<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="prism.css">
    <title>Baz JavaScript Learning</title>
    <style>
        body {
            background-color: #1f2430;
        }
    </style>
</head>

<body>
    <pre><code class="language-javascript">
// --------------------------------------------------
// JavaScript Basics for Beginners

// --------------------------------------------------
// 2.1 Variables

// By default variables in Javascript are undefined.

let name;
console.log(name);
// output:
// undefined

// Declared a variable called name, and set it to this value, a string

let name = 'Baz';
console.log(name);
// output:
// Baz

// Variable Naming Rules:

// Cannot be a reserved keyword (if, else, for, etc.)
// Should be meaningful (meaningful labels, descriptive)
// Cannot start with a number (1name)
// Cannot contain a space or hyphen
// Variables are Case Sensitive
// Using camelCase -- convention we use to name our variables

let firstName;

// you can declare multiple variables either:
// on one line and separate them with a comma

let firstName, lastName;

// can optionally initialise one, or both of them

firstName = 'Baz', lastName = 'Murphy';

// but the modern best practise is to declare each variable on a single line

firstName = 'Baz';
lastName = 'Murphy';




// --------------------------------------------------
// 2.2 Constants

let interestRate = 0.3;

// this is the initial value we can always change that later

interestRate = 1;
console.log(interestRate);
// output:
// 1

// we see the new value in the console

// However sometimes we don't want the value of a variable to change,
// because it can create bugs in our application.

// In those situations we use a CONSTANT instead of a VARIABLE

// the Value of a VARIABLE (as the name implies) can VARY
// the Value of a CONSTANT cannot CHANGE

const interestRate = 0.3;
interestRate = 1;
console.log(interestRate);
// output:
// TypeError: Assignment to constant variable.

// Here is the best practice:

// If you don't need to RE-ASSIGN CONST should be your default choice

// Otherwise if you need to RE-ASSIGN a variable use LET




// --------------------------------------------------
// 2.3 Primitive Types

// 2 types in Javascript
// PRIMITIVE(/Value) Types and REFERENCE Types

// In Primitives we have:

// STRING
// NUMBER
// BOOLEAN
// UNDEFINED
// NULL


let name = 'Baz'; // String Literal

let age = 30; // Number Literal

let isApproved = true; // Boolean Literal

// we use a Boolean in a case where we want some logic,
// so if the order is approved then it needs to be shipped,
// so the value of a boolean variable can be true or false

let firsName; // if we don't initialise it, by default its value is undefined
let firstName = undefined; // this is not very common

let lastName = null;

// we use null when we want to explicitly clear the value of a variable

// for example, we present the user with a selection of colors
// if the user has not selected a color we want it to be null

let selectedColor = null;

// in the future when the user selects a colour we are going to reassign
// this variable to a color

let selectedColor = 'red';

// These are the examples of Primitive/Value Types

// in ES6 we have another primitive SYMBOL 
// but you will learn about that later in the course.




// --------------------------------------------------
// 2.4 Dynamic Typing

// One thing that separates JavaScript from a lot of programming languages, 
// is that JavaScript is a dynamic language. 

// What do I mean by Dynamic? 

// Well, we have two types of programming languages. 

// Static languages or Dynamic languages. 

// In Static languages, when we declare a variable, 
// the type of that variable is set and it cannot be changed in the future.

// In a Dynamic language like JavaScript, the type of a variable can change at run time. 
// Let's see this in code. 

// So back in the example from the last lecture we have declared this name variable, 
// and we have set that to a string, so the type of name is currently a string, 
// but it can change in the future. 

// Let's take a look. So here in the console, we can execute some JavaScript code, 
// we have this typeof operator, and with that we can check the type of a variable. 

// So after that we add the name of the variable. 
// In this case the name variable

let name = 'Baz';
typeof name;
// output:
// string

// So note that the type of name is a string. 
// So, if you reassign name to a different value, like a number, and check it's type,
// look, the type is now changed to a number, this is what we call a dynamic language, 

let name = 1;
typeof name;
// output:
// number

// so unlike static languages the type of these variables will be determined at runtime 
// based on the values that we assign to them. 

// Now, let's take a look at a few more examples of the "typeof" operator. 
// And by the way, note that typeof is another reserved keyword, 
// so we cannot have a variable called typeof. 

// So, we can clear the console by pressing control and L. 

// So now let's take a look at typeof age, it's a number. 

let age = 30;
typeof age;
// output:
// number

// Now if we change age to a floating point number, and I know it doesn't make sense, 
// but let's just stick to this for example, 30.1,
// and then look at typeof age, it's still a number. 

let age = 30.1;
typeof age;
// output:
// number

// So in JavaScript, unlike other programming languages 
// we don't have two kinds of numbers, we don't have floating point numbers
// and integers, all numbers are of type number.

// Now, let's look at the typeof isApproved, it's a boolean as I told you before,

let isApproved = true;
typeof isApproved;
// output:
// boolean

// what about the firstName, let's have a look.

let firstName = undefined;
typeof firstName;
// output:
// undefined

// It's undefined. And that's funny, because the value of this variable is undefined
// but it's type is also undefined. What does this mean?

// Well, earlier I told you that we had two categories of types,
// we have Primitives or value types, and Reference types.

// In the Primitive types category, we have STRINGS, NUMBERS, BOOLEANS, UNDEFINED and NULL. 

// So undefined is actually a TYPE, but it's ALSO a VALUE.

// In this example, because we have set firstName,to undefined as a value 
// it's type is also undefined, 

// Okay? But what about selectedColour. Let's have a look, so;

let selectedColor = null;
typeof selectedColour;
// output:
// object

// The type of this variable is an object.

// What is an object? That's a topic for the next lecture.




// --------------------------------------------------
// 2.5 Objects

// So you have seen all the primitive types in JavaScript. 
// Now let's look at the Reference Types.

// In the Reference Types category, we have:

// OBJECT
// ARRAY
// FUNCTION

// In this lecture we're going to explore Objects,
// and you will learn about Arrays and Functions later in this section. 

// So, what is an Object. 
// An object in JavaScript and other programming languages is like an object in real life. 

// Think of a person. A person has name, age, address and so on. 
// These are the properties of a person. You have the same concept in JavaScript.

// So when we're dealing with multiple related variables, 
// we can put these variables inside of an object. 

// For example, here we have two variables name and age, they're highly related, 
// they are part of the representation of a person, 

let name = 'Baz';
let age = 30;

// so instead of declaring two variables, we can declare the person object.
// And then instead of referencing these two variables we can
// just reference the person object, it makes our code cleaner.

// So, let's see how we can declare a person object.

// We start with let or const (if we don't want to reassign the person object), 
// and set it to an object literal. 

let person = {}

// So the syntax we have here use curly braces is what we call an Object Literal. 

// Now between these curly braces we add one or more key value pairs.
// So, the keys are what we call the properties of this object. 

// In this case we want this person object to have two properties or two keys, name and age,
// So, we add name here, that's the key, 
// then we add a colon, and after that we set the value so Mosh. 
// Now, we add a comma, and add another key value pair. Age 30 

let person = {
    name: 'Baz',
    age: 30
}

// So now we have this person object with two properties or two key value pairs, name and age. 
// And with that we don't need these two variables, we delete:
// let name = 'Baz';
// let age = 30;
// Now let's log person on the console.log, Save the changes.

let person = {
    name: 'Baz',
    age: 30
};

console.log(person);
// output:
// { name: "Baz", age: 30 }

// So here's our person object, again note the Object Literal syntax,
// so we have curly braces, and in between them we have one or more key value pairs, 
// and these are the properties of the person object.

// Now, there are two ways to work with these properties. 
// Let's say we want to change the name of this person, so we need to access the name property. 

// There are two ways, the first way is what we call the DOT NOTATION.
// So, we add the name of our object in the name of this person

person.                ;

// now you can see it's properties, age, and name.

// So you can change the name of to John.

// Now we can choose the dot notation to also read the value of a property, 
// so here on line 10, instead of logging the person object we can log it's name property.
// Save the changes, and in the console we get John.

person.name = 'John';

console.log(person.name);
// output:
// John

// The other way to access a property is using Bracket Notation.

// So instead of dot we use square brackets, 
// and we pass a string that determined the name of the target property
// so single or double quotes, but single quotes are more common.

// The name of the target property is name. 
// So, we can change that to let's say Mary.
// Again when reading that we can use the dot notation or the bracket notation.
// If you save the changes, now we get mary on the console.

person['name'] = 'Mary';

console.log(person['name']);
// output:
// Mary

// Now you might be asking, which approach is better?
// Dot Notation or Bracket Notation? 

// Well as you can see, dot notation is a bit more concise. 
// It's shorter, so that should be your default choice.

// However, bracket notation has it's own uses, sometimes, you don't know the name of the
// target property until the run time.

// For example, in our user interface, the user might be selecting the name of the target property.
// In that case, at the time of writing code, we don't know what property we're going to access. 
// That is going to be selected at run time by the user.

// So we might have another variable somewhere else like selection, 
// that determines the name of the target property that the user is selecting, 
// and that can change at run time.

// With this, we can access that property using the bracket notation in a dynamic way.
// So, we pass selection here, and we get the same result.


let selection = 'name';
person[selection] = 'Mary';

console.log(person['name']);
// output:
// Mary

// Now, if this is confusing, don't worry, we're going to see this again in the future, 
// as you gain more experience with JavaScript.

// For now, just stick to the dot notation, because that's cleaner and easier. 

// Next we're going to look at Arrays.




// --------------------------------------------------
// 2.6 Arrays

// Sometimes in your applications, you might be dealing with a list of objects.

// For example, the list of products in a shopping cart,
// or the list of colors the user has selected,
// In situations like that, you use an ARRAY to store that list.
// Let me show you how.

// So here I'm going to declare another variable called selectedColors. 
// Note that I'm using a meaningful name, I don't have sc or some other weird name.

// Now we can initialize this, and set it to an empty array.
// So these square brackets are what we call Array Literal, and they indicate an empty array.

let selectedColors = [];

// Now we can initialize this array and add a couple of items, like red and blue.

let selectedColors = ['red', 'blue'];

// Let's log this on the console, so Save the changes, 
// so here's our array with two elements.
// We can expand that, note that each element has an index,
// and that determines that position of the element in that array. 

console.log(selectedColors);
// output:
// 0: "red"
// 1: "blue"

// So, the index of the first element is 0, 
// and the index of the second element is 1.
// So if you want to access an element in an array, we use this index.

// Here's how. 
// For example, let's say you want to display the first element in this array, 
// we use these square brackets, and then specify the index.
// Save the changes, and now we have red.

console.log(selectedColors[0]);
// output:
// red

// Now earlier, I told you that JavaScript is a dynamic language.
// So the type of variables can change at run time. 
// The same principle applies to our arrays. 

// So the length of arrays as well as the type of objects we have in an array are dynamic, 
// they can change.

// So, on line 2, we initialize this array with 2 elements, right? 
// Now, on line 3 we can add another element to this array, so the array will expand.
// So, let's say 

selectedColors[2] = 'green';

// that means the third item in this array will also be green.
// Now, let's display this array on the console, 

let selectedColors = ['red', 'blue'];
selectedColors[2] = 'green';
console.log(selectedColors);
// output:
// (3)["red", "blue", "green"]

// so, we have an array with 3 elements. 
// So the length is dynamic, it can change

// Also the type of objects we have in this array is dynamic, 
// so unlike other programming languages, where every item or
// every object in the array, should have the same type, 
// in JavaScript we can store different types in an array. 

// So, we can make the last element a number.

selectedColors[2] = 1;
console.log(selectedColors);
// output:
// ["red", "blue", 1]

// Save the changes, now we have 2 strings and a number.

// So the objects in the array as well as the size of the array are dynamic.

// Now technically an array is an object, 
// so just like the person object we defined in the last lecture
// it has a bunch of key value pairs, or properties that we can access using the dot notation.

// Let me prove that to you.
// So here on the console, let's look at the type of selectedColors.

typeof selectedColors;
// output:
// "object"

// So the type of this array is an object.
// So an array is an object in JavaScript.

// So here on line 4, we can look at the properties of this array, or this object, 
// using the dot notation

selectedColors.         ;

// look these are  all the properties defined in arrays in JavaScript, 

// So, every time we declare an array using square brackets, 
// that array will automatically receive these properties, 
// we didn't explicitly define them, 
// they are just somehow magically inherited from somewhere else.

// We're going to learn about that later when we talk about prototypes.

// Now in this lecture, we're going to look at one of these properties.

// That is the length property.

// This property returns a number of items or elements in an array.
// So, save the changes, you can see we have three elements in this array.

console.log(selectedColours.length);
// output:
// 3


// Now later in the course, we have a comprehensive section about arrays, 
// you will learn about all kinds of operations you can perform on arrays,
// for now, all I want you to take away is

// an ARRAY, is a data structure, that we use to represent a list of items.




// --------------------------------------------------
// 2.7 Functions

// In the category of Reference Types, you have learned about Objects and Arrays. 
// Now, let's take a look at Functions.

// Functions are one of the fundamental building blocks in JavaScript. 

// A function is basically a set of statements that performs a task or calculates a value. 

// Let me show you a couple examples. 
// So I'm going to declare a function using the function keyword.

// Now we need to give it a name, let's call that greet. 

// After that we need to add parenthesis, 
// that's part of the syntax for declaring functions.
// And then curly braces.

function greet() {

}

// Now what we have here, inside the curly braces is what we refer 
// to as the BODY of this function. 
// And this is where we add all the statements to define some kind of logic in our application. 

// For example, The logic for this function should be to display a message on the console. 
// So here we can add:

function greet() {
    console.log('Hello World');
}

// Now note that here we have a statement, so we terminate it with a semi colon, 
// but when we are declaring a function, we DON'T NEED TO ADD semi colon at the END, 
// because we are not declaring it like a variable like this. Okay.

// This is a function declaration, right. 

// So, now we have a function we can call this function like this. 

// So we add the name of the function, and parenthesis again, 
// and then semi colon to indicate that this is a statement. 

greet();

// Save the changes, now we have Hello World on the console.
// But that's pretty boring, what would we do with this? 
// Let me show you how to make this more interesting.

// Our functions can have inputs, and these inputs can change how the function behaves.

// So, let's say instead of displaying Hello World 
// we want to display the name of the person here. Like Hello John.

// So we can add a variable here in between parenthesis, 
// we refer to this variable as a PARAMETER.

function greet(name) {
    console.log('Hello World');
}

greet();

// So, this greet function has one parameter called name, and essentially name is 
// like a variable that is only meaningful inside of this function.

// So inside of this function we can work with this name variable but 
// it will not be accessible outside of this function.

// Now name is an input to this function.

// So instead of displaying Hello World you can display Hello then add a plus here 
// to concatenate two strings.

// So, we can add name after.

function greet(name) {
    console.log('Hello' + name);
}

greet();

// Now, when calling the greet function, 
// we need to pass a value for the name variable,
// or name PARAMETER more accurately. 
// So, we can pass John here, 
// now we refer to this as an ARGUMENT.

// So John is an ARGUMENT to the greet function 
// and name is a PARAMETER of the greet function

// it's one of the things that a lot of programmers don't know. 
// They don't know the difference between a PARAMETER and an ARGUMENT.

// So a parameter is what we have here at the time of declaration (name),
// but the argument is the actual value of supply for that parameter ('John').

// Okay? 
// Now, I save the changes, so we have Hello John.

function greet(name) {
    console.log('Hello' + name);
}

greet('John');
// output:
// Hello John

// Now we can reuse this function but with a different input.
// So, we can change this line here and change John to Mary.
// Save the changes now we have two different messages on the console.

function greet(name) {
    console.log('Hello' + name);
}

greet('John');
greet('Mary');
// output:
// Hello John
// Hello Mary

// Now a function can have MULTIPLE PARAMETERS.
// So here we can separate parameters using a comma, so let's add another parameter, like lastName, 
// now we can change our console.log add a space here, and then display the lastName.

// Now, when calling this greet function, we should pass another argument for the last name.
// Well let's see what happens if we don't do this. 
// So I'm going to save the changes, see what we got 

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}

greet('John');
// output:
// Hello John
// undefined

// Because as I told you before that the fault value of variables in JavaScript is undefined.
// So because we did not pass a value for the last name, by default it's undefined.

// So I'm going to pass another argument here, 
// we separate them using comma John Smith 
// and we don't need this second call to the greet function.
// Save the changes, now we have Hello John Smith.

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}

greet('John', 'Smith');
// output:
// Hello John Smith




// --------------------------------------------------
// 2.8 Types of Functions

// Now there is a cleaner way to write this code on line 3, 
// all this concatenations are kind of ugly, they're getting in the way, 
// later in the course I will show you how to use template literals to 
// clean up this code. 
// For now, don't worry about it, let's look at another example of a function.

// This function we have here is performing a task. 
// This task is to display something on the console. 

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}
greet('John', 'Smith');

// But sometimes our functions might calculate something, so, 
// here is an example of a function that calculates a value. 

// So again, function, let's call this function square, 
// this function should take a parameter, let's call that number, 
// now we need to calculate the square of that number, that is number times number.
// Just basic math. Right? 

function square(number) {
    number * number;
}

// Now we need to return this value to whoever is calling this function. 
// For that we use the RETURN KEYWORD. 
// That's another reserve keyword so we cannot have a variable called return, okay? 

function square(number) {
    return number * number;
}

// Now instead of calling the greet function, let's call the square function. 
// So, square, we pass 2, now this returns a value so we can use that value to initialize a variable.

function square(number) {
    return number * number;
}

square(2);

// For example, you can declare another variable called result, and set it to a square of 2.
// And then we can display that on the console. Save the changes, so we get 4. 

function square(number) {
    return number * number;
}

let result = square(2);
console.log(object);
// output:
// 4

// Now, in this particular example, 
// we don't necessarily have to declare a separate variable (result) 
// if all we want to do is display the square of 2 on the console. 
// We can exclude this variable declaration (let result =)
// and simply pass square(2) to console.log.

// So, when the JavaScript engine executes this code, 
// first it's going to call this function, 
// it will get a value and then pass that value to console.log.
// Save the changes and look we still get 4.

function square(number) {
    return number * number;
}

console.log(square(2));
// output:
// 4

// Now, I have a question for you. 

// How many function calls do you think we have in this code? 

// We have 2 function calls. 

// Square of 2, is one function call, 
// but console.log is also another function call, 

// right? Because here we have parenthesis, so, we're calling the log function, 
// which is defined somewhere, and passing an argument, 
// we can pass a simple string, like Hello, 
// or we can pass an expression, that expression can be a call to another function, like square of 2.
// Okay? 

// So this is the basics of functions. 
// Again, later, in the course we have a comprehensive section about functions, 

// for now, all I want you to take away is that

// a FUNCTION is a set of statements that either performs a task, 
// or calculates and returns a value. 

// A real world application is essentially a collection of hundreds or thousands 
// of functions working together to provide the functionality of that application.




// --------------------------------------------------
// 3.1 JavaScript Operators

// So you have learned how to declare variables and constants, 
// now let's take a look at OPERATORS.

// In JavaScript we have different kinds of Operators. 

// We use these operators along with our variables and constants to create expressions. 
// And with these expressions we can implement logic and algorithms.

// [Variables+Operators] --> [Expressions] --> [Algorithms]

// So here are the different kinds of operators in JavaScript. 
// We have:

// ARITHMETIC operators, 
// ASSIGNMENT operators, 
// COMPARISON operators 
// LOGICAL operators, 
// BITWISE operators. 

// Over the next few lectures, you're going to learn each of these in detail.




// --------------------------------------------------
// 3.2 Arithemetic Operators

// The first category of operators we're going to look at is ARITHMETIC OPERATORS.
// We use this for performing calculations, just like the calculations in mathematics, 
// so here we have two variables x and y, 
// let's take a look at all the arithmetic operators in JavaScript. 

let x = 10;
let y = 3;

// So I'm going to do a console.log, 
// here's the first example, x plus y, 
// that is the addition operator.

console.log(x + y);

// So these arithmetic operators usually take two up OPERANDS in this case x and y. 
// And then produce a new value.

// What we have here is "x + y" is what we refer to as an EXPRESSION in JavaScript. 

// So an EXPRESSION is something that produces a value. 

// So here's the addition operator. 

// We also have subtraction.

console.log(x - y);

// We have multiplication:

console.log(x * y);

// Division:

console.log(x / y);

// And remainder of division: 

console.log(x % y);

// So just like basic arithmetic operators in mathematics

// We have a new operator in JavaScript that is exponentiation
// it's indicated by two stars, and that is x, to the power of y. 

console.log(x ** y);

// So these are pretty straight forward 

// we have two additional arithmetic operators that are a little bit more tricky.

// So I'm going to focus on those. 
// For now I'm going to comment out these few lines, you can do that by selecting a piece of code, 
// and pressing command and / on Mac, or control and / on Windows.

// So, these two other operators, are INCREMENT and DECREMENT operators

// let's see how they work. 
// So increment is indicated by two plus signs, 
// and DEPENDING ON WHERE WE PUT the plus signs this operator will behave DIFFERENTLY.

// So I'm going to do a console.log of x, 
// x is initialized to 10, so if I save the changes, we see 10 on the console.

let x = 10;

console.log(x);
// output:
// 10

// Now, if I put the increment operator BEFORE x 
// the value of x will be incremented by 1 first 
// and then we will see that on the console.
// Let's take a look so save the changes, see we get 11.

let x = 10;

console.log(++x); // applied before
// output:
// 11

// In contrast, if you put this operator AFTER x, 
// we will see x on the console first, 
// and then the value of x will be incremented by 1. 
// Have a look, save the changes we see 10, but at this point x is incremented by 1,

let x = 10;

console.log(x++); // applied after
// output:
// 10

// so if we do another console.log of x, now we should see 11. 
// Have a look. Here it is. 

let x = 10;

console.log(x++); // applied after
console.log(x);

// output:
// 10
// 11

// The DECREMENT operator is pretty similar.
// So, instead of two plus signs, we have two minus signs, 
// and here I'm gonna apply this before x, 
// so we're going to decrement the value of x by 1, 
// and then display it on the console.

let x = 10;

console.log(--x); // applied before

// output:
// 9

// So for this demo, I'm going to comment out these two lines, have a look, 
// we see 9 on the console, because we apply this operator first and then displayed x on the console. 

let x = 10;

console.log(x--); // applied after
// output:
// 10

let x = 10;

console.log(x--); // applied after
console.log(x); // then logged
// output:
// 10
// 9

// So these are all the arithmetic operators we have in JavaScript. 

// To recap, we have 
// addition, subtraction, multiplication, division, remainder of division, 
// exponentiation which is x to the power of y, as well as increment and decrement operators.




// --------------------------------------------------
// 3.3 Assignment Operators

let x = 10;

// The second category of operators we're going to look at is Assignment Operators.

// We have already seen an example of an assignment operator. 
// So here, we are using the simple assignment operator to assign a value in this case 10 to x, 
// but we have a few more assignment operators. Let me show you. 

// So in the last lecture you learned about the increment operator.  
// With this we increment the value of x by 1. 
// This expression here is exactly equivalent to this.

x++;
x = x + 1;

// So, we read the value of x, add 1 to it, and then using the assignment operator, 
// assign this new value to x.

// But what if in this example instead of adding 1 to x we want to add let's say 5. 

x = x + 5;

// Well, this increment operator x++ will not work. 

// So, how can we do that.
// Well this is one simple way, but we have a short hand, 
// we can use the addition, assignment operator like this. 

x += 5;

// So line 5, and line 4 are exactly the same.

// Here's another example. Let's imagine we want to multiply the value of x by 3. 
// So, we can write it like this

x = x * 3

// or we can use the multiplication assignment operator like this.

x *= 3;

// So all the other arithmetic operators you learned about in the last lecture, 
// addition, subtraction, division, multiplication, and the remainder operators, 
// all of them have this combination with the assignment operator.




// --------------------------------------------------
// 3.4 Comparison Operators

// Alright now let's take a look at comparison operators. 


// As the name implies we use these operators to compare 
// the value of a variable with something else.

// So here we have x set to 1
// Let's look at the first comparison operator, that is greater than. 
// So we want to check if x is greater than 0.
// I'm going to save the changes, look what we get, true.

let x = 1;

console.log(x > 0);
// output:
// true

// So the RESULT of an EXPRESSION that INCLUDES a COMPARISON OPERATOR is a Boolean,
// it's True or False. 

// Now, let's look at another example, 
// this second operator is greater than or equal to
// so we can change 0 to 1 to see if x is greater than or equal to 1.
// Obviously it is, so save the changes to get true again.

let x = 1;

console.log(x >= 1);
// output:
// true

// The other operators are very similar.
// So we have less than as well as less than or equal to.
// Now let's save the changes. Look at what we get on the console.

let x = 1;

console.log(x < 1);
console.log(x <= 1);
// output:
// false
// true

// So the third item is false, because x is not less than 1.
// It's less than or equal to 1, that's why we got a false here.

// So these 4 operators we have here, you refer to them as RELATIONAL operators.

// We also have EQUALITY operators,

// so we can check to see if x is equal to 1.
// So we have triple equal signs.
// Save the changes, obviously x is 1, that's why we get true.

let x = 1;

console.log(x === 1);
// output:
// true

// Now if you want to check if x is not equal to a given value,
// you replace the first equal sign with an exclamation mark.
// So, let's save the changes, 
// the result of the last expression is false, because x is equal to 1.

let x = 1;

console.log(x !== 1);
// output:
// false

// So these are all the COMPARISON OPERATORS in JavaScript.




// --------------------------------------------------
// 3.5 Equality Operators

// In the last lecture you learned about the equality operator.

console.log(1 === 1);

// Now technically in JavaScript we have ANOTHER equality operator,
// that is indicated by 2 EQUAL SIGNS instead of 3 EQUAL SIGNS. 

console.log(1 == 1);

// So you might be wondering what the difference is.

// Well, first of all what we have on the top is what we refer to as STRICT EQUALITY OPERATOR.
// What we have on the bottom is what we call LOOSE EQUALITY OPERATOR. 

// Now this STRICT equality operator ENSURES that both these values we have
// on the sides of this operator have the SAME TYPE and SAME VALUE.

// What do I mean by that? 
// Well, in this example, on both sides of this operator we have two numbers. 
// so their type as well as their value are equal. 
// So if you save the changes, we get true and true. 

// Strict Equality Operator (Type + Value)
console.log(1 === 1);
// Loose Equality Operator ()
console.log(1 == 1);
// output:
// true
// true

// Now, let's take a look at another example, this time, 
// I'm going to change one of these numbers to a string. Now if I save the changes, 
// this expression is going to evaluate to false because here we're comparing a string to a number.
// So the types here do not match, that's why we'll get false.
// Let's have a look. Save, and here's false, right? 

console.log(1 === 1);
console.log('1' === 1);

// output:
// true
// false

// So the strict equality operator ensures that both operands are of the 
// same type and of the same value.

// Now LOOSE equality operator behaves DIFFERENTLY.

// So, to focus on this operator, I'm going to comment out these two lines, 
// so here we're comparing one with one, and we get true. 

// Now, what if we compare 1 as a string with 1.
// We still get true. In contrast, in a previous example, we got false. 

console.log(1 == 1);
console.log('1' == 1);
// output:
// true
// true


// So let's see what's happening here.
// In this case, this operator looks at the value on the left side. 
// Here we have a string, so it will automatically convert what we have on the right side, 
// to a string, so it will look like this, 
// and now because these values are exactly the same,
// we get true on the console.

console.log('1' == '1');
// output:
// true

// Now what if on the left side we have a boolean
// well, this operator, looks at what we have on the left side, 
// because it's a boolean, it will automatically convert the value on the right side to a boolean. 
// So, it's like comparing true with true. And if you save the changes, again we get true. 

console.log(true == 1); // console.log(true == true); CONVERTS THE 1 TO TRUE
// output:
// true

// So here's what you need to take away. 

// The STRICT EQUALITY OPERATOR ensures that BOTH VALUES have the SAME TYPE and the SAME VALUE. 

// The LOOSE EQUALITY OPERATOR doesn't care about the types matching, if the types don't match, 
// it will convert the type of what we have on the right side to match what we have on the left side. 
// And THEN it will only check if the values are equal.

// Now most of the time, we should be using the strict equality operator, because it's more
// precise and accurate.

// FINAL CODE
// Strict Equality (Type + Value)
console.log(1 === 1);
console.log('1' === 1);
// Loose Equality (Value)
console.log(1 == 1);
console.log('1' == 1);
console.log(true == 1);
// output:
// true
// false
// true
// true
// true




// --------------------------------------------------
// 3.6 Ternary Operators

// Now let's take a look at the TERNARY or CONDITIONAL OPERATOR, 
// which is one of my favorite operators in JavaScript. 

// Let's imagine we want to implement a rule like this.
// If a customer has more than 100 points, they are a gold customer
// otherwise, they are a silver customer, how do we implement this?

// Well, first I want to start by declaring a variable to keep track of the number of points. 
// So, let points we set that to let's say 110, now we want to declare another variable 
// called type that represents the type of customer, 
// and here is where we use the ternary or conditional operator.

let points = 110;

// So this is how it works, first we start with a condition. 
// We want to compare the number of points with hundred, 
// so we use the comparison operator here, points greater than 100. 

let type = points > 100 // (points > 100) IS AN EXPRESSION

// Now as you learned earlier, this expression produces a boolean.
// So the result of this expression is either true or false.

// Now depending on the result, we're going to set this type variable to a different value. 
// So here we add a question mark, now if this expression value is to true, 
// that means this is a gold customer, so we want to set type to gold.

// Otherwise, if this expression devalues to false, we want to set the type to silver.

let type = points > 100 ? 'gold' : 'silver';

// So this is the ternary or conditional operator, 
// we start with a condition, 
// if that condition evalues to true, we use this value (gold), 
// otherwise we use this other value (silver).

// Now, let's log type on the console, save the changes, so we have a gold customer,
// in contrast, if I change the number of points to 90, and save the changes, we get a silver customer.

let points = 110;
let type = points > 100 ? 'gold' : 'silver';

console.log(type);
// output:
// gold

let points = 90
let type = points > 100 ? 'gold' : 'silver';

console.log(type);
// output:
// silver




// --------------------------------------------------
// 3.7 Logical Operators with Boolean Values

// Alright now let's take a look at the LOGICAL OPERATORS. 

// We use these operators to make decisions based on multiple conditions.
// In JavaScript we have three types of logical operators, 

// LOGICAL AND  &&
// LOGICAL OR   ||
// LOGICAL NOT  ! 

// Let's see each of these operators in action. 

// So I'm going to start with the LOGICAL AND which indicated by &&
// So here's the basic rule of thumb.

// This LOGICAL AND RETURNS TRUE IF BOTH OPERANDS ARE TRUE. 

// What do I mean by that?
// Well, let's do a console.log, true and true. 

// So we have two operands, they are both true, 
// so the result of evaluating, this expression will be true. 
// Let's have a look on the console. Look, here we get true. 

console.log(true && true);
// output:
// true

// Now if either of these is false, the result will be false, 
// so I'm going to change this to false, save the changes, 
// note that we get false on the console, 

console.log(false) && true);
// output:
// false

// it doesn't matter which one is false, if I make the other one false, 
// or both of them false, we'll still get false. 

// So LOGICAL AND returns true if BOTH operands are true. 

// Now you might be asking what is a real world use case for this operator? 

// Well, let's imagine we want to build an application for approving loans.
// So we want to see if the applicant has high income and a good credit score, 
// then they will be eligible for loans. 

// So, I'm going to delete all this, and declare a couple variables, 
// high income, we're going to set that to true, 
// and good credit score, we're going to set that to true as well.

let highIncome = true;
let goodCreditScore = true;

// So here we're dealing with two conditions, 
// we want to make sure that the applicant has high income, and good credit score.

// That's where we use the LOGICAL AND.

// So we can declare another variable, eligibleForLoan 
// and this is where we use the logical and operator.
// So high income && goodCreditScore.

// Now, if we log this on the console, eligible for loan, we should get true, 
// and here's the result, 

let highIncome = true;
let goodCreditScore = true;

let eligbleForLoan = highIncome && goodCreditScore;

console.log(eligbleForLoan);
// output:
// true

// Now let's take a look at the LOGICAL OR. 
// So, LOGICAL OR is indicated by two vertical lines ||
// and this RETURNS TRUE IF ONE OF the operands is True. 
// It doesn't matter which one, whether the one on the left, or the one on the right or both of them, 
// as long as we have one true operand, the result of this expression will be true. 

// So here's an example. 
// I'm going to replace this logical and with logical or, 
// now in this case both operands are true, so the result of this expression will also be true. 
// Let's have a look. So I'm going to save the changes to get true, 
// now if I set one of these to false, we still get true.

let highIncome = true;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

console.log(eligbleForLoan);
// output:
// true


let highIncome = false;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

console.log(eligbleForLoan);
// output:
// true

// It doesn't matter which one is true.
// As long as we have one operand in this expression that evalues to true, 
// the result of this expression will also be true. 

// So this is how we use the logical or. 

// And finally, let's look at the LOGICAL NOT OPERATOR. 
// That is indicated by an exclamation mark !

// So let's imagine if the applicant is not eligibleForLoan, 
// we want to consider the application as refused.

// So we can declare another variable applicationRefused 
// here we use the NOT OPERATOR we apply it on eligibleForLoan, 

let highIncome = false;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

let applicationRefused = !eligbleForLoan; // this converts it to the opposite

console.log(eligbleForLoan);
// output:
// true

// so this is what happens here..
// If eligibleForloan is true, this not operator will convert that to false.

// So whatever we give it, it will give us the opposite, 
// in this case if eligibleForLoan is true, this will convert that to false, 
// and applicationRefused will be false.

// Because if someone is eligible for a loan, we don't want to refuse their application, right?

// So applicationRefused, is always the opposite of eligibleForLoan, 
// and that's where we used the NOT OPERATOR. 

// So let's see this in action. I'm going to change both these conditions to false. 
// So we're dealing with someone who has low income and a bad credit score, 
// obviously they are not eligible for a loan, so let's log this on the console,
// eligibleForLoan, and we can also add a label so I'm going to add a string, Eligible, 
// and here we add comma, then we apply the not operator, to set the application refused variable, 
// let's do another console.log, application refused, and here we log application refused variable.
// Now let's see what we get on the console, so save the changes

let highIncome = false;
let goodCreditScore = false;

let eligbleForLoan = highIncome || goodCreditScore;

console.log('Eligible', eligbleForLoan);

let applicationRefused = !eligbleForLoan; // this converts it to the opposite

console.log('Application Refused', applicationRefused);
// output:
// Eligible false
// Application Refused true

// you can see if this applicant is not eligible because eligible is false, 
// and application refused is true because it's always the opposite of eligible for loan.




// --------------------------------------------------
// 3.8 Logical Operators with Non-Boolean Values

// In the last lecture you learned about logical operators, 
// in all the examples you saw in the last lecture, 
// we used these logical operators with boolean values. 

// But in JavaScript, UNLIKE in many programming languages, 
// WE CAN USE THESE LOGICAL OPERTORS WITH NON BOOLEAN VALUES.
// And that's extremely powerful. 

// Let me show you a few examples.
// Let's say we have false or true.
// What do you think is the result of this expression? 
// Well, it's true, right?

false || true
// output:
// true

// Now what if we have false or the string Mosh? 
// What do you think is the result of this expression? 
// Well let's take a look, we get Mosh back

false || 'Mosh'
// output:
// "Mosh"

// what if we have false or number 1? 
// We get number 1 back.

false || 1
// output:
// 1

// So here's the first thing you need to realize, 
// THE RESULT OF A LOGICAL EXPRESSION IS NOT NECCESSARILY a true or a false.
// That DEPENDS on the VALUE of the OPERANDS we have. 

// In the first example our second operand is true, that's why we get true back.
// In the second example, our second operand is a string, that's why we get a string back, 
// and by the same token, in the third example. We get a number back. 

// So when our JavaScript engine tries to evaluate this expression, 
// it looks at each operand, if that operand is not a boolean true or false, 
// it will TRY TO INTERPRET IT AS TRUTHY OR FALSY, 

// so in JavaScript we have these values which we refer to as FALSY, 
// that's NOT a boolean false, it's FALSY.

// What are these Falsy values? Well we have:
undefined
null
0 // number 0
false // boolean false
'' // an empty string
NaN // Not a Number

// Now we haven't talked about this yet, that's going to come later in the course, 
// for now, just remember, Not a Number is a special value in JavaScript, 
// and when we are dealing with a mathematical calculation that does not produce a valid number,
// this value is returned, NaN "Not a Number". 
// Now we're going to look at that later in the course, so don't worry about it. 

// So these are the Falsy values in JavaScript, 
// IF WE USE ANY OF THESE VALUES IN A LOGICAL EXPRESSION THEY WILL BE TREATED AS FALSY
// which is kind of like a boolean false, but it's not exactly the same.

// Now, ANYTHING THAT IS NOT Falsy IS Truthy.

// So, back to these examples.

// In the second example, our second operand is a string with 4 characters.

false || 'Mosh'
// output:
// "Mosh"

// Truthy

// So this is not an empty string, it's not Falsy, so it's Truthy. 
// So when our JavaScript engine tries to evaluate this, it looks at the first operand
// it's false, so the search continues, because with a logical or operator, 
// as you learned in the last lecture, as long as one of the operands is true 
// the result will be true. 

// Now here in the second example, the first operand is false, so the search continues
// hoping that maybe the other operand is true or Truthy.

// In this case 'Mosh' we are dealing with a Truthy value, 
// so this value is immediately returned. 

// The same goes for third example. So here 1 is not a boolean true, it's Truthy,
// that's why the value of this operand is returned.

false || 1
// output:
// 1

// Truthy

// Now, what if we have an expression like this

false || 1 || 2
// output:
// 1

// What do you think we're going to get? Let's take a look. You get 1. 

// So this is another thing you need to understand about the logical or operator. 
// The EVALUATION starts here (at the false), AS SOON AS WE FIND AN OPERAND THAT IS TRUTHY,
// THAT OPERAND IS RETURNED, so here our second operand (1) is Truthy, 
// it's value is returned, and here the evaluation stops (at the 1).

// It doesn't matter what we have on the right side (2 etc), 
// we could have a million other operands, they are completely ignored, 
// this is what we call SHORT-CIRCUITING. 
// Just exactly like short circuiting that we have in electricity.

// Now that you understand how these logical operators work with non-boolean values,
// let me give you a real world example on when to use this. 

// So let's imagine an application, and somewhere the user has to pick a color, 
// or we're going to use a default color.
// Maybe this is the color of the t-shirt they want to buy. 

// So, I'm going to declare a few variables, userColor. We set that to red, 
// defaultColor we set that to blue, 
// and currentColor, which we set to userColor or defaultColor. 

let userColor = 'red';
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

// Now let's read this exprsssion in plain English. 
// userColor or defaultColor that basically means 
// if we have a value for userColor we're going to use that,
// if we don't, we're going to use the defaultColor.
// Now, let's log this on the console.

let userColor = 'red';
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

console.log(currentColor);
// output:
// red

// So currentColor we get red.
// Because our user has selected a color.

// In contrast, if the user has not selected a color, let's set this to undefined,
// save the changes, we get blue. Because defaultColor is blue.

let userColor = undefined;
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

console.log(currentColor);
// output:
// blue

// So this is the POWEER OF USING THE LOGICAL OR OPERATOR, BETWEEN NON-BOOLEANS.
// With this technique, we can provide default values.

// So if the user has selected a color, we're going to use that 
// otherwise we're going to use our defaultColor and that determines
// the current color which we are going to display on the screen.




// --------------------------------------------------
// 3.9 Bitwise Operators

// Finally, the last group of operators we're going to look at is BITWISE OPERATORS.

// Now, this really requires me to go beyond the scope of this course, 
// I have to talk about some computer science stuff, 
// and honestly I don't really want to bore you, 
// because this stuff doesn't really have that much practical usage in the real world, 
// I'm not saying they're useless, they definitely have their own use, 
// but they are more on the theoretical side 
// and it's not something that you will use on a daily basis. 

// However, if you're really enthusiastic, 
// I'm going to explain what bitwise operators are, 
// and how they work, but feel free to skip this lecture if you just want to focus on the practicality. 

// So you know that we humans use the decimal system to represent numbers. 
// So 12345. 
// But in computers, these numbers are stored in the binary format, 
// which is a combination of 0's and 1's. 

// So let's take a look at a few examples. 
// The number 1 in the decimal system, is represented as 
1 = 00000001

// So we have 8 digits, each digit is what we call a bit, 
// so here we have 8 bits, which represents 1 byte of information in a computer. 

// Here's another example. 
// Number 2 in the decimal system equals to 
2 = 00000010

// There are mathematical formulas behind this, for converting numbers between decimal
// and binary systems, if you don't want to learn the mathematics, you can simply
// Google decimal to binary converter.

// Now, bitwise operators in JavaScript or any other programming languages, 
// are similar to logical operators, but they work in the individual bits of a number.

// Let me show you what I mean by this.

// So, I'm going to do

console.log(1 | 2);

// Note that here we have a single vertical line |
// that represents a Bitwise OR 
// logical or's have double vertical lines ||

// So when we apply the BITWISE OR between 1 and 2, 
// this is what's going to happen. 
// So, I add r as the result here.

1 = 0000001
2 = 0000010

R = 0000011

// Now, this operator is going to look at each of these bits like this,
// in a vertical way, 
// if either of these bits is 1, the result will be 1, otherwise it will be 0. 
// So here, in both these numbers, the first 6 bits are 0, 
// so, in the result you also have 6 0's.

// Now the 7th bit will be 1, because here (at the 7th digit of 2) 
// we have 1 at this position, right? 
// And similarly, the 8th bit will be 1, because here (at the 8th digit of 1) 
// we have a 1.
// Now if we convert this binary number to a decimal number the result will be 3. 

// So let's save the changes and you can see on the console we have 3.

console.log(1 | 2);
// output:
// 3


// Bitwise AND is similar.
// So let's duplicate this, BITWISE AND will use a single ampersand for that &

console.log(1 & 2);

// Now the result is going to be something like this.
// So, if both numbers are 1, 1 will be returned otherwise will be 0. 

1 = 0000001
2 = 0000010

R = 0000000

// So in this case all the bits will end up being 0, 
// because if you look if you look at these two first numbers, 1 and 2,
// their first 6 bits are 0,
// and here in the second number (2) we have this bit that is 1 (at the 7th digit of 2),
// but the bit at the equivalent position (at the 7th digit of 1) here is 0. 

// So if we apply the Bitwise AND between these two bits the results will be 0, okay?
// So, this binary number equals 0 in the decimal system. 
// So save the changes, and see this on the console. Save, here it is.

console.log(1 & 2);
// output:
// 0

// So this is the fundamentals of BITWISE OPERATORS.
// Now in JavaScript we have a few more bitwise operators,
// but in the real world they are not that common.

// Now let me give you a real world example of when we can use these bitwise operators 
// so at least they make sense to you.

// Imagine we want to implement an access control system. 
// So the user can have these permissions, read, write or execute.

// Now we can use 1 BYTE of information, or 8 BITS, to determine the kind of information
// a user can have. For example, we can use 5 0's, we don't care about the first 5 bits, 
// but for the other 3 bits, if the user has a permission we will use 1, 
// otherwise we will use 0.

// So if the user has only the read permission, you will use 1 for the read, 
// and for write and execute you will use 0.

Read = 00000100

// Similarly if the user has read and write permissions.
// We can represent this permission using this binary number. 

Write = 00000110

// And finally if the user has all these permissions. 
// We can represent that like this.

Execute = 00000111

// Now, this is where we use bitwise operators.

// Let's see how we can implement these access control system, using bitwise operators.

// So, I'm going to define a constant called readPermission,
// now I need to set this to a decimal number that is equivalent to this binary number.
// That decimal number is 4.
// Again, you can use an online converter to get this.

// just the Read flag on = 00000100

const readPermission = 4;

// Similarly I'm going to define another constant, writePermission
// now what I want now is the decimal representation of this binary number.
// So all these bits or flags are off, only the right flag is on it, okay? 

// just the Write flag on = 00000010

const writePermission = 2

// So this binary number, is equivalent to 2 in the decimal system.

// And finally, executePermission.
// So what we want is the decimal representation of this binary number.
// All these flags are 0, oney the execute flag or execute bit is 1. 
// And that number is 1.

// just the Execute flag on = 00000001

const executePermission = 1;

// Now, I can declare a variable like myPermission inititally set that to 0, 
// now I can give myself extra permissions.

let myPermission = 0;

// So, I can update my permission like this, myPermission, here we apply the bit
// wise or to add a permission like readPermission, as well as the writePermission.

myPermission = myPermission | readPermission | writePermission;

// Now let's take a look at the value of my permission on the console.
// So, we get 6. 

console.log(myPermission);
// output:
// 6

// Now technically, we don't care about this decimal number, 
// we can use the bitwise and operator to see if I have a given permission.

// So here's an example, I'm going to declare a variable, 
// let's call that message, now here I'm going to use the ternary operator, 
// the conditional operator, remember? 

// So we start with a condition, we take myPermission, 
// and use the bitwise and operator along with readPermission.

let message = (myPermission & readPermission)

// Now, if this evalues to true, that means I have the readPermission.
// So, let's say you want to display a message like yes, otherwise we want to display no.

let message = (myPermission & readPermission) ? 'yes' : 'no';

// So here's our ternary operator.
// You have a condition, if that evalues to true, this value will be used, 
// otherwise this value will be used.

// Finally, let's log this message on the console.

console.log(message);
// output:
// yes

// So I have the readPermission. 
// But if I move this readPermission here, and save the changes. 
// Now, you can see our readPermission is gone.

const readPermission = 4;
const writePermission = 2;
const executePermission = 1;

let myPermission = 0;
myPermission = myPermission | writePermission // readPermission deleted

let message = (myPermission & readPermission) ? 'yes' : 'no';

console.log(message);
// output:
// no

// So here's what I want you to take away. 

// With the Bitwise OR operator, we can add permissions, 
// and with the Bitwise AND operator, we can check to see if we have a given permission.

// Of course this is just 1 real world use case for using the bitwise operators, 
// there are other use cases but as I told you before, they are really not that common, 
// so if this lecture was confusing, don't worry about it.




// --------------------------------------------------
// 3.10 Operators Precedence

// When working with complex expressions, 
// one thing that you need to account for is the PRECENDENCE OF OPERATORS. 

// Let me show you an example. 
// So, let's declare x and set it to 2, plus 3 x 4.

let x = 2 + 3 * 4;

// What do you think is the result of this expression. 
// Well, let's log this and have a look. So, we get 14. 

let x = 2 + 3 * 4;

console.log(x);
// output:
// 14

// The reason for that is because the multiplication operator has HIGHER PRECEDENCE 
// so this expression is evaluated first, so 3 x 4 is 12, and then the result is added to 2.

// Now, all these operators you have learned in this section, they have their own precedence. 

// It's really hard to memorize which operators have HIGHER PRECEDENCE or LOWER PRECEDENCE . 
// So when working with complex expressions you can USE PARENTHESIS  
// to determine HOW these operators are applied. 

// For example, here we can put parenthesis around 2 plus 3,
// and this means this expression is evaluated first, 
// so we get 5, and then the result is multiplied by 4. 
// So now if we save the changes we get 20.

let x = (2 + 3) * 4;

console.log(x);
// output:
// 20




// --------------------------------------------------
// 3.12 Exercise

let a = 'red';
let b = 'blue';

console.log(a);
console.log(b);

// Alright let's finish this section with a simple programming exercise. 
// Let's declare 2 variables, and set it to red, and b, set it to blue. 
// Now when we log these on the console, obviously we're going to get red and blue. 
// Right? 

// Now what I want you to do, is to write some code here to swap the value of
// these two variables. 

// So when we log these on the console, instead of getting red and blue, 
// we're going to get blue and red. 

// So pause the video, spend a couple of minutes on this exercise, when you are done come
// back and continue watching.

let a = 'red';
let b = 'blue';

let c = a;
a = b;
b = c;

console.log(a);
console.log(b);

// Alright to swap the value of two variables we need a third variable.
// So we're going to declare another variable let's call it c, we're going to use that as a backup.

// So whatever you're storing in a, we're going to put that in another variable that is c, 
// then we're going to copy b to a and finally what we have in c, 
// which was the value of a before we're going to copy that to b. 

// Let me show you. So we declare c, and set it to a.
// So what we have in a which is red will be copied to c. 

// Now we want to overwrite a with b. So we set a to be.
// The value of b is copied to a, now both these variables at this point are blue.

// Finally we're going to copy what we have with c which is the original value of a, we're going to copy that to b. 
// So we set b to c, now, when we save the changes, instead of red and blue we're going to see blue and red. 

// So this proves that we have swapped the value of these two variables.
// Now if you couldn't do this exercise, don't worry, this is because you have not trained your programming brain.
// And this requires a bit of time. Just like some one who wants to go to the gym, they are not going to build muscle on day 1.
// It requires time and effort.

// Now to help you train your programming brain, I have designed lots of exercises for you in this course, 
// so, as you go through these exercises and look at my solutions, you'll start to pick up some patterns and techniques to solve programming problems.
// So once again, if you couldn't do this exercise, don't be disappointed, that's perfectly fine.




// --------------------------------------------------
// 4.1 If...else

// In the last section you learned about expressions and operators. 

// In this section we're going to use these expressions and operators 
// along with CONDITIONAL STATEMENTS to implement interactivity in our applications. 

// In JavaScript we have TWO types of CONDITIONAL statements, we have:

// If ... else

// and 

// Switch ... case

// You're going to learn about if and else in this lecture, 
// and we'll look at switch and case in the next lecture.

// So imagine in our application we're going to get the current hour 
// and depending on it's value, we're going to greet the user with a different message

// so if the hour is between let's say 6am and 12pm, you display something like good morning. 
// Similarly, if it is between 12pm and 6pm we're going to display good afternoon. 
// Otherwise we're going to display good evening. 
// So we want to have some logic like this in our application.

// That's where we use if and else. 

// So we start with the IF, then we add parenthesis.

if (); // IGNORE ; 

// And in between these parenthesis, we add a condition. 

if (condition)
    statement

// If this condition evaluates to true, the statement we put after will be executed. 

// Now if you have multiple statements, we need to put them in between these curly braces. 
// We refer to these as a BLOCK of code. Okay? 

if (condition) {
    statement
}

// Now optionally, we can have another condition so we write ELSE IF 
// once again parenthesis, anotherCondition. 
// Now, if this condition is true, then this other statement will be executed

if (condition) {
    statement
}

else if (anotherCondition)
    statement

// and similarly, if we have multiple statements, 
// we need to surround them with curly braces. Like this: 

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}

// Also note that as a convention, when we want to define a block of code,
// we put the first curly brace on the same line, not here (on a new line below),
// that's kind of ugly in JavaScript, so take that into account,

// now back to our if and else, we could have yet another condition like this, 
// yetAnotherCondition, we could have as many conditions as we want, there is no limitation.
// And once again here we have 1 or more statements

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}
else if (yetAnotherCondition)
    statement

// now optionally if none of these conditions evaluate to true, 
// we could use else to execute 1 or more other statements.

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}
else if (yetAnotherCondition)
    statement
else
    statement

// So this is the basic structure. 

// Now, we want to get this logic and map it into this structure.
// It's very easy. 

// So let's start with our first condition. 
// If hour is between 6am and 12 pm, so that's the condition, 
// and the statement we want to execute is good morning, okay?
// So I'm going to declare a variable here, hour and set it to 10, 
// now in a real world application we want to read the current hour. 
// For now, let's not worry about getting the current time and hard code this number here, 10.

// So we want to compare the value of hour with these two numbers. 

// Now for simplicity, let's go with 24 hour time format 
// so we want to see if hour is greater than or equal to 6, and hour is less than 12.

if (hour >= 6 && hour < 12); // IGNORE ;

// You learned this in the last section, right?
// So here we're using this COMPARISON OPERATOR, we have two EXPRESSIONS, 
// here's the first one, here's the second one, and we're applying the LOGICAL AND in between them.

// So, if both these expressions evaluate to true, 
// then the result of this expression will also be true. 

// Now let's add the statement. You want to display good morning.
// And of course we need to terminate this statement with a semi colon. 

if (hour >= 6 && hour < 12) {
    console.log('Good morning');
}

// Now here's my suggestion for you. If you want to master JavaScript pause the video now and continue implementing this logic
// using if and else then come back continue watching and see my solution.

let hour = 10;

if (hour >= 6 && hour < 12) {
    console.log('Good morning');
}
else if (hour >= 12 && hour < 18) {
    console.log('Good afternoon');
}
else {
    console.log('Good evening');
}

// Alright let's continue. Here's a second condition. 

// You want to check to see if hour is between 12 and 18. 
// So, very easy. 
// If hour is greater than or equal to 12, and it's less than 18. 
// We want to display good afternoon. So console.log good afternoon.

// Now in this example, we don't need this other else if because otherwise 
// we want to display good evening. So let's delete this, we do a console.log
// of good evening. 

// Now in this example, because we're dealing with a single statement
// these curly braces are getting in the way and creating noise in the code.
// So it's better to get rid of them and simplify the code, here's another pair, okay, that's better.
// Now save the changes, we get good morning here

let hour = 10;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good morning

// If I change the hour to 13, we get good afternoon, 
// and if I change this to 20, we get good evening.

let hour = 13;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good afternoon

let hour = 20;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good evening

// So this is all about IF and ELSE. 

// In the next lecture, you're going to learn about switch and case.




// --------------------------------------------------
// 4.2 Switch...case

// Alright, now let's take a look at SWITCH and CASE. 

// So let's start by declaring a variable called role. 

let role;

// Let's imagine this represents the role of the current user. 
// Now we want to see if this user is a guest, or a moderator or an admin.

// We can easily implement this logic, using a bunch of if and else statements.
// But there is another way, using SWITCH and CASE.

// So let's have a look. 
// We start with this SWITCH statement, we add parenthesis, 
// but INSTEAD of adding a condition here, we add a VARIABLE,
// in this case we're going to add the role variable. 

let role;

switch (role)

// Now we add curly braces, 

let role;

switch (role) {

}

// then we add one or more case statements, 
// each case statement is used to compare the value of this variable with something.

// So, here's our first case. 

let role;

switch (role) {
    case:
}

// If this role equals guest, so I'm COMPARING the value of role with guest,

let role;

switch (role) {
    case 'guest':
}

// now we add colon, and then after that we add one or more statements. 

let role;

switch (role) {
    case 'guest':

}

// So, we can do a console.log guest user. Like this.

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
}

// Now here we need to add the BREAK statement. 
// So we jump out of this switch block. 

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;
}


// Otherwise the other statements here will be executed, let me show you.

// So, we need to add another case statement. 
// If this user is a moderator, we want to display console.log Moderator User
// once again we need to add the BREAK

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;
}

// so in this case, if I don't add this break statement here (after guest), 
// and the role equals guest, both these console.log statements will be executed. 

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
    // break; deleted here

    case 'moderator':
        console.log('Moderator User');
        break;
}
// output:
// Guest User
// Moderator User

// That's why we need to add a BREAK TO JUMP OUT OF this switch block, right?

// Now, we can have as many case statements here there is no limitation. 

// Optionally, if none of these cases are matched, 
// we can have a DEFAULT STATEMENT and execute 1 or more statements 
// so console.log, Unknown User. Or more accurately, unknown role. 

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
    // dont need a break here because the control auto exits the block here
}

// Now here FOR THE DEFAULLT STATEMENT WE DON'T NEED A BREAK, 
// because at this point THE CONTROL WILL AUTOMATICALLY GET OUT OF THIS SWITCH BLOCK.
// Alright, so, let's save the changes and see what we get on the console.
// Save. We get Unknown User, because I have not initialized role, 
// so it's default value is undefined and it doesn't match any of these case statements. 

// Now if I change role to guest, save the changes, we get guest user

let role = 'guest';
switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
}
// output:
// Guest User

// and similarly if I change role to moderator, we get the moderator user message. 

let role = 'moderator';
switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
}
// output:
// Moderator User

// So here's the takeaway:

// With switch and case, 
// we can compare the value of a variable (role) against a bunch of other values (guest/moderator etc). 

// Now they don't have to be string, they can be numbers or even booleans. 
// But using booleans here is less common. 
// Because if you want to compare the value of a variable with true or false, 
// it makes more sense to use an if statement. 

// Now just to let you know we can implement this exact logic using 
// if and else statements, Let me show you.

// So, if role equals guest, note that I'm using strict equality here, 
// so triple equal signs, and that means we're checking the type and value of this variable 
// against what we have on the right side. 

// So, if role is guest we want to do a console.log of guest or guest user. 
// Else if role equals moderator then then we're going to do a console.log of moderator
// finally else if the role is something else we want to display unknown user. 

if (role === 'guest') console.log('Guest');
else if (role === 'moderator') console.log('Moderator');
else console.log('Unknown User');

// Now compare these two implementations 
// you can see implementing this logic with if and else is cleaner and shorter, 
// we don't have all these break statements or default, 
// or these curly braces, these are extra noise in the code. 

// So it doesn't mean you should never use switch and case, ...well it depends who you ask. 
// I personally tend to use if and else more often, switch and case are kind of outdated, 
// they look a little bit ugly, in my personal opinion. 
// But there is nothing terribly wrong with them, sometimes they are more explicit. 
// It comes back to your personal preference.




// --------------------------------------------------
// 4.3 For

// Sometimes we want to repeat an action a number of times. 
// For example, let's imagine we want to display hello world 5 times on the console.
// The poor way of doing that is like this.
// So console.log hello world, and then repeat it five times. 

console.log('Hello World');
console.log('Hello World');
console.log('Hello World');
console.log('Hello World');
console.log('Hello World');

// This code is ugly, there is a better way to achieve the same result, 
// and that's where we use LOOPS.

// In JavaScript we have various kinds of loops, 
// and all these loops essentially do the same thing. 

// THEY REPEAT AN ACTION A NUMBER OF TIMES

// We have:

// For          loops
// While        loops
// Do...While   loops
// For...In     loops
// For...Of     loops 

// All these loops essentially do the same thing. 
// But there is a SUBTLE DIFFERENCE BETWEEN HOW THEY START AND END. 
// Let's start by looking at the for loop. 

// So, back to this code, this is how we write a for loop, so for we add parenthesis, 

// and here we need 3 statements. 
// The FIRST statement is what we call INITIAL EXPRESSION. 
// And here we declare an initialized variable. 
// So, we use let to declare a variable like i and set it to 0. 

for (initialExpression; condition; incrementExpression) {
    statement;
}

// Now i is short for index and is a common convention to use in for loops. 
// This is what we call the LOOP VARIABLE.
// So we initialize it to 0, then we terminate this statement with a semi-colon,

for (let i = 0;) {
}

// and the SECOND part of the for loop is what we call a CONDITION.
// so here we want to add a condition and compare the value of i with something else. 

for (let i = 0; condition;) {
}

// This loop will run as long as this condition evaluates to true. 

// So if you want this loop to run 5 times, we compare i with 5. 
// So as long as i is less than 5, this loop will execute. 
// You will see that in a second.

for (let i = 0; i < 5;) {
}

// Once again, we terminate this statement with a semi colon, 

for (let i = 0; i < 5; incrementExpression) {
}

// and finally the THIRD PART. This is what we call INCREMENT EXPRESSION,
// and quite often what we have here is something like this.
// So, we use the increment operator to increment the value of i with 1.

for (let i = 0; i < 5; i++) {
}

// Now, after this for statement we can add 1 or more statements, 
// just like the if statements if you have multiple statements here, 
// you need to put them in code block. Like this.

for (let i = 0; i < 5; i++) {
    statement
}

// Now here we want to display hello world on the console. 
// So our statement is console.log Hello World.
// So instead of repeating this line 5 times, we put it in a for loop, 
// and this loop will run 5 times. 
// Now, save the changes, so we get 5 Hello World messages, on the console. 

for (let i = 0; i < 5; i++) {
    console.log('Hello World')
}
// output:
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World


// Alright now that you have seen a for loop reaction,
// let's see exactly how this loop works. 

// So earlier I told you this is what we call an INITIAL EXPRESSION, 
// here we're initializing i to 0, ( let i = 0 )

// now this loop will execute AS LONG AS this condition ( i < 5 ) is true. 
// So as long as i is less than 5, the statements we have here 
// ( console.log 'Hello World' ) will be executed. 

// Now, after the first iteration, i is incremented by 1. 
// THEN this CONDITION IS EVALUATED AGAIN, so 1 is less than 5, 
// so one more time, this loop is executed so we have the second iteration,
// now after the second iteration, once again, i is incremented by 1,
// so now we are in the third iteration. 
// Again, this condition is evaluated, and because it is true, the loop is executed.

// To show you this in action, I'm going to output i on the console. 
// So, save the changes, this is what we get.

for (let i = 0; i < 5; i++) {
    console.log('Hello World', i)
}
// output:
// Hello World 0
// Hello World 1
// Hello World 2
// Hello World 3
// Hello World 4

// So note that in the first iteration i is 0, 
// then is incremented by 1 until it reaches 4. 
// So at the end of the 5th iteration i will be 4, 
// and when we increment that by 1, it will be 5, 
// so this condition ( i < 5 ) will evaluate to false. 

// So essentially there are two ways to repeat an action a number of times
// using the for loop. 

// Let's say we want to repeat something 5 times, we can initialize i to 0, 
// and check to see if it's less than 5. 
// Alternatively, we can initialize this to 1, 
// and check to see if it's less than or equal to 5.
// Now, if you save the changes, you can see i starts from 1, and finishes at 5. 

for (let i = 1; i <= 5; i++) {
    console.log('Hello World', i)
}
// output:
// Hello World 1
// Hello World 2
// Hello World 3
// Hello World 4
// Hello World 5

// Now we can make this program a bit more interesting. 
// Let's say we want to display the odd numbers between 1 to 5. 

// So instead of logging Hello World in the console, 
// we can have an if statement and check the remainder of the division of i by 2.

// So, if the remainder of division of i by 2 is not 0, that means i is an odd number. 
// So we can display it on the console. 
// Save the changes, so here are the odd numbers between one and five. 

for (let i = 1; i <= 5; i++) {
    if (i % 2 !== 0) console.log(i);
}
// output:
// 1
// 3
// 5

// There is also another way to write this loop. 
// Instead if starting from 1 and going all the way to 5, 
// we can start from 5 and go back to 1. 
// So, we change the initial expression, set i to 5, 
// as long as i is greater than or equal to 1, now we want to decrement i.
// Save the changes. Now we get the odd numbers in the reverse order.

for (let i = 5; i >= 1; i--) {
    if (i % 2 !== 0) console.log(i);
}
// output:
// 5
// 3
// 1

// It's more common to use the previous form, 
// so we initialize i to 0 or 1 and increment it in every iteration. 
// But in certain problems, you want to use the for loop in reverse order.




// --------------------------------------------------
// 4.4 While

// In the last lecture, we wrote this for loop to display all the odd numbers
// between 0 and 5. 

// And in this lecture, I'm going to show you how to implement 
// the same logic by using a while loop. 

// Now one key difference between a while loop and a for loop 
// is that IN FOR LOOPS THE LOOP VARIABLE ( let i = 0; ) IS PART OF THE LOOP ITSELF.

// For Loop
for (let i = 0; i <= 5; i++) {
    if (i % 2 !== 0) console.log(i);
}

// But IN WHILE LOOPS YOU HAVE TO DECLARE THIS WHILE VARIABLE EXTERNALLY. 
// Let me show you what I mean. 
// So we start with declaring a variable like i and set it to 0. 

// While Loop
let i = 0;

// Note that this i we have here is different from the i we have in this for loop,
// because this variable is only meaningful and accessible inside of this for loop. 

// This is called scope, and I'm going to talk about it later in the course, 
// all I want you to know is that these two variables are completely different, 
// even though their names are the same. 

// Now, we have our loop variable initialized to 0.
// Next we add a while statement, 
// in parenthesis we need to add our condition. 

let i = 0;
while (condition) { }

// What is the condition here? 
// That is i less than or equal to 5. 
// So I'm going to add that here.

let i = 0;
while (i <= 5) {

}

// Next, we need to add our statements. 
// So what is the statement that we want to repeat, 
// here's the statement, we want to display the odd numbers, 
// so we add that here as well,

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
}

// and finally, at the end of this while block we need to increment i.

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}

// So this is a DIRECT TRANSLATION of this for loop INTO a while loop.

// So this is what happens when we execute this code. 

let i = 0; // Initially i is 0, 
while (i <= 5) { // now in the while loop, first this condition is evaluated, 
    if (i % 2 !== 0) console.log(i);  // if this condition is true,
    i++;                              // then the body of the while loop will be executed. 
}

// Again, in the next iteration the condition is evaluated again, 
// if it's true, the statements in the while BLOCK will be executed, 
// otherwise the while block will terminate. 

// In the next lecture we're going to look at another kind of loop in JavaScript.




// --------------------------------------------------
// 4.4 Do While

// Alright now let's take a look at the third kind of loop we have in JavaScript.
// That is a Do While loop. 

// Do While loops are very similar to while loops, 
// but they're slightly different. 

// It's easier to show you in code. 

// So I'm going to REWRITE this WHILE LOOP using a DO WHILE LOOP. 

// let i = 0;
// while (i <= 5) {
//     if (i % 2 !== 0) console.log(i);
//     i++;
// }

// Just like the while loops, WE HAVE TO DECLARE OUR LOOP VARIABLE EXTERNALLY, 
// so we declare i and initialize it to 0. 
// So we add the do statement here, then a code block, 
// in this block we should have our statements. 

let i = 0;
do {

}

// So I'm going to borrow them from our while loop, copy these, paste them here,

let i = 0;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
}

// and then finally at the end of this block,
// we add the while statement along with our condition. 
// That is i less than or equal to 5, followed by a semi colon.

let i = 0;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
} while (i <= 5);

// Now you might be wondering WHAT IS THE DIFFERENCE between a WHILE loop and a DO WHILE loop
// DO WHILE loops ARE ALWAYS EXECUTED AT LEAST ONCE.
// EVEN IF this condition (while (i <= 5)) evaluates to false. 

// Let me show you what I mean.

// So I'm going to temporarily comment out these few lines. 
// And bring back our while loop.
// Now if you save the changes, we get 1, 3, 5 on the console. 

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}
// output:
// 1
// 3
// 5

// However, if I change i to 9, we are not going to see anything, 
// because the first time we try to execute this while loop, 
// this condition evaluates to false.

let i = 9;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}
// output:
// nothing

// So these statements (inside the while block) ARE NEVER EXECUTED. 
// So save the changes, look, there's nothing in the console.

// So in WHILE loops, THIS CONDITION (i <= 5) IS EVALUATED AHEAD OF TIME.
// AT THE BEGINNING OF EVERY ITERATION. 

// In contrast in DO WHILE loops, THIS CONDITION IS EVALUATED AT THE END. 
// And that means THESE STATEMENTS (inside the do block) ARE ALWAYS EXECUTED AT LEAST ONCE. 
// Even if the condition is false. 

// So let's try this, I'm going to comment out this while loop,
// and change i to 9, just like before. Save the changes, we get 9 on the console

let i = 9;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
} while (i <= 5);
// output:
// 9

// Why? Because in our do-while loop here, on line 15, 
// we check to see if this is an odd-number it is, and display it on the console. 

// Next, we increment i by 1, so i, is 10. 
// Then, the condition is evaluated, of course it's false. 

// So our loop will terminate. 

// Now, realistically we're not going to use these Do While a lot in programming,
// there are situations you may want to use this, but in practical terms,
// most of the time you will be using a for or while loop. 

// Just be aware of the difference between a while loop and a do while loop.




// --------------------------------------------------
// 4.5 Infinite Loops

// When writing loops something that you need to be aware of 
// is what we call an INFINITE LOOP.

// So an infinite loop as the name implies, executes infinitely or forever. 

// So if you accidentally create one of these loops, 
// you're going to crash your browser or your computer. 

// Let me show you an example. 
// So here I'm going to declare a variable, set it to 0, 
// put it in a while loop, so as long as i is less than 5, 
// we're going to do a console.log, of i,
// now here technically we should increment i, 
// but if you forget to do so, you END UP CREATING AN INFINITE LOOP, 
// because in the first iteration, i is 0. 
// And it's less than 5, so will display an i on the console.

let i = 0;
while (i < 5) {
    console.log(i);
    //i++;
}

// Now, in the second iteration i is still 0, and is less than 5.
// So this loop could run forever. Let me show you.

// So I'm going to save the changes, 
// now on the console, this number you see before 0 
// is the number of times you're displaying 0 on the console,
// so you can see this number is increasing rapidly so far we have displayed 0, 
// more than 35 hundred times.

// And if you look at the browser, you can see this spinner going forever.
// So the only way to get rid of this is to close this window,
// or if this doesn't work, you'll have to force quit Chrome. 

// So this is one example of an infinite loop. 

// Here's another example while true. 

while (true) {

}

// Again, this loop is going to run forever.
// So it's an infinite loop. 

// And by the way, infinite loops are not limited to while loops, 
// we can create an infinite do while loop, so:

do {

} while (true);

// Or similar to the last example, 
// maybe we'll create a loop variable like 0 
// and then have a condition like x is less than 5, 
// but we forget to increment x here.

let x = 0;
do {
    // x++;
} while (x < 5);

// We can also create an infinite for loop. 
// So, for let i equal to 0, as long as i is greater than 0, i ++, 

for (let i = 0; i > 0; i++) { }

// again with the condition that we have placed here (i > 0)
// this loop is going run forever, 

// or maybe we have the right condition, like i is less than 10, 
// but we forget to add the third part.

for (let i = 0; i < 10;) { }

// So we don't increment i, and this is exactly like this while loop 
// that we had earlier. Without incrementing i. 

// So be aware of the infinite loops, avoid them, 
// because they can crash your browser or your computer.




// --------------------------------------------------
// 4.7 For...In

// So far you have learned about 3 kinds of loops in JavaScript.
// FOR LOOPS, WHILE LOOPS and DO WHILE LOOPS.

// With all these loops we can repeat an action a number of times.

// But we have TWO MORE kinds of loops in JavaScript and
// WE USE THEM TO ITERATE OVER THE PROPERTIES OF AN OBJECT OR ELEMENTS IN AN ARRAY

// Let me show you. 
// In this lecture, we're going to look at the FOR IN loop.

// So let's say we have an object like person, with two properties name, 
// Mosh and age 30.

const person = {
    name: 'Mosh',
    age: 30
}

// Let's say we want to display all the properties of this person object.

// That's when we use the FOR IN loop. 

// So for, now in parenthesis, unlike the for loop that we learned about earlier,
// we don't have three parts, so we don't have that initial expression 
// followed by a semi colon, a condition, followed by the increment part.

// NOT WRITTEN LIKE A For Loop
// for (initialExpression; condition; increment)

// It looks a little but different, let me show you.

// So we have let key in person.

for (let key in person) { }

// So in EVERY ITERATION THIS KEY VARIABLE IN THE LOOP
// WILL HOLD THE NAME OF ONE OF THE PROPERTIES OF THE person object

// Let me show you.
// So here I'm going to do a simple console.log of key, save the changes.

for (let key in person)
    console.log(key);

// output:
// name
// age

// So in the first iteration, key is name, and in the second iteration it is age.

// Now what if you want to display the VALUE OF EACH PROPERTY next to it.
// Well earlier i told you that there are two ways to access the properties of an object.

// We can use the DOT NOTATION which looks like this

person.name

// or we can use the BRACKET NOTATION.
// So person square brackets, the name of the target property as a string.

person['name']

// Earlier I told you, that we used the bracket notation 
// when we don't know ahead of time, at the time of writing code, 
// what property we're going to access.

// Perhaps the name of the target property is calculated at run time.

// Here is a real example.

// When we iterate over the properties of the person object, 
// in EACH ITERATION THE VALUE OF KEY IS GOING TO BE DIFFERENT.

// So here WE CAN'T USE THE DOT NOTATION to display the value of this property, 
// in other words, we can't do something like this

console.log(key, person.key)

// BECAUSE WE DON'T HAVE A PROPERTY CALLED KEY IN THE PERSON OBJECT

// So that's when we use the BRACKET NOTATION.
// So we add square brackets, and pass key as the name of the target property.
// Save the changes

const person = {
    name: 'Mosh',
    age: 30
}

for (let key in person)
    console.log(key, person[key]);

// output:
// name Mosh
// age 30

// so you can see the value of name is Mosh and the value of age is 30.

// So this is the FOR IN LOOP and WE USE IT TO ITERATE OVER THE PROPERTIES OF AN OBJECT.

// WE CAN ALSO USE THIS TO ITERATE OVER AN ARRAY.

// BUT IT'S NOT AN IDEAL WAY, in the next lecture I'm going to show you a better way, 
// but let's see how that works before we finish this lecture.

// So I'm going to define an array called colors, 
// with three values, red, green, and blue.

const colors = ['red', 'green', 'blue'];

// Now we can use the FOR IN LOOP TO ITERATE OVER THIS ARRAY. 

// So for let index in colors
// note that I named this LOOP VARIABLE index, 
// because in each iteration, this index variable will be set to the 
// INDEX of one of the elements in this array.

// So it's going to be 0 1 and 2. Let's take a look. 
// So console.log index. Save the changes.
// So, we get 0, 1, and 2. 

const colors = ['red', 'green', 'blue'];

for (let index in colors)
    console.log(index);

// output:
// 0
// 1
// 2

// Now if you want to get the elements of a given index.
// Once again we use the square bracket notation. 
// So, comma, colors of index. Save the changes,
// and now we can see each element in our colors array.

const colors = ['red', 'green', 'blue'];

for (let index in colors)
    console.log(index, colors[index]);

// output:
// 0 red
// 1 green
// 2 blue

// Now starting from Ecma Script 6, or ES6, which is the modern version 
// of JavaScript we have a NEW KIND OF LOOP that is called FOR OF LOOP, 
// and that is an IDEAL WAY TO ITERATE OVER ARRAYS,
// and that's what you're going to learn in the next lecture.




// --------------------------------------------------
// 4.8 For...of

// So as I told you in the last lecture, starting from Ecma Script 6, or ES6,
// we have a new way to iterate over arrays and that is using the FOR OF LOOP.

// It's very similar to the for in loop but instead of the IN keyword we use the OF keyword. 

// So here's an example, for let, color of colors,
// you can simply log this color on the console.

const colors = ['red', 'green', 'blue'];

for (let color of colors)
    console.log(color);
// output:
// red
// green
// blue

// You can see with this new for loop, we don't have to deal with this index.
// And we don't have to access this element at the given index.

// So in each iteration this color which is our loop variable 
// will hold one of the items in this array.
// So when I save the changes, we see red green and blue

// So WE USE THE FOR IN LOOP TO ITERATE OVER THE PROPERTIES OF AN OBJECT:

// FOR IN LOOP
const person = {
    name: 'Mosh',
    age: 30
}

for (let key in person)
    console.log(key, person[key]);

// and THE FOR OF LOOP TO ITERATE OVER THE ELEMENTS OR ITEMS IN AN ARRAY:

// FOR OF LOOP
const colors = ['red', 'green', 'blue'];

for (let color of colors)
    console.log(color);




// --------------------------------------------------
// 4.9 Break and Continue

// With all the loops you have learned about in this section, there are two keywords,
// BREAK and CONTINUE that can change how the loop behaves. 

// In this demo I'm going to use a while loop. 
// But what you're going to learn applies to all loops we have learned in this section. 

// So let's start by declaring a variable called i and initialize it to 0.
// Now we put this in a while loop, as long as while is less than or equal to 10, 
// we're going to display i on the console and then increment it. 
// Save the changes, so this gives us numbers 0-10. 

let i = 0;
while (i <= 10) {
    console.log(i);
    i++;
}
// output:
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10

// Now sometimes YOU WANT TO JUMP OUT OF A LOOP FOR SOME REASON
// that may happen at run time.

// For example, here we can have an if condition an if statement, 
// with a condition like this. 

// If i equals 5, we want to jump out of this loop. 
// That's where we use the BREAK keyword. 
// Now when we save the changes, see what happens we get the numbers 0 to 4. 

let i = 0;
while (i <= 10) {
    if (i === 5) break;

    console.log(i);
    i++;
}
// output:
// 0
// 1
// 2
// 3
// 4

// So at the end of the 5th iteration here we increment i, 
// now i is 5, so we break out of the loop. 

// Now let me comment this out and look at the CONTINUE keyword.

// So I'm going to write another if statement, 
// I want to see if i is an even number or not. 
// So i, modulus 2, equals 0.
// If that's the case, I want to increment i and then continue.
// Let's see what happens when we run this code. Save the changes,

let i = 0;
while (i <= 10) {
    //if (i === 5) break;
    if (i % 2 === 0) {
        i++;
        continue;
    }

    console.log(i);
    i++;
}
// output:
// 1
// 3
// 5
// 7
// 9

// we only get the odd numbers, why is that? 
// Alright let's take a look at an example. 
// So when i becomes 2, it's an even number, at this point increment i, i will be 3. 

// Now when the JavaScript engine sees the CONTINUE keyword. 
// IT WILL JUMP TO THE BEGINNING OF THE LOOP. 
// AND CONTINUES IT'S EXECUTION IN THE NEXT ITERATION.

// while (i <= 10) {   <-- it jumps here to the beginning of the loop

// At this point i is 3, so this if statement is not executed,
// that's why we see i on the console. 

// Now, in my personal experience, continue is not something you will use that often,
// it's one of those old legacy things in the JavaScript language, 
// I'm only explaining it here in case you see it in projects you're working on. 

// It's not something that I recommend you to use, it's an ugly way of writing code.

// So just to recap 
// with the BREAK keyword we JUMP OUT OF A LOOP, 
// and with the CONTINUE keyword we JUMP TO THE NEXT ITERATION.




// --------------------------------------------------
// 5.1 Objects - Basics

// Earlier in the course you learned a little bit about objects, 
// you learned that objects are collections of key value pairs, 
// so if you have properties that are highly related, 
// we want to encapsulate them inside of an object.

// Here's an example. 
// Let's say we are building an application for drawing different kinds of shapes, 
// like circles, rectangles and so on. 

// So we could declare multiple variables, around circles for example 
// radius we set that to 1, then x and y
// we're defining multiple variables, but all these variables are highly related, 
// they represent the circle. 

let radius = 1;
let x = 1;
let y = 1;

// A better approach is to put these variables inside of an object. 

// Now we can send that object anywhere in our programs, 
// we can pass that to any functions,
// and all these variables will be available in that object. 

// So, I'm going to define an object, we could use let or const, 
// in this case it doesn't really matter, 
// so let's define a circle object using the object literal syntax, 
// so we add these curly braces, and inside them we add 1 or more key value pairs. 

const circle = {};

// So, the first key is radius, and the value is 1. 

const circle = {
    radius: 1
};

// Now this value we have here can be any type in JavaScript, 
// it can be a number, a string, a boolean, null, undefined, 
// it can even be another object, or an array, or a function. 

// Let me show you 
// so instead of defining two other key value pairs as x and y, 
// I'm going to add a key called location, and set it's value to another object. 
// Now in this object we can have two key value pairs or properties 
// the first one is x and the second one is y.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
};

// We can also have another property here like isVisible, and set that to a boolean, 
// true or false, okay?

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
};

// So the purpose of an object is to group related variables. 

// But it's not just grouping related variables, 
// quite often we have functions that should operate on these variables.

// For example, we can have a function like draw, for drawing a circle. 
// Or, we could have another function for moving a circle, right?

function draw() { }
function move() { }

// So again these functions are highly related to these variables we have to find here.

// So INSTEAD OF defining these functions, in a STANDALONE way, 
// it's BETTER TO PUT THESE FUNCTIONS, INSIDE OF THE circle OBJECT. 

// Again with this, 
// WHERE WE HAVE THE circle OBJECT in our program, 
// WE HAVE ACCESS TO ALL OF IT'S PROPERTIES AND FUNCTIONS. 

// So let me show you how to add this draw function inside of the circle object. 

// We add another key value pair, 
// the key is draw, 
// and the value is a function, 
// so I told you that the value of a key value pair can be anything in JavaScript, 
// here the value is a function.

// Now for simplicity I just want to do a console.log here, 
// let's log draw on the console.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

// So now with this circle object, we no longer need 
// these independent variables, 

// let radius = 1;
// let x = 1;
// let y = 1;

// and functions, 

// function draw() { }
// function move() { }

// all of THESE ARE NOW PART OF A circle OBJECT.

// So we can access them using the dot notation, circle. 
// look, all of them are here. 
// We can simply call this draw function like this. 
// And if I save the changes, you see the draw message here. 

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

circle.draw();
// output:
// draw

// Now what you see here, is what we refer to as OBJECT ORIENTED STYLE of programming. 
// So OBJECT ORIENTED PROGRAMMING, also abbreviated as OOP. 

// Object oriented programming is basically a style of programming
// where we see a program as a collection of objects 
// that talk to each other to perform some functionality.

// So here we have a circle object, and this object has a few properties and a function. 

// In object oriented programming terms, 
// IF A FUNCTION IS PART OF AN OBJECT,
// WE CALL THAT FUNCTION A METHOD. 

// So here more accurately instead of saying we're calling the draw function of the circle object, 
// we say WE'RE CALLING THE DRAW METHOD OF THE circle OBJECT.

// So that's the difference between a function and a method 
// if a function is part of an object, in object oriented programming terms, 
// we refer to that function as a method. 

// Now, using this object literal syntax, is an easy way to create an object, 
// but as our applications get more complex we need a different way to create objects. 

// And that's what you're going to learn next.




// --------------------------------------------------
// 5.2 Objects - Factory Functions

// In the last lecture you learned how to use the object literal syntax to create an object
// but there is a tiny problem here. 

// Imagine you want to create two circle objects, so, I'm going to copy this code here, 
// and call this second circle object circle 2.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

const circle2 = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

// Now the problem that we have here is that we have duplicated the implementation,
// of the draw method, so right now it's a simple method with only a single line of code, 
// but what if we had 10 lines of code here. 
// You wouldn't want to repeat all these lines here, because if you bug in this method, 
// then we'll have to fix it in multiple places.
// And also take into account that our circle object currently has only a single method. 
// What if we had 10 other methods here?
// We don't want to duplicate or repeat all that logic, alright?

// So, if our objects have logic, we need a different way to create objects. 
// That's when we use FACTORY or CONSTRUCTOR FUNCTIONS.

// In this lecture you're going to learn about factory functions 
// and we'll look at constructor functions next.

// So I'm going to delete this second circle and show you how to create a factory function. 

// So factory function, just like a factory producing products, 
// these FACTORY FUNCTIONS PRODUCE OBJECTS.  

// So we define a function and call it create circle.

function createCircle() {

}

// Now we're going to move this definition of the circle object inside
// our factory function,
// so you have a circle object here, 
// finally we need to return this. 

function createCircle() {
    const circle = {
        radius: 1,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
    return circle;
}


// Now one way is to return it like this, 
// but we don't really need this circle constant defined
// because we are not going to reference it anywhere, 
// we only want to return it.

// So we can make this code shorter by removing the circle constant 
// and simply returning this object. 

// So whenever we call the create circle function we'll get a circle object. 

function createCircle() {
    return {
        radius: 1,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}

// However, we have hard coded these values here, so every circle that is created by this
// function, it's radius will be one. 
// That's not what we want, we want to have a circle with a bigger radius. 

// So we want to pass radius as a parameter here. 
// So radius and then instead of hardcoding 1, 
// we want to set the value to this radius argument that we supply when calling this function.

function createCircle(radius) {
    return {
        radius: radius,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}


// Similarly we can add another parameter here like location, 
// and instead of hard coding this object here, 
// we simply set location to this location argument.

function createCircle(radius, location) {
    return {
        radius: radius,
        location: location,
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}

// However, for simplicity, I'm going to remove these two properties.
// Location and is visible, so we can focus on the core of factory functions. 

// So, let's delete these properties, we don't need the location parameter either, 
// now we can make this code a little bit shorter.  

// So in modern JavaScript if our key and value are the same, 
// we can make our code shorter by removing a value and simply adding the key.
// So that is exactly equivalent to this code.


function createCircle(radius) {
    return {
        radius: radius,
        draw: function () {
            console.log('draw');
        }
    };
}

function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

// Alright? So that is better, 

// next we have our draw method, there is also a shorter syntax to define this method,
// so instead of defining it as a key value pair, we can define it like this. 

// So draw parenthesis and a code block. 
// This is similar to how we defined a function outside of an object, right? 

// So if you want to define a function, this is how we define it, right? 

// So we have the function keyword, then the name of the function, parenthesis, and code block.

// Now when we put this inside of an object, basically we're dropping the function keyword 
// and simply adding this inside of the object. 

function draw() // standard function definition OUTSIDE of an OBJECT

{
    draw: function() { } // formal [key:value pair] function INSIDE of an OBJECT (METHOD)
}

{
    draw() { } // abbreviated [key:value pair] function INSIDE of an OBJECT (METHOD)
}

// You can see that this syntax is a little bit shorter than here. 
// So let me delete this. And move this console.log statement in our draw method.

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

// So now we have a factory function, we can simply call this to create a circle object. 
// So I'm going to define this constant circle1, 
// and call the create circle function, and pass 1 as the radius.
// Now let's log this circle object on the console. circle1, save the changes

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

const circle1 = createCircle(1);
console.log(circle1);
// output:
// { radius: 1, draw: [Function: draw] }

// so you can see radius is set to 1, 
// we also have this draw method, 
// so we can call circle1.draw and here's our draw message on the console. 

circle1.draw();
// output:
// undefined

// Now THE BEAUTY OF THIS FACTORY FUNCTION IS THAT WE HAVE DEFINED OUR LOGIC IN ONE PLACE.

// So we can call this function with different values or different arguments, 
// we get different circle objects, but we have defined the draw method only in 1 place.

// So if there is a bug in this method that we need to fix in the future, 
// there is a single place that we need to modify.

// So now I'm going to create another circle object, 
// circle2, createCircle

// I'm going to pass 2 as the radius, let's log this on the console.
// Circle2, save the changes

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

const circle1 = createCircle(1);
console.log(circle1);

const circle2 = createCircle(2);
console.log(circle2);
// output:
// { radius: 1, draw: [Function: draw] }
// { radius: 2, draw: [Function: draw] }

// look we have TWO DIFFERENT circle OBJECTS and A SINGLE DEFINITION OF the draw METHOD.

// So this is all about FACTORY FUNCTIONS. 

// But factory functions are not the only way to create objects, 
// we can also use constructor functions, and that's what you're going to learn next.




// --------------------------------------------------
// 5.3 Objects - Constructor Functions

// In this lecture you're going to learn about another pattern for creating objects.

// That is a CONSTRUCTOR FUNCTION,

// so just like the factory function, we're going to create a function, 
// and THE JOB OF THIS FUNCTION IS TO CONSTRUCT OR CREATE AN OBJECT

// However, the naming convention we use for constructor functions is different. 
// So the naming convention we have for factory functions is what we call camel notation,
// so the first letter of the first word is lowercase, but the first letter of every word after is uppercase. 
// This is what we call camel notation. 

// So it looks like this, camel notation, you've got oneTwoThreeFour

// You can see the first letter of the first word is lowercase.
// And these upper case letters, look like camel humps, that's why we call it camel notaton. 

// In contrast, we have another notation that is called PASCAL NOTATION, 
// and in this notation, the FIRST LETTER of EVERY WORD should be UPPER CASE. 

// So OneTwoThreeFour. 

// You can see the pattern right?

// Now, WHEN NAMING CONSTRUCTOR FUNCTIONS, WE SHOULD USE PASCAL NOTATION by convention, 
// because that's something other JavaScript developers expect when they read your code. 

// So we're going to call this function circle with a capital C. 

// Note that I did not call this create circle and you will see that in a second.

function Circle() {

}

// Now, just like our factory function, here we need to add a parameter, radius
// however, instead of returning an object,
// we're going to use a different approach to initialize an object.

// In JavaScript, we have a keyword called "THIS". 
// And "THIS" is a REFERENCE TO THE OBJECT THAT IS EXECUTING THIS PIECE OF CODE.

// You're going to see that in a second. 
// For now, just imagine this references an empty object. 

function Circle() {
    this
}

// Now you know what with dot notation, we can access properties of an object, 
// we can read a property, or we can set a property, 

// So on this new empty object, we want to add a property called radius, 
// and we set that to this radius argument that we receive here.


function Circle(radius) {
    this.radius = radius;
}

// So in JavaScript our objects are dynamic. 
// Once we create them we can always add additional properties or methods to them. 
// So here WE ARE ADDING A NEW PROPERTY TO AN EMPTY OBJECT. 

// Now similarly, we are going to use this approach to add a draw method to this new empty object.

// So this.draw, 
// but we set this to a function 
// and in the body of this function we simply do a console.log of draw.


function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

// Now finally in order to create a circle object using this constructor function, 
// we're going to DEFINE A CONSTANT called circle and here we're going to use another keyword,
// that is "NEW", circle, and pass 1 as the radius. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(1);


// What is happening here? 
// Well, when we use this "NEW" OPERATOR here, 3 things happen. 

// This "NEW" OPERATOR CREATES AN EMPTY JavaScript OBJECT. 

// Something like this. Constant, x, set to an empty object. 
// const x = {};
// That is happening under the hood, but you don't see that. 

// Next, IT WILL SET "THIS" TO POINT TO THIS NEW EMPTY OBJECT "{}"

// So in this code we have access to this new empty object, 
// and we set this "radius" property as well as the "draw" method in this new object.

// Finally, this "NEW" OPERATOR WILL RETURN THIS NEW OBJECT FROM THIS FUNCTION,
// so it looks like this. 

// return this;

// We don't have to explicitly add the statement here in this function, 
// this will happen under the hood. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
    return this;
}

const circle = new Circle(1);

// So let me recap, when we use the "NEW" OPERATOR, 3 THINGS HAPPEN, 

// this operator FIRST CREATES AN EMPTY OBJECT "{}"

// then IT WILL SET "this" TO POINT TO THIS OBJECT "{}"

// and finally IT WILL RETURN THAT OBJECT from this function "return this;".

// So what we get here is that new object "new circle(1);" 
// and we simply set the " const circle" to point to that object. 

const circle = new Circle(1);


// Now let's see THE DIFFERENCE BETWEEN FACTORY AND CONSTRUCTOR FUNCTIONS.

// So with factory functions we create an object like this.
// myCircle here we call createCircle and pass an argument. 

// FACTORY FUNCTION
const myCircle = createCircle(1);

// So WITH FACTORY FUNCTIONS, 
// WE SIMPLY CALL A FUNCTION
// AND IN THIS FUNCTION WE RETURN A NEW OBJECT. 

// In contrast, 

// WITH CONSTRUCTOR FUNCTIONS
// WE USE THE "NEW" OPERATOR, 
// AND INSTEAD OF RETURNING AN OBJECT WE USE THE "this" KEYWORD. 

// CONSTRUCTOR FUNCTION
const circle = new Circle(1);

// Also in terms of naming convention 
// with CONSTRUCTOR FUNCTIONS we use the PASCAL NAMING convention, 
// but in FACTORY FUNCTIONS we use the CAMEL notation. 

// So you might be asking 
// WHICH APPROACH or which pattern YOU SHOULD YOU USE TO CREATE NEW OBJECTS. 

// Both these patterns are EQUALLY GOOD for creating new objects, 

// the CONSTRUCTOR FUNCTION pattern is familiar to developers who have 
// some experience programming in languages like C# and Java. 

// So with this pattern you can see that we're creating a new circle.
// Alright, 

// if you don't have any experience in languages like C# or Java, 
// you might want to go for a FACTORY FUNCTION. 

// There is really no difference between these two patterns, however, 
// there are some discussions online by some strongly opinionated developers 
// comparing these to patterns, 
// my suggestion to you is do not get hung up on these discussions, 
// they're just a waste of time, 

// pick one pattern, and just stick to that.




// --------------------------------------------------
// 5.4 Objects - Dynamic Nature of Objects

// One thing we need to understand about objects in JavaScript is that they are dynamic
// which means once you create them you can always add new properties or methods, 
// or remove existing ones. 

// So here we have a circle object with a single property that is radius, 

const circle = {
    radius: 1
};

console.log(circle);
// output:
// { radius: 1 }


// we can add another property like color set it to yellow
// now when we log the circle on the console you can see we have two properties, 
// color and radius. 

const circle = {
    radius: 1
};

circle.color = "yellow";

console.log(circle);
// output:
// { radius: 1, color: 'yellow' }

// Similarly, we can add a new method here, circle.draw, we set it to new function 
// and now when we log this on the console we can see our circle object 
// has three members, two properties, color and radius, and one method.

const circle = {
    radius: 1
};

circle.color = "yellow";
circle.draw = function () { }

console.log(circle);
// output:
// { radius: 1, color: 'yellow', draw: [Function] }

// We can also delete existing properties or methods, so here before logging the circle, 
// we can use the "delete" operator, to delete a member from a circle object. 

// That member can be a property method. So circle.color 
// we can also delete the draw method, so circle.draw, now save the changes, 
// we can see now our circle object has only the radius property that we added at the
// time of creating this object. 

const circle = {
    radius: 1
};

circle.color = "yellow";
circle.draw = function () { }

delete circle.color;
delete circle.draw;

console.log(circle);
// output:
// { radius: 1 }

// Now something some developers find confusing is that here 
// we have used the const keyword, to define a new constant. 

// However, you can see I have modified the circle object of either the property, 
// and then remove that property.

// So what kind of constant is that? 

// Well, when we use constant here "const circle = " 
// that means we cannot reassign this variable, 
// so this variable is more accurately a constant. 

// So we cannot reset circle to a new object. 
// If we do that, we get this error: "TypeError: Assignment to constant variable". 

const circle = {
    radius: 1
};

circle = {};
// output:
// TypeError: Assignment to constant variable.

// So we cannot REASSIGN this constant, 
// but we can always change the circle object by adding or removing properties.




// --------------------------------------------------
// 5.5 Objects - Constructor Property

// EVERY OBJECT in JavaScript HAS A PROPERTY CALLED CONSTRUCTOR.
// And THAT REFERENCES THE FUNCTION THAT WAS USED TO CONSTRUCT OR CREATE THAT OBJECT. 

// So here we have two objects circle and another. 

function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

const circle = createCircle(1);

// Constructor Function
function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1); // constructor function

// Let's look at their constructor property. 
// So, here, on the console, another.constructor.
// So as you see, this returns our circle function that we used to create this object. 

console.log(another.constructor);
// output:
// [Function: Circle]

// Now let's look at circle.constructor. What is this?
// Well, we can tell that this is a function, because here we have this blue f. 
// And as you can see the first letter of this function is uppercase. 

console.log(circle.constructor);
// output:
// [Function: Object]

// So this is a BUILT IN CONSTRUCTOR FUNCTION in JavaScript, 

// WHEN WE CREATE AN OBJECT USING OBJECT LITERAL SYNTAX, 
// INTERNALLY THE JAVASCRIPT ENGINE USES THIS "Constructor" FUNCTION. 
// Let me show you. So I'm going to temporarily delete all this code, 

// let's define an object like this,

let x = {};

// WHEN WE USE THIS SYNTAX, OBJECT LITERAL, 
// JavaScript will translate that to something like this. 

let x = new Object();

// Okay?
// So, the circle object we created, and returned it, from our factory function, 
// and because we used the object literal syntax, 
// internally it was created using this "Object" constructor function.

// In JavaScript we have a few other built in constructors, for example, 
// we have "String" for creating strings, 

new String();

// but quite often we use string literals. 
// So, single quote, or double quote, or back tick: '', "", ``

// Using these literals is cleaner and simpler than using the "constructor".

// We also have "Boolean", but again we don't use this, we either use true or false. 
// So we refer to these as boolean literals. 

new Boolean();

// We also have "Number", but instead we use number literals, like 1, 2, 3, whatever. 

new Number();

// So this is what I want you to take away, 

// EVERY OBJECT HAS A CONSTRUCTOR PROPERTY,
// AND THAT REFERENCES A FUNCTION THAT WAS USED TO CREATE THAT OBJECT.




// --------------------------------------------------
// 5.6 Objects - Functions are Objects

// ONE OF THE CONFUSING CONCEPTS IN JAVASCRIPT IS THAT HERE FUNCTIONS ARE OBJECTS. 

// So this Circle function we have here, is actually an object. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1);

// Don't believe me? Let me show you. So 

// Circle.

// Look these are all the members of the circle function or circle object.

// So the purple icons are methods, like call, bind, and apply,
// and the blue icons are properties. 

// So let's take a look at a few of these members in the console. 
// Here in the console

console.log(Circle.name); // that returns the name of this function.
// output:
// Circle 

console.log(Circle.length); // returns the number of arguments, 
// output:
// 1

// now earlier in the last lecture I told you that 
// EVERY OBJECT IN JAVASCRIPT HAS A CONSTRUCTOR PROPERTY, 
// AND THAT REFERENCES THE FUNCTION THAT WAS USED TO CREATE THAT OBJECT. 

// Now here's the interesting part, who do you think, created this object?
// Let's have a look, so 

console.log(Circle.constructor);
// [Function: Function]

// so here we have another built in constructor called "Function", 
// and when we declare a function using this syntax, internally, 
// JavaScript engine will use this Function constructor to create this object.

// Let me show you. 

// So, I'm going to define a constant called Circle1, 
// to separate from our circle.

// Set it to new Function, 
// now here our function requires one parameter, radius, 
// so we add that here as a string.

const Circle1 = new Function('radius')

// Now as a second argument, 
// I'm going to pass the code inside of this function. 

// So to break it up into multiple lines. 
// I'm going to use the back tick character, 
// and then simply copy all this code and put it here, 

// SO WHEN WE DECLARE A FUNCTION, INTERNALLY IT'S REPRESENTED LIKE THIS.

const Circle1 = new Function('radius', `
this.radius = radius;
this.draw = function() {
    console.log('draw');
}
`);

// Now we can call this Circle1, just like calling our circle function. 

// So, we can create a circle object by "newing up" Circle1, "new Circle1()" 
// and pass 1 as the radius, save the changes, 
// now in the console, let's log circle. 

const circle = new Circle1(1);
console.log(circle);
// output:
// anonymous { radius: 1, draw: [Function] }

// Look, it's a real circle object with these two members (draw and radius).


// Now let's take a look at a couple methods that are available in our functions. 
// So I'm going to delete all this code, 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1);

// here we have this "call" method, 
// and with this we can call a function. 

Circle.call()

// Look at the arguments. The first argument, is "thisArg"
// Here we need to pass an empty object {} 
// and "this." will reference this object {} that we pass here (inside the .call() brackets).

Circle.call({})

// Okay? Now after that we add our arguments explicitly, 
// so here we have one argument (radius), we pass 1,
// if we had multiple arguments we would pass them explicitly like this, okay?

Circle.call({}, 1)

// So, this expression is EXACTLY LIKE this expression:

const another = new Circle(1);

// when we use the "new" OPERATOR, 
// THIS NEW OPERATOR WILL INTERNALLY CREATE AN EMPTY OBJECT {}
// AND PASS THAT AS THE FIRST ARGUMENT TO THE CALL METHOD.

// And this object will determine the context for "this." 
// so "this." will reference this object the {} inside Circle.call({}, 1)

// Earlier I told you that IF YOU DON'T USE THE NEW OPERATOR
// "THIS."" BY DEFAULT WILL POINT TO THE GLOBAL OBJECT WHICH IS WINDOW. 

// So, if I want to rewrite this expression

const another = new Circle(1);

// in this way:

Circle.call({}, 1)

// instead of passing an empty object, I would pass window.

Circle.call(window, 1)

// Of course we don't want to do this, 
// I'm just explaining to you what happens under the hood. 
// So, let's revert this back,

// so the first argument here ({})

Circle.call({}, 1)

// specifies the target of this. Okay? 

// Now we have another method called "apply".

Circle.apply();

// It's exactly like the call method, with this we can call a function, 
// BUT INSTEAD OF PASSING ALL THE ARGUMENTS EXPLICITLY WE PASS THEM IN AN ARRAY. 

Circle.apply({}, [1, 2, 3]);

// So this is useful if you already have an array somewhere in your application, 
// and you want to pass that array as the second argument to the apply method.

// So this is the takeaway. 
// IN JAVASCRIPT, FUNCTIONS ARE OBJECTS.




// --------------------------------------------------
// 5.7 Objects - Value vs Reference Types

// In JavaScript we have TWO CATEGORIES OF TYPES. 
// On one side we have VALUE TYPES, also called primitives, 
// on the other side we have REFERENCE TYPES. 

// So in the value types category we have 
// number, string, boolean, symbol (which is new in ES6) as well as undefined and null. 
// These are the primitive or value types. 

// On the other side we have objects, functions, and arrays.

//      VALUE TYPES         REFERENCE TYPES
//
//      Number              Object
//      String              Function
//      Boolean             Array
//      Symbol
//      undefined
//      null

// So in the last lecture you learned that FUNCTIONS ARE ALSO OBJECTS.
// THE SAME IS TRUE ABOUT ARRAYS, 
// so in a nutshell in JavaScript we have Primitives and Objects. 

// Now in this lecture, 
// I'm going to SHOW YOU HOW PRIMITIVES AND OBJECTS BEHAVE DIFFERENTLY, 
// because this is absolutely important for you to understand, 
// before we move onto the next section where I talk about Prototypes. 

// So on this empty canvas, I'm going to define two primitives, x and y. 
// I'm going to set y to x, so here y is 10,
// now I'm going to change the value of x to 20, 

// what I want you to note here, is that X AND Y ARE TWO INDEPENDENT VARIABLES,
// so, let's save the changes, go back in the console,
// let's log x and y,

let x = 10;
let y = x;

X = 20;

console.log(x);
console.log(y);
// output:
// 10
// 10

// x is 20, and y is 10
// they are INDEPENDENT. 

// So WHEN WE WORK WITH PRIMITIVES. 
// THIS VALUE (10) THAT WE HAVE HERE IS STORED INSIDE OF THIS VARIABLE (X). 

// WHEN WE COPY THAT VARIABLE THAT VALUE THAT IS STORED IN THE VARIABLE (X)
// IS COPIED INTO THIS NEW VARIABLE (Y). 

// So THEY ARE COMPLETELY INDEPENDENT OF EACH OTHER. 

// NOW LET'S SEE WHAT HAPPENS IF WE USE A REFERENCE TYPE or an object HERE. 

// So I'm going to change this (let x = 10) 
// to an object that has a property called value ( let x = { value: 10 } ). 
// And then instead of saying x to 20, I'm going to set x.value to 20.
// So save the changes, 
// let's log x so you can see value property is 20, 
// now let's log y, you can see the value property of y is also 20. 

let x = { value: 10 };
let y = x;

X.value = 20;

console.log(x);
console.log(y);
// {value: 20}
// {value: 20}

// So this is the takeaway,

// WHEN WE USE AN OBJECT, THAT OBJECT IS NOT STORED IN THIS VARIABLE (x).

// THAT OBJECT IS STORED SOMEWHERE ELSE IN THE MEMORY (12345), 
// AND THE ADDRESS OF THAT MEMORY LOCATION (12345) IS STORED INSIDE THAT VARIABLE. 

// So then when we copy x into y, 

// let y = x;

// IT'S THE ADDRESS OR THE REFERENCE (12345) THAT IS COPIED. 
// In other words, BOTH X AND Y ARE POINTING TO THE SAME OBJECT IN MEMORY (12345). 

// And WHEN WE MODIFY THAT OBJECT USING X, OR Y, 
// THE CHANGES ARE IMMEDIATELY VISIBLE TO OTHER VARIABLE. 

// So here's the conclusion. 

// PRIMITIVES ARE COPIED BY VALUE
// REFERENCE TYPES (OR OBJECTS) ARE COPIED BY BY THEIR (memory) REFERENCE.

// Let's take a look at another example. 

// So I'm going to define a function called increase that takes a number,
// and here we simply increase this number by one.
// Let's declare a number variable and set it to 10. 
// And then call increase and pass this number. 

// Now, if I log this number on the console, what do you think you'll see? 
// Let's have a look. So save the changes, we see 10. 

// Primitive Types VALUE - Example with Function
let number = 10;

function increase(number) {
    number++;   // this variable number here 
}                // is COMPLETELY INDEPENDENT OF THE let "number" VARIABLE above.

increase(number);
console.log(number);
// 10

// But didn't we increase the number?
// WELL WHEN WE CALL INCREASE AND PASS THIS NUMBER VARIABLE 
// IT'S VALUE IS COPIED INTO THIS PARAMETER THAT IS LOCAL IN THIS FUNCTION. 

// SO THIS VARIABLE HERE IS COMPLETELY INDEPENDENT OF THIS OTHER NUMBER VARIABLE. 

// Here in this function, we increment this number by 1, so it will be 11, 
// but after this function this number is going to go out of the scope. 

// So when we log this number on the console, 
// we're essentially dealing with this first number. 

// So I told you that PRIMITIVES ARE COPIED BY THEIR VALUE. 

// SO HERE WE'RE DEALING WITH TWO INDEPENDENT COPIES. 
// That's why you see 10 on the console. 


// Now let's change this to a reference type or an object.
// So, I'm going to change 10 to an object, that has a value property. 
// Okay? Let's rename this variable to object, and similarly, 
// im going to rename the parameter in this function to object, 
// and then increment object.value.

// Now when we log this on the console, what do you think we're going to see? 
// We're going to see 11. See? We got this object with value 11. 

// Reference Types VALUE - Example with Function
let object = { value: 10 };

function increase(object) {
    object.value++;
}

increase(object);
console.log(object);
// 11

// THE REASON FOR THIS IS BECAUSE WHEN WE CALL INCREASE AND PASS THIS OBJECT. 
// THIS OBJECT IS PASSED BY IT'S REFERENCE. 

// So this local parameter that we have here (in the function: increase(object)) 
// WILL POINT TO THE SAME OBJECT that we defined here (in the let statement: let object). 

// SO IN THIS CASE WE ARE NOT DEALING WITH TWO INDEPENDENT COPIES, 
// WE HAVE TWO VARIABLES THAT ARE POINTING TO THE SAME OBJECT. 
// SO ANY CHANGES WE MAKE TO THIS OBJECT WILL BE VISIBLE TO THE OTHER VARIABLE. 

// So remember this, in JavaScript 
// we have value types, also called primitives, 
// as well as reference types which are objects. 

// Our primitives are number, string, boolean, symbol, undefined and null. 

// PRIMITIVES OR VALUE TYPES ARE COPIED BY THEIR VALUE 
// REFERENCE TYPES OR OBJECTS, ARE COPIED BY THEIR REFERENCE.




// --------------------------------------------------
// 5.8 Objects - Enumerating Properties of an Object

// So here we have this circle object with the radius property and the draw method.

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};


// Earlier in the course, you learned how to use 
// the FOR IN and FOR OF loops to iterate over the properties in an object. 

// So in this lecture I'm going to review this one more time to make sure 
// you fully understand how everything works. 

// So first, let's take a look at the FOR IN loop. 
// for let key in circle  
// with this we can iterate over all the properties and methods of an object. 
// Now we can log the key on the console, 

for (let key in circle)
    console.log(key);

// output:
// radius
// draw

// so, we have radius, and draw, 
// and if you want to get the value of a property, 
// we use the bracket notation here. 

// So as the second argument here, we pass circle of key (circle[key]). 
// So we're using the bracket notation to get the value of this key or this property. 
// Save the changes 
// so you can see the value of radius is 1, and the value of draw is a function. 
// And here's the implementation of our draw function or draw method. 

for (let key in circle)
    console.log(key, circle[key])

// output:
// radius 1
// draw [Function: draw]

// Now we also have this new FOR OF LOOP, let's take a look. 
// So for let key of circle simply log it on the console, 
// now when I save the changes, we're going to see an error, circle is not iterable.

for (let key of circle)
    console.log(key);

// output:
// TypeError: circle is not iterable

// So earlier I told you that the FOR OF LOOP CAN ONLY BE USED WITH ITERABLES 
// SUCH AS ARRAYS AND MAPS.

// You have not learned about maps yet, you're going to learn about them later in the course,

// what you need to know is that AN OBJECT IS NOT ITERABLE, 
// SO WE CANNOT ITERATE IT USING A FOR OF LOOP. 

// However, we have this METHOD Object.keys of circle (Object.keys(circle))
// WITH THIS WE CAN GET ALL THE KEYS IN OUR CIRCLE OBJECT, AND THIS WILL RETURN AN ARRAY. 

// AND SINCE ARRAYS ARE ITERABLE. 
// WE CAN USE THE FOR OF LOOP TO ITERATE THEM. 
// Now save the changes, again, we get radius and draw. 

for (let key of Object.keys(circle))
    console.log(key);

// output:
// radius
// draw

// Now let's keep a closer look at this method here.

// Object.keys(circle)

// So earlier YOU LEARNED THAT THIS "Object" IS A BUILT IN CONSTRUCTOR FUNCTION. 

// So somewhere we have this constructor function like this

// function Object() {}

// and whenever we create an object using the object literal syntax, 
// internally that is translated into a call to this constructor function (Object). 

// So when we create an object using the object literal syntax, 
// like this 

const x = { value: 1 }

// internally, that is translated to a call to this Object constructor function. 

// So that looks like this. Right?

const x = new Object();

// Also, you learned that all functions in JavaScript are objects, 
// so they have properties and methods that we can access using the dot notation.

// So when we type Object. 
// we can see all the properties and methods defined in this object, 
// so here we're using the keys method, 

Object.keys

// and THIS METHOD RETURNS A STRING ARRAY WHICH CONTAINS 
// ALL THE PROPERTIES AND METHODS IN THIS OBJECT. 

// We have another similar method to object.keys 
// Let me duplicate this, that other METHOD is called "entries".

Object.entries

// SO INSTEAD OF RETURNING THE KEYS AS A STRING ARRAY 
// IT RETURNS EACH VALUE PAIR AS AN ARRAY. 
// Let me show you. 

// So let's rename key to entry. And to do that we can press f2,
// to rename all the references to this key variable.
// Let's change that to entry, we can see that is updated here as well.
// Save the changes. 

for (let entry of Object.entries(circle))
    console.log(entry);

// output:
// [ 'radius', 1 ]
// [ 'draw', [Function: draw] ]

// SO YOU CAN SEE EACH ENTRY IS AN ARRAY, 
// THE FIRST ELEMENT IN THIS ARRAY IS THE KEY, AND THE SECOND ELEMENT IS THE VALUE. 

// so that is also ANOTHER WAY TO GET ACCESS TO ALL THE PROPERTIES
// AND METHODS IN AN OBJECT. 

// And finally SOMETIMES YOU WANT TO SEE IF A GIVEN OBJECT HAS A GIVEN PROPERTY OR METHOD. 
// To do that, you can use the "in" operator. 
// Here's an example. 
// If radius as a string in circle we display a message like yes. 

if ('radius' in circle) console.log('yes');
// output:
// yes

// WITH THE "in" OPERATOR YOU CAN SEE IF A GIVEN PROPERTY EXISTS IN A GIVEN OBJECT.

// Save the changes, so we get yes here, 
// if I change radius to let's say color, 
// we're not going to see the yes message now. 
// Save the changes, yes disappears.

if ('color' in circle) console.log('yes');
// output:
// 

// So THE SIMPLEST WAY TO ENUMERATE THE PROPERTIES IN AN OBJECT IS USING THE FOR IN LOOP, 
// but WE CAN ALSO USE THE FOR OF LOOP ALONG WITH Object.keys AND Object.entries
// and finally TO SEE IF A GIVEN PROPERTY OR METHOD EXISTS IN AN OBJECT WE USE THE IN OPERATOR.

// ALL CODE
const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

for (let key in circle)
    console.log(key, circle[key]);

for (let key of Object.keys(circle))
    console.log(key);

for (let entry of Object.entries(circle))
    console.log(entry);

if ('radius' in circle) console.log('yes');




// --------------------------------------------------
// 5.9 Objects - Cloning an Object

// In the last lecture you learned how to enumerate the properties of an object.

// Now USING THIS TECHNIQUE WE CAN GET ALL THE PROPERTIES IN AN OBJECT
// AND COPY THEM INTO ANOTHER OBJECT. 

// So let's say you want to create another circle object, 
// which is a copy of this circle object here.  

// I'm going to call that another. So constant another, initially we set it to an empty object, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = {};

// now we can use the for in loop to iterate over all the properties in an object, 
// and copy them into this new object. 

// So for, let key, in circle, now we use the bracket notation 
// to access a property with a given key.

for (let key in circle);

// So we set another of key to circle of key.

for (let key in circle)
    another[key] = circle[key];

// So basically here in the first iteration, key will be radius, 
// so this code will be equivalent to this. 

another['radius'] = circle['radius'];

// another of radius, so we're setting the radius property of another object to circle of radius,

// now here on the right side of the assignment operator 
// we're reading the radius property of the circle, the value of this property is 1, 
// so we get 1 and put it in the radius property of the another object. Okay?

// Now lets log another on the console, save the changes, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = {};

for (let key in circle)
    another[key] = circle[key];

console.log(another);
// output:
// { radius: 1, draw: [Function: draw] }

// so here we have this radius property is set to 1, 
// and here's our draw method
// so if we call another.draw everything works as we expect, beautiful.

another.draw()

// But THIS APPROACH FOR COPYING OR CLONING AN OBJECT IS A LITTLE BIT OLD. 

// In modern JavaScript we have better ways to achieve the same thing. 
// One way is to USE THE Object.assign METHOD. 

// Let me show you. 
// So I'm going to comment out these few lines, 
// we have this "Object." that we have seen before, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = Object.assign({}, circle);

console.log(another);

// THIS Object HAS A METHOD CALLED ASSIGN,

Object.assign();

// now here as the FIRST ARGUMENT we can PASS A TARGET OBJECT 
// which CAN BE AN EMPTY OBJECT, OR AN EXISTING OBJECT, 
// you will see the difference in a second.

Object.assign({});

// And THEN WE CAN PASS 1 OR MORE SOURCE OBJECTS. Let's say circle.

Object.assign({}, circle);

// What THIS METHOD DOES IS IT TAKES ALL THE PROPERTIES OF THIS METHOD 
// IN THE SOURCE OBJECT AND COPIES THEM INTO THIS NEW OBJECT, 
// and finally returns the result here.

const another = Object.assign({}, circle);

// So this line of code is exactly equivalent to these three lines.

const another = {};
for (let key in circle)
    another[key] = circle[key];

// If we save the changes, we get the exact same result.

// Now THIS TARGET OBJECT PASS HERE DOESN'T HAVE TO BE AN EMPTY OBJECT, 
// IT CAN BE AN EXISTING OBJECT, it can have 1 or more properties or methods, 
// so as an example, let's add a color property here, we set that to yellow, 
// now, save the changes, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = Object.assign({
    color: 'yellow'
}, circle);

console.log(another);
// output:
// { color: 'yellow', radius: 1, draw: [Function: draw] }

// so, THIS NEW OBJECT HAS THE COLOR PROPERTY THAT WE INITIALLY HAD HERE, 
// AS WELL AS THE MEMBERS OF THE CIRCLE OBJECT. 
// So this is the object.assign method. 


// Now let me revert this back to an empty object,

// I'm going to show you yet ANOTHER SIMPLER AND MORE ELEGANT WAY TO CLONE AN OBJECT.

// We CAN USE THE SPREAD OPERATOR, so, another, here we set this to a new object, 
// and then use the spread operator, which is three dots, to spread the circle object.

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = { ...circle };

console.log(another);
// output:
// { radius: 1, draw: [Function: draw] }

// Basically WHAT THIS OPERATOR DOES IS THAT IT TAKES ALL THE PROPERTIES AND METHODS
// IN THIS OBJECT AND PUTS THEM HERE in between these curly braces {}. 

// So this is the simplest way to clone an object. 
// Save the changes, again, we get the exact same object as before.

// So here's what I want you to take away, 

// Object.assign COPIES THE PROPERTIES AND METHODS 
// FROM 1 OR MORE SOURCE OBJECTS INTO A TARGET OBJECT, 
// AND WE CAN USE THAT TO CLONE AN OBJECT, 
// OR COMBINE MULTIPLE OBJECTS INTO A SINGLE OBJECT, 

// and THE SPREAD OPERATOR IS USED TO SPREAD AN OBJECT, 
// WHICH BASICALLY MEANS GETTING ALL IT'S PROPERTIES AND METHODS 
// AND PUTTING THEM INTO ANOTHER OBJECT.




// --------------------------------------------------
// 5.10 Objects - Garbage Colleciton

// In low level languages like C or C++, 
// when creating an object, we need to allocate memory to it, 
// and when we're done we need to reallocate memory. 

// But in JavaScript, we don't have this concept. 
// We can easily create a new object, at the time we initialized this object,

let circle = {};

// the memory is automatically allocated to this object, next we can use that object,

console.log(circle);

// and when we are done using, we don't need to deallocate the memory. 

// So, our JavaScript engine has what we call a GARBAGE COLLECTOR. 

// The job of this garbage collector is to find the variables or constants 
// that are no longer used and then deallocate the memory that was allocated to them earlier. 

// So you as a JavaScript developer do not have to worry about this. 
// MEMORY ALLOCATION AND DEALLOCATION AUTOMATICALLY HAPPENS BEHIND THE SCENES, 
// and you have no control over that. 

// You cannot tell garbage collector when to run and what variables to remove from memory. 

// So based on some complex algorithms, this garbage collector runs in the background, 
// it figures out what variables are not used, 
// and then it will automatically deallocate their memory.




// --------------------------------------------------
// 5.11 Objects - Math

// So you have learned a lot about objects, 
// now LET'S TAKE A LOOK AT A FEW OF THE BUILT IN OBJECTS IN JAVASCRIPT. 

// The first one we're going to look at is the Math object. 

// So here in Google let's search for JavaScript math the first link is on
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math
// this is your first reference for learning about all the objects in JavaScript. 

// So let's take a look at the Math object, 
// you can see THIS IS ONE OF THE BUILT-IN OBJECTS WITH PROPERTIES AND METHODS 
// FOR MATHEMATICAL CONSTANTS AND FUNCTIONS.

// So if you scroll down you can see the properties, 
// for example one of the useful properties is math.PI so this is the pi number. 

// We have a bunch of other Properties here, 

// and below them we've got all the Methods, 
// the first one is 

Math.abs()

// WHICH RETURNS THE ABSOLUTE VALUE OF A NUMBER 
// so if you give it a negative number, it returns it's positive value.

// So there are a lot of methods here, I'm not going to go through each of them, 
// it's really a waste of your time and my time, 

// all I want you to know is that we've got this Math object built into Javascript, 
// so IN YOUR APPLICATIONS IF YOU EVER HAVE TO DEAL WITH MATHEMATICAL CALCULATIONS, 
// JUST COME BACK TO THIS PAGE AND SEE WHAT METHODS WE CAN USE. 

// In this lecture I'm going to give you a quick demo of a couple of these methods, 
// the first one is the .random METHOD

Math.random()

// So, let's take a look, for each of these methods we have a comprehensive 
// documentation along with examples. Really, really easy. 

// So here in the console, lets call the random method.

console.log(Math.random());
console.log(Math.random());
console.log(Math.random());
console.log(Math.random());
// output:
// 0.8590424339715734
// 0.9317896805903911
// 0.46605613928953993
// 0.42930733604937044

// So every time we call this method we get a new random number between 0 to 1. 
// Now if you want to map this to a given range you need a simple mathematical formula. 

// Back to the documentation for the random method, 
// if you scroll down from the list of examples, we can see this example. 
// Getting a random number between two values.

function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}

// So basically you need a function like this, that takes a min and
// max, and generates a random number between these two values.
// Pretty self explanatory, you don't need more explanation. 

// Another useful method is Math.round
// so we can give it 1.9, and it returns 2. 

Math.round(1.9)
// output:
// 2

// We also have Math.max
// We can give it a bunch of arguments, 
// and it will return the largest number in the list. 

Math.max(1, 2, 3, 4, 5)
// output:
// 5

// Now later in the course this is going to be one of your exercises. 
// So you're going to write a function like the Math.max method here, 
// that takes a varying number of arguments and returns the largest value. 

// We also have Math.min
// which returns the smallest number in this list. 

Math.min(1, 2, 3, 4, 5)
// output
// 1

// So I leave it up to you to look at all the methods available in the Math object.




// --------------------------------------------------
// 5.12 Objects - String

// The second built in object we're going to look at is the String object, 
// so I'm going to define a constant message and set it to a string. 

const message = "hi";

// Now look at this. 

// message. [VSCode pops up all the properties and methods]

// what's going on here? It looks like we have a bunch of properties and methods. 
// But earlier in the course, I told you that string is a primitive type. 

// Primitive types don't have properties and methods. Only objects do. 
// So why is it that we see these properties and methods in this string? 

// Well, the reason for this is because IN JAVASCRIPT WE HAVE TWO KINDS OF STRINGS. 

// So THIS IS WHAT WE CALL A STRING PRIMITIVE BUT WE ALSO HAVE A STRING OBJECT.

const message = "hi"; // String Primitive

// So we have this constructor object string and we can use that to create a new string object.

String() // Constructor Function to create a new string object

// So we can pass the same string here, now because this is a constructor function 
// we need to apply the new operator and now we have another string. 

const another = new String('hi'); // String object

// Now let's take a look at the type of each of these constants. 
// So typeof message, that's a string, but type of another is an object. 

const message = "hi"; // String Primitive
const another = new String('hi'); // String object

typeof (message);
typeof (another);
// output:
// string
// object

// SO THE FIRST CONSTANT IS A STRING PRIMITIVE, THE SECOND ONE IS AN OBJECT. 

// However, when we use the dot notation with a string primitive 
// JavaScript engine internally wraps this with a string object, 
// we don't see that, but we can work with this like a string object.

// Now just like the Math object, if you want to learn about all these methods, 
// it's best to look at the documentation so simply search for JavaScript string.

// Once again, on developer.mozilla.org on this page you can see all the 
// properties and methods of the string object.

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String

// In this lecture, I'm going to show you a few of these methods, but I strongly
// recommend you to look at the documentation once, just to have a quick look to see
// what methods are there in case you need them. 

// So back to our code let's change this string to this is my first message. 

const message = 'This is my first message';

// Here we have the length property which returns the number of characters in a string. 

message.length();
// output:
// 24

// This is particularly useful in situations where we want to make sure the user types 
// at least a certain number of characters inside an input field. 
// Or maybe you want to put a limit. You don't want the user to type in more than 100 characters. 

// Now if you want to access a character at a given index, you can use square brackets, 
// so, message of 0 returns T, message of 1 returns h. 

message[0];
message[1];
// output:
// T
// h

// If you want to see if the string has a special word, you can use the includes method. 
// So, does this string have my, yes it does, but it doesn't have not.

message.includes('my');
// output:
// true
message.includes('not');
// output:
// false

// We also have another method, startsWith 
// so this string starts with this but if you swap the capitol t here we get false, 
// so note that these searches are case sensitive.

message.startsWith('This');
// output:
// true
message.startsWith('this');
// output:
// false

// We have a similar method, ends with so message.ends with e, 
// so you can see the last character here is e. 

message.endsWith('e');
// output:
// true

// If you want to find the index of a given character or a given string, inside the string, 
// you can use the indexOf method. So let's see what is the index of my. 
// So my starts at index 8.

message.indexOf('my');
// output:
// 8

// We can also replace a part of a string so replace, 
// we want to replace first, with second. Pretty easy. 

message.replace('first', 'second');
// output:
// "This is my second message"

// NOTE THAT THIS RETURNS A NEW STRING AND DOES NOT MODIFY THE ORIGINAL ONE. 
// SO, IF YOU LOG THE ORIGINAL ONE, WE STILL HAVE THIS IS MY FIRST MESSAGE. 

console.log(message);
// output:
// "This is my first message"

// We also have a couple of useful methods toUpperCase, 
// once again this returns a new string where all characters are uppercase, 
// similar to this method, we have toLowerCase

message.toUpperCase();
message.toLowerCase();

// and another useful method is trim. 

// So let me add a couple of white spaces here, before and after our message. 
// Now, if we call trim method, it gets rid of all the white space before and after our message. 

message.trim();

// And of course this method, has variations, for example we have trimLeft,
// which only removes the white space at the beginning of the string
// of trim right, and so on. 

message.trimLeft();
message.trimRight();

// ANOTHER IMPORTANT CONCEPT YOU NEED TO KNOW IN JAVASCRIPT, IS ESCAPE NOTATIOn. 
// So if you look at the documentation for the string object, 
// you can see in this table under escape notation, you've got these special characters. 
// So if you want to use these you need to encode these using the escape notation.

//      Code 	Output
//      \' 	    single quote
//      \" 	    double quote
//      \\ 	    backslash
//      \n 	    new line
//      \r 	    carriage return
//      \v 	    vertical tab
//      \t 	    tab
//      \b 	    backspace
//      \f 	    form feed

// \XXX (where XXX is 1–3 octal digits; range of 0–377) 	ISO-8859-1 character / Unicode code point between U+0000 and U+00FF
// \uXXXX (where XXXX is 4 hex digits; range of 0x0000–0xFFFF) 	UTF-16 code unit / Unicode code point between U+0000 and U+FFFF
// \u{X} ... \u{XXXXXX} (where X…XXXXXX is 1–6 hex digits; range of 0x0–0x10FFFF) 	UTF-32 code unit / Unicode code point between U+0000 and U+10FFFF
// \xXX (where XX is 2 hex digits; range of 0x00–0xFF) 	ISO-8859-1 character / Unicode code point between U+0000 and U+00FF

// For example, let's say you want to have a single quote in your string. 
// Now in this example, you have defined this string with a single code. 
// SO IF YOU WANT TO HAVE A SINGLE CODE INSIDE OF THIS STRING, 
// LOOK, OUR JAVASCRIPT ENGINE GETS CONFUSED, BECAUSE IT THINKS THIS SECOND SINGLE CODE 
// REPRESENTS THE END OF THE STRING. 

// TO FIX THIS, WE NEED TO PREFIX THIS WITH A BACK SLASH, AND NOW, THIS CHARACTER IS ESCAPED
// it's encoded, so when we log the message you can see the single code is actually part of the string.

const message = 'This is my \'first message';
// output:
// This is my 'first message

// Another useful escape character is /n which represents a new line. 
// So back here if we add a /n after my, this will add a new line. So save the changes, 
// let's look at message on the console, you can see we have a new line here.

const message = 'This is my\n first message';
// output:
// This is my
// first message

// Another very useful method, is the split method. 
// So message.split, WITH THIS WE CAN SPLIT A STRING BASED ON A GIVEN CHARACTER. 
// So here I'm going to pass a white space, and see what we get, we get an array of 5 items. 
// And each item in this array is a word in our message. 

message.split(' ');
// output:
// [ 'This', 'is', 'my', 'first', 'message' ]

// Next, we're going to look at template literals.




// --------------------------------------------------
// 5.13 Objects - Template Literals

// In the last lecture you learned that /n adds a new line to a string.
// Now what I don't like about this approach is that it doesn't allow us
// to visualize what the output looks like

// In other words, if we log message on the console, 
// we can see this is what the outcome looks like, 
// so on the first line we have this is my, and on the second line we have first message. 
// But when writing code, our string looks different. 

// Now if you want to make this string similar to what the output looks like, 
// we have to do something like this. 

// So, we break this string into 2 parts, and concatenate them like this, 
// and then we add the second part on a new line. 
// We can also put the first part on a new line. 
// And now this kind of looks similar to what we have in the output. 

const message =
    'This is my \n' +
    'first message';
// output:
// This is my
// first message

// But we still have this \n getting in the way creating some noise in the code. 
// To make the matter worse, if you want to surround first with single quotes, 
// you'll have to escape the single code character like this.

const message =
    'This is my \n' +
    '\'first\' message';
// output:
// This is my
// 'first' message

// Again, this is very very ugly, let's log this one more time, very very ugly and noisy. 

// That's where Template Literals come in the picture. 

// So far you have learned about different kinds of literals in JavaScript. 
// So we have object literals which are indicated by curly braces, 
// we have boolean literals which are true or false. 
// We have string literals which are indicated by single or double quotes. 
// Now starting from ES6 we have template literals. 
// Which are indicated by the back tick character. 

// Object literals      { }
// Boolean literals     true, false
// String literals      '', ""
// Template literals    ``

// This back tick character is the character before number 1 on your keyboard.
// So let's see how template literals help us write cleaner code.

// I'm going to define another constant, 
// but this time I'm going to use a template literal instead of a string literal.

// So, we add the back tick character, this is my, now to add a new line, 
// we don't need to add \n here, we can simply add a line break and then type first message.
// So we can format our string the way we want it to look like. 
// So now, let's log message, and another. See? 
// What we have in code looks very similar to what we have in the output.

const another = `This is my
first message`;
// output:
// This is my
// first message

// Now we can also put this on a new line, 
// now if you want to surround first with single quotes we can simply add them here, 
// there is no  need to escape them. 
// Because we have used a different character to define our string. 
// So save the changes, one more time, message another, they look identical
// but compare this code with the former code.

const another =
    `This is my
'first' message`;
// output:
// This is my
// 'first' message

// This is particularly useful if you want to send out email
// messages in your application. For example, let's say you want to
// send an email to the user like this. 
// So we can format our string exactly the way we want it to look like. 
// There is no need for any of these plus or /n characters. 

const another =
    `Hi John,

Thank you for joining my mailing list.

Regards,
Mosh`;

// So, let me delete all this stuff.

// Now, another benefit of using template literals is that here we can add placeholders. 
// So let's say we want to add the name dynamically,

// With a regular string we'll have to do something like this.
// So message, we set it to hi, then we have to concatenate this with some variable or constant, 
// that we define name here set it to John, 
// now we'll have to concatenate this message with name,
// then add a comma, then \n

const name = 'John';
const message = 'Hi' + name + ',\n'; // this is really, really ugly.

// Let me show you a better way. 
// With template literals, 
// we can add a place holder using a dollar sign and curly braces ${}.

// Now inside these curly braces we add an expression. 
// We can pass the name of a variable or a constant, now let's save the changes, 
// let's take a look at another, you can see we've got John here DYNAMICALLY. 
// So THIS ${name} IS A PLACEHOLDER FOR OUR NAME CONSTANT.

const name = 'John';
const another =
    `Hi ${name},

Thank you for joining my mailing list.

Regards,
Mosh`;
// output:
// Hi John,
//
// Thank you for joining my mailing list.
//
// Regards,
// Mosh

// Now here we can add any kind of expression. We can also add a simple mathematical expression,
// like this, let's log this one more time, so, Hi John 5.

const name = 'John';
const another =
    `Hi ${name} ${2 + 3},

Thank you for joining my mailing list.

Regards,
Mosh`;
// output:
// Hi John 5,
//
// Thank you for joining my mailing list.
//
// Regards,
// Mosh

// So technically 
// WE CAN ADD ANY EXPRESSION THAT PRODUCES A VALUE IN BETWEEN THE CURLY BRACES. 
// WE CAN ALSO CALL FUNCTION THAT RETURNS A VALUE, AND THAT'S PERFECTLY VALID. 

// So these are the benefits of using template literals.




// --------------------------------------------------
// 5.14 Objects - Date

// And finally, the last built in object we're going to look at in this section 
// is the date object. 

// Now just to clarify, the objects that we're looked at in this section 
// they are not the only built in objects in JavaScript, 
// there is more and you're going to learn about them as we go through the course.

// So let's see different ways to create a Date object. 

// We can create date1 set it to new date, so date is a constructor function. 

// Now when you open parenthesis here, you can see this number here, 2 of 6, 
// that shows different versions of this Date constructor. 

// You can use the up and down arrows to cycle through these,
// so we can use the date constructor without any parameters,
// and this returns the current date time. 
// So let's rename this to now.

const now = new Date()

// Let's create another date object, new date, 
// we have another constructor with 1 parameter called value, 
// which can be a string or a number which is the number of milliseconds 
// from January 1st 1970 or another date object.
// So here I'm going to pass a string let's say May 11 2018, 9 AM. 

const date1 = new Date('May 11 2018 09:00');

// Now this format is not the only format that you can pass here, 
// if you want to find out about all possible formats that are supported, 
// simply search for JavaScript date, on this page, if you scroll down, here under dateString, 
// you can read about various formats that are supported. 

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date

// And finally, another way to create a date object, is by passing numbers. 
// So here we have another constructor, with these parameters, year, which is a number,
// month is also number, and then so on. So I'm going to pass 2018, 

// now the confusing thing about Date objects is that month is 0 based. 
// So, 0 represents January, and 11 represents December.
// So we're going to use 4 for May. 

// The third parameter is the date parameter, 
// and that's the day of the month. So, 11

// next parameter is hour, so 9 am, and minutes is 0. 
// Now we can exclude this argument,
// because all the other the arguments are initialized to 0 by default.

// So this is how we create a date object.

const date2 = new Date(2018, 4, 11, 9, 0);

// Now, all these date objects have a bunch of get and set methods. 
// For example, now.get so getDate returns the day of the month. 
// getFull year. getHours, getMilliseconds, getMinutes, so on. 

now.getDate();
now.getDay();
now.getFullYear();
now.getMilliseconds();
now.getMinutes();

// We also have set methods.
// So, let's call setFullYear and change the year to 2017.

now.setFullYear(2017);

// We also have setDate, setHours, setMilliseconds, setMinutes and so on. 

// Alright, now, let's see how we can display this on the console. 

// To save the changes, 
// all these date objects have a few methods for converting them to a string. 
// You can call toDateString and we get a string like this.
// So Thursday May 11 2017, note that we changed the year on line 6.

now.toDateString();
// output:
// Thu Jan 30 2020

// We also have toTimesString which returns the time component of this date object,

now.toTimeString();
// output:
// 11:34:36 GMT+0000 (Greenwich Mean Time)

// and another useful method is to ISOString which returns a string like this. 

now.toISOString();
// output:
// 2020-01-30T11:36:01.034Z

// So we have date, then T, and time, this is a standard ISO format, 
// and it's commonly used in applications, 
// so if you're building a web or a mobile app that talks to a back end. 
// This is the format you commonly use to transfer date between the client and the server.




// --------------------------------------------------
// 6.1 Arrays - Introduction

// In this section, we're going to take a detailed look
// at arrays. You're going to learn all kinds of operations that you can
// perform on arrays, such as:

// adding new elements, 
// finding elements, 
// removing elements, 
// splitting arrays 
// combining arrays 

// and so on. 

// These operations are extremely important in programming,
// especially if you are starting out, so make sure to watch every lecture
// and do the exercises that I have designed for you at the end of this section.
// So now, let's get started.




// --------------------------------------------------
// 6.2 Arrays - Adding Elements

// Alright let's start by DECLARING A CONSTANT called numbers
// and we set this to an array with two elements, 3 and 4.

const numbers = [3, 4];

// Now note that here I've declared numbers as a constant, 
// that means we cannot reassign numbers to something else, 
// if we do this, we get this error assignment to constant variable, 

numbers = [];
//output:
// TypeError: Assignment to constant variable

// however IT'S PERFECTLY FINE TO MODIFY THE CONTENT OF THIS ARRAY. 
// We can add new elements, or remove existing elements. 
// So CONSTANT DOES NOT STOP US FROM MODIFYING THE CONTENT OF AN ARRAY. 
// Okay? 

// So, earlier you have learned that arrays are objects,
// so using the dot notation, 
// we can look at all the properties and methods defined in arrays.

// numbers.

// In this lecture, we're going to look at 3 of these methods,
// so add new elements to the end beginning or middle of an array.

// The first method we're going to use is the PUSH METHOD.
// So

numbers.push();

// we can pass 1 or more arguments, and 
// THESE ARGUMENTS WILL BE PLACED AT THE END OF THIS ARRAY. 
// So I'm going to pass 5 and 6 now let's do a console.log of numbers, save the changes,
// so we have 3 and 4, now we have 5 and 6 at the end. 

numbers.push(5, 6);

console.log(numbers);
// output:
// (3, 4, 5, 6)


// If you want to ADD ELEMENTS TO THE BEGINNING OF AN ARRAY, you use the UNSHIFT METHOD. 
// Let me show you. So, 

numbers.unshift();

// This basically pushes the elements in this array to the right, 
// and adds new elements in the beginning. 
// So, again here we can pass one or more arguments, I'm going to pass 1 and 2, 
// now let's bring this console.log down, and by the way to do this, 
// we can hold down the alt key, and press the up or down arrow. That's a good tip to know. 
// So save the changes, now we have 1 and 2 at the beginning of this array. 

numbers.unshift(1, 2);

console.log(numbers);
// output:
// (1, 2, 3, 4, 5, 6)

// And finally if you want to ADD ELEMENTS TO THE END OF AN ARRAY, you use the SPLICE METHOD. 
// So let's bring this down, 

numbers.splice();

// with this method we can go to a given position, and add new elements or remove existing elements. 
// Later in this section, we're going to look at removing elements, so for now don't worry about that. 

// Now look at the parameters of this method. 
// The FIRST PARAMETER IS A START, which is a number. So that's our starting position. 
// So let's say in this array, after 1 and 2 here, between 2 and 3, we want to add a new element. 

// So our starting position is here. What is the index of this element? 
// Well you know that arrays are 0 index. 
// So the index of the first element is 0 and 1 and here's 2. 

// So our starting position, or starting index is 2.

// Now look at THE SECOND PARAMETER HERE, THAT'S DELETE COUNT WHICH IS A NUMBER. 
// How many elements do we want to delete? In this lecture, none. 
// So I'm going to pass 0 

// and then look at the THIRD PARAMETER. THAT'S THE ITEMS YOU WANT TO ADD. 
// So, to make this stand out, I'm going to add 2 characters here. a and b. 
// Save the changes. So note that a and b are placed after 1 and 2.

numbers.splice(2, 0, 'a', 'b');
console.log(numbers);
// output:
// (1, 2, 'a', 'b', 3, 4, 5, 6)




// --------------------------------------------------
// 6.3 Arrays - Finding Elements (Primitives)

// Alright now let's see HOW WE CAN FIND ELEMENTS IN AN ARRAY. 
// FINDING ELEMENTS REALLY DEPENDS ON IF YOU'RE STORING 
// PRIMITIVE OR REFERENCE TYPES IN AN ARRAY. 

// So I'm going to START WITH PRIMITIVES because they're easier.

// And then I will show you how to find reference types in an array. 

// So, let's say we have an array of numbers, with 4 elements. 1, 2, 3, 4.

const numbers = [1, 2, 3, 4];

// Here we have a method called INDEXOF, 
// we PASS THE ELEMENT WE ARE LOOKING FOR, 
// and IF THAT ELEMENT EXISTS IN THE ARRAY, 
// THIS METHOD WILL RETURN THE INDEX OF THAT ELEMENT IN THE ARRAY.
// IF IT DOESN'T EXIST, IT WILL RETURN MINUS 1.

numbers.indexOf();

// Let me show you a few different examples. 
// So first I'm going to pass the character a, obviously we don't have this element 
// so the result that we'll see will be -1.

numbers.indexOf('a');
// output:
// -1

// Look, so INDEX OF RETURNS THE INDEX OF THE GIVEN ELEMENT IN THIS ARRAY. 
// However, if I change this to 1, we get 0, because the index of this element is 0, 

numbers.indexOf(1);
// output:
// 0

// NOTE THAT THE TYPE OF THIS ELEMENT MATTERS,
// so if I pass 1, as a string here, again we get -1, 
// because we don't have 1 as a string in this array, we have it as a number. Okay? 

numbers.indexOf('1');
// output:
// -1

// Now similar to indexOf, we have another method called lastIndexOf. 
// And that WILL RETURN THE LAST INDEX OF THE GIVEN ELEMENT OR -1 IF IT DOESN'T EXIST. 
// So to demonstrate this, I'm going to add another 1 here, 
// now, let's do another console.log, numbers.lastIndexOf(1). Save the changes. 

const numbers = [1, 2, 3, 1, 4];

numbers.lastIndexOf(1);
// output:
// 3

// So the last index of is 3, because it's here, and the index of this element is 3.

// Okay? So basically to see if a given element exists in an array we can do something like this. 
// Console.log numbers.indexOf(1) is not -1.
// If this expression returns true that means this element exists in the array. 
// Let's have a look, save the changes, we've got true here.

console.log(numbers.indexOf(1) !== -1)
// output:
// true

// But this is a little bit ugly, we have a new method in JavaScript for achieving the same thing.
// So, console.log numbers.includes(1). 
// This simply returns true if the given element exists in the array. 
// Let's have a look, so save the changes and we get true here.

console.log(numbers.includes(1))
// output:
// true

// Now, ALL THESE METHODS HAVE A SECOND PARAMETER WHICH IS OPTIONAL. And THAT IS THE STARTING INDEX. 
// For example, with index of, let's change this to 1 as a number, so save the changes, 
// you can see the index of 1 is 0. Because it's here, right?

// However, I can pass a second argument here, that SECOND ARGUMENT IS FROMINDEX. 
// And that's THE INDEX FROM WHICH THE SEARCH WILL BEGIN. 
// So I can pass 2 here, so that is 0, 1, 2, 
// our search will begin here, let's see what we get. Save the changes, 
// so we get 3 which is the index of the second 1 in this array.

const numbers = [1, 2, 3, 1, 4];

console.log(numbers.indexOf(1, 2));
// output:
// 3




// --------------------------------------------------
// 6.4 Arrays - Finding Elements (Reference Types)

// In the last lecture I told you that FINDING PRIMITIVES IS DIFFERENT THAN FINDING REFERENCE TYPES. 

// So let's see why. 
// I'm going to start by declaring a new array called courses, 
// and in this array we're going to have a couple of course objects. 
// So here's the first one with two properties, id and name the name doesn't really matter, 
// now we can duplicate this line,by holding down shift, alt, and the down arrow.
// So, let's change these values, id2, and name b, and don't forget the semi colon here.
// so we have two course objects here, 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

// LET'S SEE IF WE HAVE A COURSE WITH THE NAME A IN THIS ARRAY, 
// the INCLUDES METHOD that you learned in the last lecture WILL NOT HELP US HERE. 
// Now, let me show you. 

// So courses.includes here we pass the object that we're looking for. 
// So, course with id 1, and name a. 
// Now, let's log this on the console. Console.log save the changes, WE GET FALSE, 

courses.includes({ id: 1, name: 'a' });

console.log(courses.includes({ id: 1, name: 'a' }));
output:
false

// THE REASON FOR THIS IS BECAUSE THESE TWO OBJECTS, 
// THAT IS THE OBJECT THAT YOU ARE PASSING TO THE INCLUDES METHOD, 
// AND THE OBJECT THAT WE HAVE IN THE COURSES ARRAY, 
// THESE ARE TWO DIFFERENT OBJECTS. 
// THEY HAVE TWO DIFFERENT REFERENCES, 
// THEY'RE IN TWO DIFFERENT LOCATIONS IN MEMORY.

// And in the last section, you learned that objects are reference types 
// so when we check them for their equality their references are checked. 

// In this case, there are two different references, that's why we get false. 

// So IF YOU HAVE AN ARRAY WITH REFERENCE TYPES, 
// you need to USE THE FIND METHOD. 

//Let me show you. So I'm going to delete this line, 

courses.find();

// Now look at the parameter of this method. What we see is way to complicated. 
// So, whenever you want to learn about an object or a function in JavaScript, 
// simply search for that. javascript array find 
// Here the first link is from developer.mozilla.org. So, that's a good reference,
// here we can find a good description of what this method does
//  and a very simple example of using that method.

// So here we have an array with a few numbers. 

var array1 = [5, 12, 8, 130, 44];

// We're calling the find method 

var found = array1.find();

// NOTE THAT AS AN ARGUMENT TO THIS METHOD WE HAVE TO PASS A FUNCTION.
// We call this function a PREDICATE, 

var found = array1.find(function (element) {

});

// AND WE USE THAT TO DETERMINE IF THE GIVEN ELEMENT EXISTS IN AN ARRAY OR NOT. 

// So, this function takes a parameter, 
// that's an element in this array. 
// And in the body of this function, 
// we should return a boolean. 

// So here we have a simple expression 
// if this element is greater than 10, we'll return true, otherwise we'll return false. 

var found = array1.find(function (element) {
    return element > 10;
});

// So this is what happens when we call the find method and pass this function. 

// This function is executed once for the first element in this array. 

// So in this case 5 will be passed here. 
// 5 is not greater than 10 so we'll return false, and the search will continue. 

// Now this function will be called for the second element in this array. 
// So, 12 will be passed as an argument to this function, and because it's greater than 10, 
// we'll return true and the search will stop here.

// So now, what we'll get here as a result of calling the find method 
// is the first element that matches this criteria. 

// So if you log this found variable on the console, we'll get 12. 

var array1 = [5, 12, 8, 130, 44];

var found = array1.find(function (element) {
    return element > 10;
});

console.log(found);
// output:
// 12

// Now in contrast, IF THERE ARE NO ELEMENTS IN THIS ARRAY THAT MATCHES THIS CRITERIA, 
// WE'LL GET UNDEFINED. 

// Let me show you. So, back to our example, let's say we want to 
// see if we have a course with the name a in this array. 

// So we pass a function. here we call this a PREDICATE or a CALLBACK function, 
// BECAUSE THE FUNCTION IS CALLED BACK AS PART OF FINDING AN ELEMENT IN THIS ARRAY. 

course.find(function ())

// So here we should have a parameter, we can call that element, or course, 
// because  each element in this array is a course object, so it's better to be more explicit, 
// that makes our code more readable and understandable. 

course.find(function (course)) {

}

// So, what is our criteria? We're looking for a course with the name equal to a.
// So, we simply return this and let's store the result in a constant called course. 

course.find(function (course)) {
    return course.name === 'a'
}

// And finally let's log this on the console. Here's the course object, save the changes,
// and that's the course with the name a. We get the complete course object that we have in this array. 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.find(function (course) {
    return course.name === 'a';
});

console.log(course);
// output:
// { id: 1, name: 'a' }

// Now if I change the search criteria to something like this. xyz,
// obviously we don't have a course with this name, so when we save the changes,
// we get undefined. 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.find(function (course) {
    return course.name === 'xyz';
});

console.log(course);
// output:
// undefined

// So here's our find method, it returns the first element that matches this criteria. 

// We have a similar METHOD CALLED findIndex, 
// it works exactly the same but instead of returning the actual object, like the course object, 
// IT WILL RETURN IT'S INDEX. 
// Let me show you. 

// So I want to change this to find index, in this case we don't have a course with this name,
// so, when I save the changes, we should see minus 1 on the console. Here it is.

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.findIndex(function (course) {
    return course.name === 'xyz';
});

console.log(course);
// output:
// -1

// Now if I change this back to a and save the changes, we get 0, 
// because THE INDEX OF THE FIRST ELEMENT THAT MATCHED THIS CRITERIA IS 0.

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.findIndex(function (course) {
    return course.name === 'a';
});

console.log(course);
// output:
// 0




// --------------------------------------------------
// 6.5 Arrays - Arrow Functions

// In the last lecture you learned about this predicate (callback) function 
// that we passed on the find method. 

// In ES6 there is a shorter cleaner way to write the same code using arrow functions.

// So WHENEVER YOU WANT TO PASS A FUNCTION, 
// AS A CALLBACK FUNCTION 
// OR AS AN ARGUMENT FOR A DIFFERENT METHOD, 
// YOU CAN USE THE ARROW FUNCTION SYNTAX.

// Let's see how that works. 

// So, YOU REMOVE THE FUNCTION KEYBOARD, 
// and TO SEPARATE THE PARAMETERS OF THIS FUNCTION FROM IT'S BODY 
// PUT A FAT ARROW IN BETWEEN THEM. 

//This is what we call an ARROW FUNCTION.

const course = courses.find(function (course) {
    return course.name === 'a';
});

const course = courses.find((course) => {
    return course.name === 'a';
});

// Now iF YOUR FUNCTION HAS A SINGLE PARAMETER, WE CAN ALSO GET RID OF THE PARENTHESIS, 
// and this makes your code cleaner, you're removing the noise in the code. 

const course = courses.find(course => {
    return course.name === 'a';
});

// IF YOU DON'T HAVE ANY PARAMETERS, YOU HAVE TO PASS AN EMPTY PARENTHESIS. 

const course = courses.find(() => {
    return course.name === 'a';
});

// In this case we have a single parameter so I'm going to bring that back, 
// and finally 

// IF YOU'RE FUNCTION IS A SINGLE LINE OF CODE AND IS RETURNING A VALUE, 
// we can make this code even shorter. 

// First you GET RID OF THE RETURN KEYWORD, AND THEN YOU REMOVE THE CURLY BRACES, like this. 

const course = courses.find((course) => {
    return course.name === 'a';
});

const course = courses.find((course) => {
    course.name === 'a';
});

const course = courses.find((course) =>
    course.name === 'a'
);

// And finally you can put everything on one line. 

const course = courses.find((course) => course.name === 'a');

// So here's the end result. 

// You read this expression as course goes to course.name equals a. 

// So basically we are finding a course with the name equal to a.




// --------------------------------------------------
// 6.6 Arrays - Removing Elements

// Alright now let's see how we can remove elements from an array. 
// So, start by declaring a new array, numbers, and we set this to 1, 2, 3, 4. 
// Earlier in this section you learned about 3 methods to add new elements to an array. 
// You learned about the push method, which we use to add something at the end of an array.
// You learned about the unshift method that we use for adding elements at the beginning of an array, 
// and the splice method that we use for adding an element somewhere in the middle. 

const numbers = [1, 2, 3, 4];

// Now, when it comes to removing an element, 
// again we can remove an element from
// the end, from the beginning and from the middle. 

// But instead of the push method, we use the pop method. 
// This will REMOVE THE LAST ELEMENT IN THIS ARRAY AND RETURN IT. 

numbers.pop();

// So let's store that in a constant called last. 
// And here I'm going to do a console.log of numbers, so you can see the array 
// after we've popped the last element. And also I'm going to show you this last element. 
// Save the changes. So, here's our array, 1, 2, 3, and you can see the last element is 4. 

const last = numbers.pop();
console.log(numbers);
console.log(last);
// output:
// [1, 2, 3]
// 4

// Now, IF YOU WANT TO REMOVE AN ELEMENT FROM THE BEGINNING YOU USE THE shift METHOD. 
// Similar to the pop method this will return the element that was removed.

// So, we can store that in first, and let's have a look here, save the changes.
// So the first element is 1, now if we log numbers we only have 2 and 3. Pretty easy. 

const first = numbers.shift();
console.log(numbers);
console.log(first);
// output:
// [2, 3, 4]
// 1


// And finally the splice method you learned about earlier, 
// so IF YOU WANT TO REMOVE AN ELEMENT SOMEWHERE IN THE MIDDLE 
// YOU PASS THE INDEX OF THAT ELEMENT. 

// So let's say we want to remove this 3 here. 
// The index of this element is 2, so we pass 2 here,

// and as the SECOND ARGUMENT, WE PASS THE NUMBER OF ELEMENTS WE WANT TO DELETE. 
// We can remove 1 element, 
// and then let's log this on the console, numbers, save the changes,
// let's have a look, so let's note that 3 is removed we have 1, 2 and 4.

numbers.splice(2, 1); // at index 2 remove 1 number
console.log(numbers);
// output:
// [1, 2, 4]

// Now if you want to delete multiple elements, you pass a value greater than 1. 
// So you can delete 2 elements, starting from index 2. 
// Save the changes, so 3 and 4 are removed and we only have 1 and 2. 

numbers.splice(2, 2); // at index 2 remove 2 numbers
console.log(numbers);
// output:
// [1, 2]

// So, to recap, 
// USE THE POP METHOD TO REMOVE THE LAST ELEMENT, 
// USE THE SHIFT METHOD TO REMOVE THE FIRST ELEMENT, 
// AND THE SPLICE ELEMENT TO REMOVE AN ELEMENT SOMEWHERE IN THE MIDDLE OF AN ARRAY.




// --------------------------------------------------
// 6.7 Arrays - Emptying an Array

// So now you know how to remove an element from an array. 
// But what about emptying an array? 
// HOW CAN WE REMOVE ALL THE ELEMENTS IN THIS ARRAY. 
// Well, there are a few different solutions. 

// Here's the first solution.
// WE CAN SIMPLY REASSIGN THIS TO A NEW ARRAY. 

const numbers = [1, 2, 3, 4];
// Solution 1
numbers = [];

// Now in this case, because we have declared this array using 
// const we cannot do this, so we have to change this, to let. 
// Now, let's log numbers on the console, save the changes, so, NOW OUR ARRAY IS EMPTY. 

let numbers = [1, 2, 3, 4];
// Solution 1
numbers = [];
console.log(numbers);
// output:
// []

// However, note that THIS OLD ARRAY IS STILL IN THE MEMORY, 
// so IF THERE ARE NO OTHER REFERENCES TO THIS OBJECT
// EVENTUALLY IT WILL BE REMOVED BY THE GARBAGE COLLECTOR. 

// So this means if we have let's say another variable called another, 
// and THIS IS ALSO POINTING TO THE SAME OBJECT, 
// THIS ORIGINAL ARRAY WILL NOT BE GARBAGE COLLECTED. 

// So, line 6. When we reassign the numbers variable, 
// now NUMBERS IS POINTING TO A NEW OBJECT IN MEMORY, 
// but ANOTHER IS STILL POINTING TO THE OLD OBJECT. 

// Let me show you. 
// So here, instead of logging numbers, let's log another. 
// Save the changes. So we can see another is still pointing to this array, to the original array,
// but if you look at the numbers, numbers is now pointing to a new object. 
// To a new empty array. 

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers = [];

console.log(numbers);
console.log(another);
// output:
// []
// [ 1, 2, 3, 4 ]

// So this solution works if you do not have any other references to the original array. 

// IF YOU DO HAVE MULTIPLE REFERENCES TO THE ORIGINAL ARRAY, 
// THEN YOU NEED TO USE ONE OF THE OTHER SOLUTIONS. 

// So, I'm going to comment this out, let's look at solution 2, 
// WE CAN SIMPLY SET THE LENGTH PROPERTY TO 0, AND THIS WILL TRUNCATE THE ARRAY.
// IT WILL REMOVE ALL ELEMENTS. 
// So, here we're logging another. 
// Let's also log the original array. Save the changes. 
// YOU CAN SEE THE ORIGINAL ARRAY IS TRUNCATED 
// SO IT DOESN'T MATTER HOW MANY REFERENCES YOU HAVE TO THAT ARRAY. 
// So here's solution 2.

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers.length = 0;

console.log(numbers);
console.log(another);
// output:
// []
// []

// THE OTHER SOLUTION IS TO USE THE SPLICE METHOD. 
// So in the last lecture you learned that with the splice method you can go to a 
// given position and remove one or more elements.
// SO WE CAN START FROM THE FIRST ELEMENT, AND REMOVE ALL ELEMENTS IN THIS ARRAY. 
// How many elements do we have in this array? Well that is numbers.length, okay?
// Save the changes, again, BOTH ARRAYS ARE EMPTY.

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers.splice(0, numbers.length);

console.log(numbers);
console.log(another);
// output:
// []
// []

// And finally the last solution is to use the pop method.
// So, solution 4. So you learned that pop method removes the last element in this array. 
// Now we can put this in a loop, and keep calling this method, 
// as long as we have an element in this array. 
// So WHILE NUMBERS.LENGTH IS GREATER THAN 0, YOU CAN KEEP POPPING ELEMENTS. 
// Save the changes, again, both arrays are empty. 

let numbers = [1, 2, 3, 4];
let another = numbers;

while (numbers.length > 0)
    numbers.pop();

console.log(numbers);
console.log(another);
// output:
// []
// []

// Now this last solution is not something that I recommend you to do, 
// because if you're dealing with a large array, 
// let's say if you have a million objects in this array, 
// there's going to be a performance cost. 
// You're essentially calling this pop method a million times.

// Okay, however that's not the situation with most applications out there,
// unless you work for Google, but in terms of clean coding, you can see this approach
// is pretty noisy, compare that to the first solution. 

// This is very simple, elegant, the only issue it has is it doesn't work if you 
// have multiple references to this array. 

// So MY PERSONAL PREFERENCE IS TO SET THE LENGTH OF THE ARRAY TO 0, 
// but the first solution is also perfectly valid if you have a single reference to your array. 

// And finally similar to the last solution you can see solution 3 is a little bit noisy. 
// So overall, I would go for either solution 2 or solution 1.




// --------------------------------------------------
// 6.8 Arrays - Combining Arrays

// all right now let's see HOW WE CAN COMBINE TWO ARRAYS OR SLICE AN ARRAY INTO TWO PARTS 

// so let's start by declaring two arrays here's the first one we put 1 2 & 3 here 
// and here's the second one I'm gonna add 4 5 & 6 to combine these two arrays 

// WE USE THE CONCAT METHOD 
// so first.concat
// THIS WILL BASICALLY CONCATENATE THE FIRST ARRAY WITH THE SECOND 

// now BOTH ARRAYS ARE UNAFFECTED SO THIS WILL RETURN A NEW ARRAY 
// WHICH IS THE COMBINATION OF THE FIRST AND SECOND ARRAYS 

// so let's store the result in combined 
// and log it on the console combined 
// save the changes so we get 1 2 3 4 5 6 
// pretty easy 

const first = [1, 2, 3];
const second = [4, 5, 6];

const combined = first.concat(second);
console.log(combined);
// output:
// [ 1, 2, 3, 4, 5, 6 ]

// now we have another method that is THE OPPOSITE OF CONCAT THAT IS SLICE 
// AND WE USE THAT TO SLICE AN ARRAY INTO TWO PARTS 
// so let's get the combined array and slice it

combined.slice();

// now there are multiple ways to use this method 

// one way is to pass a zero base index for the start and end 
// so we can start at 2 and finish at 4 
// let's see what we get so let's call that slice and log it on the console

const slice = combined.slice(2, 4);
console.log(slice);
// output:
// [ 3, 4 ]

// so this is what we get
// we went to the combine array 
// started after index 2 so here 
// and finish after index 4 
// so we extracted 3 and 4

// now let me show you ANOTHER WAY TO USE THE SLICE METHOD
// WE CAN EXCLUDE THE END INDEX 
// AND WITH THIS WE GET ALL THE ELEMENTS IN THE ORIGINAL ARRAY 
// STARTING FROM THE GIVEN INDEX so that's the second way

const slice = combined.slice(2);
console.log(slice);
// output:
// [ 3, 4, 5, 6 ]

// and finally the THIRD WAY IS TO EXCLUDE THE STARTING INDEX 
// AND WITH THIS WE GET A COPY OF THE ORIGINAL ARRAY 

const slice = combined.slice();
console.log(slice);
// output:
// [ 1, 2, 3, 4, 5, 6 ]

// so to recap 
// IF YOU WANT TO COMBINE TWO ARRAYS USE THE CONCAT METHOD 
// IF YOU WANT TO SLICE AN ARRAY USE THE SLICE METHOD 

// now one thing you need to understand about both these methods 
// is that IF YOU'RE DEALING WITH PRIMITIVE VALUES 
// THESE PRIMITIVES WILL BE COPIED INTO THE TARGET ARRAY 

// BUT IF YOU HAVE OBJECTS IN YOUR ARRAY THE OBJECTS THEMSELVES ARE NOT COPIED 
// THE REFERENCES ARE COPIED 

// AND THAT MEANS THE ELEMENTS IN BOTH THE INPUT AND OUTPUT ARRAYS 
// WILL POINT TO THE SAME OBJECT 

// let me show you what I mean 

// so for simplicity I'm gonna remove these three numbers here 
// and add an object so an object with ID set to 1

const first = [{ id: 1 }]; // reference type
const second = [4, 5, 6];

// so now WE HAVE A REFERENCE TYPE RIGHT WHEN WE CALL THE CONCAT METHOD 
// THIS OBJECT ITSELF IS NOT COPIED TO THE COMBINED ARRAY ONLY ITS REFERENCE IS COPIED 

// and this means if I go to the first array get the first element 
// which is our object and change its ID to let's say 10 

first[0].id = 10;

// now when we save the changes you can see in the combined array 
// here's the first element that's our object NOTE THAT IT'S ID IS CHANGED
// TO 10 AS WELL 


const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = first.concat(second);

first[0].id = 10;

const slice = combined.slice();

console.log(combined);
console.log(slice);
// output:
// [ { id: 10 }, 4, 5, 6 ]
// [ { id: 10 }, 4, 5, 6 ]

// sO BECAUSE WE'RE DEALING WITH A REFERENCE TYPE THIS OBJECT IS COPIED 
// BY ITS REFERENCE 
// THE SAME PRINCIPLE APPLIES TO THE SLICE METHOD 
// SO AS PART OF SLICING THIS ARRAY IF THE ELEMENTS ARE PRIMITIVE THEY'RE COPIED BY VALUE 
// IF THEY'RE REFERENCE TYPES THEY'RE COPIED BY THEIR REFERENCE




// --------------------------------------------------
// 6.9 Arrays - The Spread Operator

// So in the last lecture, 
// you learned how to use the concat method to combine two arrays.

// Now, there is another way to achieve the same thing using the spread operator in ES6. 

// So I'm going to rewrite this code using the spread operator, 
// and you will see why this approach is cleaner and more flexible. 

// So, I'm going to define combined as a new array, 
// now we want to COMBINE ALL THE ELEMENTS OF THE FIRST ARRAY AND SECOND ARRAY.
// So we USE THE SPREAD OPERATOR like this.

const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = [...first, ...second];

// WHEN WE SPREAD AN ARRAY, ALL IT'S ELEMENTS ARE RETURNED INDIVIDUALLY.
// SO BASICALLY WE'RE DECLARING A NEW ARRAY, AND IN THAT ARRAY, 
// WE'RE ADDING THE INDIVIDUAL ELEMENTS OF THE FIRST AND SECOND ARRAYS. 

// So this piece of code here is exactly like this. 
// [1, 2, 3, 4, 5, 6]

// Okay? So, we can see with the spread operator, 
// we have a better visualization of how these arrays are combined. 

// It's very clear that we have an array and in this array 
// we have all the elements of the first array, followed by all the elements of the second array. 

// Now with this spread operator, we have more flexibility, 
// let's say as part of combining these two arrays, 
// we want to add an element in between them, you can do that easily like this. 
// Or we can add something at the end.

const combined = [...first, 'a', ...second, 'b'];

// Again we can clearly see what the combined array looks like.

// In contrast, if you want to do the same thing using the concat method, 
// our code is going to be more complex.

// So this is how we can use the spread operator to combine two arrays.

// Now in the last lecture, you learned that if you call the slice method 
// without any arguments, this will return a copy of the original array, here.

// So let's call that copy, now once again we can use the spread operator 
// to copy all the elements of an array into a new array.
// So we can rewrite this code like this.

const copy = [...combined];

// Constant, copy, we create a new array, and then spread the combined array.
// So this will return all the elements of the combined array, 
// and put them into this new array.

// ALL CODE 
const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = [...first, 'a', ...second, 'b'];

const copy = [...combined];

console.log(combined);
console.log(copy);
// output:
// [ { id: 1 }, 'a', 4, 5, 6, 'b' ]
// [ { id: 1 }, 'a', 4, 5, 6, 'b' ]




// --------------------------------------------------
// 6.10 Arrays - Iterating an Array

// So earlier in the section about control flow, 
// you learned about various loops in JavaScript. 

// So in that section, you learned that 
// IF YOU WANT TO ITERATE AN ARRAY YOU CAN USE THE FOR OF LOOP. 

// So for, let, number of numbers, 
// now in each iteration this number will be set to one of the elements in this array.
// So, let's log that on the console.
// We get 1, 2, and 3. 

const numbers = [1, 2, 3];

for (let number of numbers)
    console.log(number);
// output:
// 1
// 2
// 3

// There is also ANOTHER WAY TO ITERATE AN ARRAY, 
// and you may see that approach in some tutorials online. 

// That is USING THE FOR EACH METHOD. 

// So all tHESE ARRAYS HAVE THIS FOR EACH METHOD. 
// THAT TAKES A CALL BACK FUNCTION. 
// SO WE PASS A FUNCTION HERE, THIS FUNCTION TAKES A PARAMETER, IN THIS CASE NUMBER, 
// and in this function we can simply log this number on the console.

// SO WHEN WE CALL THE FOR EACH METHOD, 
// THIS FUNCTION WILL BE EXECUTED FOR EACH ELEMENT IN THE ARRAY. 

// EACH ELEMENT WILL BE PASSED AS AN ARGUMENT TO THIS FUNCTION.
// So, save the changes, again we get 1, 2, 3. 

numbers.forEach(function (number) {
    console.log(number);
});
// output:
// 1
// 2
// 3

// Now as I told you before, WE CAN USE THE ARROW FUNCTION SYNTAX TO SIMPLIFY THIS CODE,
// so we get rid of the function keyword,
// put a fat arrow between the parameters and the body of the function,
// and because we have a single parameter, we can remove the parenthesis,
// and finally we need to remove this semi colon here because we don't have this
// statement in a code block. So here's the end result. 

numbers.forEach(number => console.log(number));
// output:
// 1
// 2
// 3

// Now which approach you choose is more of a personal preference, 
// THERE IS REALLY NO SIGNIFICANT DIFFERENCE BETWEEN THESE TWO WAYS OF ITERATING AN ARRAY. 

// The only thing you need to know is that THIS CALL BACK FUNCTION, 
// THAT WE PASS THROUGH THE FOR EACH METHOD, 
// CAN OPTIONALLY TAKE A SEPARATE PARAMETER AND THAT'S THE INDEX. 

// So here, I'm going to put number in parenthesis to add the second parameter, 
// that's index, now when logging each number, or each element, 
// we can also display it's index. Save the changes,
// and you can see the index of each element in front of it. 

numbers.forEach((number, index) => console.log(index, number));
// output
// 0 1
// 1 2
// 2 3

// We don't get the index with the for of loop, 
// but if you need that we can use the for in loop. 

// Again, its really a tiny issue, 
// just be aware that we have different ways to iterate an array.




// --------------------------------------------------
// 6.11 Arrays - Joining an Array

// Another useful method of arrays is join. 

// So here we have this numbers array 
// let's say we want to join the elements in this array. 
// That's when we use the join method. 
// So we call 

numbers.join()

// now look at this parameter here, separator? 
// Note the question mark. 
// WHENEVER YOU SEE A QUESTION MARK, THAT MEANS THIS PARAMETER IS OPTIONAL, 
// and you can see this type of parameter is a string 
// so here WE CAN OPTIONALLY PASS A STRING AND THIS STRING WILL BE USED AS A SEPARATOR. 

// So let's say we want to join these elements using a comma. 
// So we pass comma as a string here, right? 
// And note that THIS JOIN METHOD RETURNS A STRING. 
// So, we get the result and store it in a constant called joined. 
// Now, let's log it on the console, Save the changes, here's the result.

const numbers = [1, 2, 3];
const joined = numbers.join(',');
console.log(joined);
// output:
// 1,2,3

// ANOTHER USEFUL METHOD THAT GOES HAND AND HAND WITH JOIN IS THE
// SPLIT METHOD, BUT THIS METHOD IS NOT PART OF ARRAYS, IT'S PART OF STRINGS, 
// but let me show you how it works. 

// So lets say we have a string called message like this.
// This is my first message.
// Now we can split the sentence like this. So 

message.split()

// again here we need to pass the separator string 
// so let's say we want to separate this using a white space. 

// NOW THIS SPLIT METHOD WILL RETURN AN ARRAY, 
// so let's call that parts now let's take a look at that array on the console,

const message = 'This is my first message';
const parts = message.split(' ');
console.log(parts);
// output:
// [ 'This', 'is', 'my', 'first', 'message' ]

// okay, so, here's the array, we have five elements here, 
// note that each element in this array is a word in our original message. 

// Now that we have an array we can use the join method, 
// to combine these elements using a separator. So, let's say 

parts.join()

// you can combine them using a hyphen, and store the result in combined and finally
// log it on the console. So here's the result. This is my first message. 

const combined = parts.join('-');
console.log(combined);
// output:
// This-is-my-first-message

// This technique is particularly useful when building a URL slug. 
// Let me show you what I mean by that.

// So, here I've got this page open on stack overflow.com. 
// https://stackoverflow.com/questions/9543518/creating-arrays-in-javascript
// Read the title of this question, "Creating arrays in JavaScript". 
// So here is what the user posted as you can see we have white space in between each word, 
// but we cannot have a white space in url's so if you look at this url here,
// note the title of question, converted to a url slug. 
// So all the white spaces are replaced with a hyphen. 
// So as part of converting the title of the question to a url slug, 
// you'll have to split this string perhaps throw out some of the words, 
// replace some of the words with other words, 
// and then eventually combine them using the hyphen as you can see here.




// --------------------------------------------------
// 6.12 Arrays - Sorting Arrays

// Back to our numbers array, 
// in this lecture I'm going to change the order of these number so they are not sorted, 
// and then I will tell you how to sort them. So let's change them to 2, 3, 1, and remove 1
// now how can we sort this array? Very easy. 

// You have this METHOD CALLED SORT 
// and what this method does is that it CONVERTS EACH ELEMENT HERE TO A STRING 
// AND THEN SORTS THE ELEMENTS IN THE ARRAY. 

// So, let's have a look, so console.log of numbers,
// here's our numbers array sorted. 

const numbers = [2, 3, 1];
numbers.sort();
console.log(numbers);
// output:
// [ 1, 2, 3 ]

// Now another method that is often companion to the sort method is THE REVERSE METHOD.
// AND WITH THIS WE CAN REVERSE THE ORDER OR ELEMENTS IN AN ARRAY.
// So numbers.reverse
// let's log it on the console one more time, now we have 3, 2, 1. 

const numbers = [2, 3, 1];
numbers.reverse();
console.log(numbers);
// output:
// [ 3, 2, 1 ]

// So this sort method is pretty useful. 
// It's very easy to use when you have numbers and strings in an array. 

// But when you have objects like course OBJECTS, 
// IT DOESN'T WORK BY DEFAULT, YOU HAVE TO DO SOME EXTRA WORK. 

// So, let me delete this code here, and define another array. 
// Called courses, here I'm going to add two course objects
// with id 1 and name, let's say Node.js. And another course object with id2, and name JavaScript.

// Now let's say you want to sort this array by name of courses. 
// So JavaScript should come before node.js. 
// So look if I call courses.sort, and then log it on the console,
// nothing is going to happen. You can see Node is still coming first. 

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'JavaScript' },
]

courses.sort();
console.log(courses);
// output:
// [ { id: 1, name: 'Node.js' }, { id: 2, name: 'JavaScript' } ]


// So how can we fix this problem? Very easy. 
// THIS SORT METHOD OPTIONALLY TAKES AN ARGUMENT AND THAT'S A FUNCTION THAT IS USED FOR COMPARISON. 
// SO WHAT DO WE CALL THE SORT METHOD, THIS METHOD GETS TWO OBJECTS IN THIS ARRAY,
// LET'S SAY A AND B, AND COMPARES THEM. 

// NOW IF THEY ARE IN THE RIGHT ORDER, IT WILL SKIP TO THE NEXT FEW ELEMENTS, 
// OTHERWISE IT'S GOING TO REARRANGE THEM. 

// So here we need to pass a function, for comparison, 
// this function should take two parameters, we can call them and a and b, or first and second, 
// doesn't really matter, because a and b is pretty self explanatory here.

courses.sort(function (a, b) {
});

// Now, in this function, if a is less than b, we should return minus 1, 
// if a is greater than b, we should return 1, and if they are equal, we should return 0. 

// So to implement this, you can write code like this. 
// If a.name, that's our first course is less than b.name we're going to return -1, okay?
// Now, the second condition. If a.name is greater than b.name, we're going to return 1, 
// otherwise we return 0. 

// Now, note that here I'M NOT USING ELSE IF, BECAUSE IF THE FIRST CONDITION IS TRUE, 
// THIS THIS RETURN STATEMENT WE'RE GOING TO JUMP OUT OF THIS FUNCTION. 

// So the control will never move to this point. 
// So there is really no need to use the else keyword. 
// It's just adding extra noise in the code. 
// So now, lets run this code one more time, save the changes, 
// inspect this array, we can see that JavaScript is coming first. 
// Beautiful.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'JavaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    if (a.name < b.name) return -1;
    if (a.name > b.name) return 1;
    return 0;
});

console.log(courses);
// [ { id: 2, name: 'JavaScript' }, { id: 1, name: 'Node.js' } ]

// However, if I change this j to a lower case j, and save the changes, see what happens.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'javaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    if (a.name < b.name) return -1;
    if (a.name > b.name) return 1;
    return 0;
});

console.log(courses);
// output:
// [ { id: 1, name: 'Node.js' }, { id: 2, name: 'javaScript' } ]

// This time Node is coming first, so what's going on here? 

// Well, each character in a computer is internally represented using a number. 
// Let me show you. So open up Google and search for ascii table. 
// That is asc with double i.
// ascii is short for American standard code for information interchange. 

// Now, take a look at the second link, so on this table, 
// you can see the numeric representation of each character. 

// So, we are looking at lower case j, it's numeric representation is 106, 
// and n which is used for our node course is 78. 
// We can see 78 is less than 106, that's why our Node course starting with capitol N came first. 
// Now to solve. this problem we should exclude case sensitivity when comparing these names.

// So, we can do something like this, you can declare two constants, 
// let's say nameA, and set it to A.name.toUpperCase. 

// So whatever the name of the first course is, we're going to convert it to uppercase, 
// and we're going to do the same with the second course. 
// Is I'm going to call the second constant, nameE, and set it to b.name.toUpperCase. 

const nameA = a.name.toUpperCase();
const nameB = b.name.toUpperCase();

// Now we have toUpperCase keys, we can compare them. 
// Also, take into account that here we could call two lowercase instead of two uppercase. 
// That's perfectly valid, but what is important is that both these names should be either
// lower case or uppercase.

// Now finally we need to replace the instances of a.name, with name a.

// So I'm going to do multi cursor editing. 
// I've selected a.name, and I'm going to press command and d on Mac, or control d on Windows. 
// We have this second cursor here, as you can see, 
// Now we can delete this and replace it with nameA. Escape, Finished. 
// One more time I'm going to replace b.name command and d, with name e, and escape. 
// Now save the changes now our sort algorithm should work properly.

// So JavaScript came first.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'javaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    const nameA = a.name.toLowerCase();
    const nameB = b.name.toLowerCase();

    if (nameA < nameB) return -1;
    if (nameA > nameB) return 1;
    return 0;
});

console.log(courses);
// output:
// [ { id: 2, name: 'javaScript' }, { id: 1, name: 'Node.js' } ]




// --------------------------------------------------
// 6.13 Arrays - Testing the Elements of an Array

// We have two new methods in modern JavaScript called EVERY AND SOME.

// Very useful methods, so here we have our numbers array,
// let's imagine WE WANT TO CHECK AND SEE IF ALL NUMBERS IN THIS ARRAY
// ARE POSITIVE.

// So, we call NUMBERS.EVERY AND here we PASS A CALLBACK FUNCTION. 

// Here in the intellisense, you can see this callback function has THREE PARAMETERS. 
// VALUE, WHICH IS A NUMBER, BECAUSE HERE WE HAVE AN ARRAY OF NUMBERS. 
// INDEX, WHICH IS THE INDEX OF THIS VALUE AND THE ARRAY, AND AGAIN, THAT'S A NUMBER,
// AND FINALLY THE ARRAY ITSELF. 

// Now when writing this function you don't have to add all these parameters, 
// you can only add ones you need, 
// for example, here I'm going to add the function and I'm only going to add one parameter, 
// value, because I don't care about the index, of these elements,

const numbers = [1, 2, 3];

numbers.every(function (value) {

});


// so, we pass this callback function, and in this function we can check to see if this
// value is a positive number. So, we return value, greater than or equal to zero. 
// If this expression evalues to true, we'll return true, otherwise we'll return false.

numbers.every(function (value) {
    return value >= 0;
});

// Now finally, this method will return a boolean, so we can store it in the constant called 
// allPositive. 

// SO WHEN WE CALL THIS METHOD, this is what's going to happen 
// THIS METHOD WILL RUN THIS FUNCTION ON EVERY ELEMENT IN THIS ARRAY, 
// AS SOON AS IT FINDS AN ELEMENT THAT DOESN'T MATCH THIS CRITERIA, 
// IT'S GOING TO STOP SEARCHING.

// Let me show you. So, let's log allPositive on the console. 
// You can see it's true on the console, because every element, 
// or every number in this array is a positive number.

const numbers = [1, 2, 3];

const allPositive = numbers.every(function (value) {
    return value >= 0;
});

console.log(allPositive);
// output:
// true


// However, if I add -1 here, we get false, 
// and basically as soon as we hit this number, the search will terminate

// so if you have a million other numbers in this array, 
// this every method is not going to call this callback function on those numbers.

const numbers = [1, -1, 2, 3];

const allPositive = numbers.every(function (value) {
    return value >= 0;
});

console.log(allPositive);
// output:
// false

// Now we have a similar METHOD CALLED SOME, and that CHECKS TO SEE IF WE HAVE 
// AT LEAST ONE ELEMENT IN THIS ARRAY THAT MATCHES THIS CRITERIA.

numbers.some

// So if I replace every with some, and save the changes, we're going to see true.
// However, I'm going to change the name of this variable, because this is distracting
// so always pay great attention to the name of your variables and functions, 
// make sure they're explaining the right thing. 

// So press F2, and rename this to atLeastOnePositive. 
// Okay? Save the changes, we get true

const numbers = [1, -1, 2, 3];

const atLeastOnePositive = numbers.some(function (value) {
    return value >= 0;
});

console.log(atLeastOnePositive);
// output:
// true

// so this SOME METHOD WILL RUN THIS CALLBACK FUNCTION ON EVERY ELEMENT IN THIS ARRAY. 
// AS SOON AS IT FINDS AN ELEMENT THAT MATCHES THIS CRITERIA, 
// IT'S GOING TO RETURN TRUE AND THE SEARCH WILL TERMINATE. 
// So, in the current example if we have a million numbers in this array, 
// because the first number matches this criteria, 
// this call back function will be executed only on this first element. 
// So it doesn't matter what we have after the first element. 

// So, to recap,
// EVERY CHECKS TO SEE IF EVERY ELEMENT IN A GIVEN ARRAY MATCHES THE GIVEN CRITERIA, 
// and SOME CHECKS TO SEE IF WE HAVE AT LEAST ONE ELEMENT THAT MATCHES THE GIVEN CRITERIA. 

// Just to let you know, these methods are new in JavaScript, 
// so some older browsers do not support this, but later in the course I'm going to explain
// how to bring these methods in older browsers.




// --------------------------------------------------
// 6.14 Arrays - Filtering an Array

// In this lecture,
// I'm going to show you how to FILTER AN ARRAY BASED ON A SEARCH CRITERIA.

// So back to our numbers array, 
// let's say you want to return only the positive numbers.

// So, we can use the filter method, like this.

numbers.filter();

// Once AGAIN WE NEED TO PASS A CALLBACK FUNCTION, 
// this function has three parameters, value index and array.

// So out of these we only care about value, 
// we don't care about the index
// because I just want to see if the number of the value is positive.

numbers.filter(function (value) {

});

// So function value, now here we can write a simple expression like this,
// if value is greater than or equal to 0.

// So WHEN WE CALL THE FILTER METHOD, THIS METHOD WILL LOOP THROUGH THIS ARRAY, 
// AND EXECUTE THIS CALLBACK FUNCTION FOR EACH NUMBER, FOR EACH ELEMENT.

numbers.filter(function (value) {
    return value >= 0;
});

// Now IF THE ELEMENT MATCHES THIS CRITERIA,
// IT WILL ADD THIS ELEMENT TO A NEW ARRAY, 
// and finally we can get the new array here. So filtered. 
// Let's take a look at the result, filtered,
// so in our filtered array, we only have 1, 2, and 3.

const numbers = [1, -1, 2, 3];

const filtered = numbers.filter(function (value) {
    return value >= 0;
});

console.log(filtered);
// output:
// [ 1, 2, 3 ]

// Now earlier you learned about arrow functions, 
// so THIS IS A GOOD CASE WHERE YOU WOULD USE AN ARROW FUNCTION.
// You have a single line of code, in this function, and we're simply returning a value. 
// So, we get rid of the function keyword, put a fat arrow between the parameter and the body of this function.

// We don't need the parenthesis because we have a single parameter, and because we're simply
// returning a value, we can also exclude the return keyword, as well as the curly braces and then
// put everything on the same line like this.

const filtered = numbers.filter(value => value >= 0);

// Now we can make this code a little bit shorter, 
// so in this case we can use an abbreviation like v for value, or n for number. 
// Because it's obvious that we're working with the numbers array.

// So we filter and we get numbers where number is greater than or equal to zero.

const filtered = numbers.filter(n => n >= 0);

// Now here we're dealing with an array of numbers, in a real world application, 
// you will be using an array of objects.

// For example, here on the yelp website, you can click this button to 
// find only the restaurants that are open now.

// So this is one kind of filtering. 

// So if you want to implement something like this, 
// instead of an array of numbers you would have an array of restaurants, 
// and each restaurants has opening hours so you could filter restaurants that are currently open
// and return them.




// --------------------------------------------------
// 6.15 Arrays - Mapping an Array

// Another very useful and powerful method we have in JavaScript is THE MAP METHOD. 
// With this method WE CAN MAP EACH ITEM IN THE ARRAY TO SOMETHING ELSE. 

// So following from the example in the last lecture, we have an array of positive numbers 
// let's say we want to construct some HTML markup, using the elements in this array. 

// So we call 

filtered.map();

// and once again we need to pass a callback function here. 

// This function just like the function that we passed to the filter method 
// CAN HAVE THREE PARAMETERS. VALUE, INDEX, AND ARRAY.

// So in this case, again, we're going to work only with the value 
// so we can pass a function or an arrow function. 
// So we get a number some html markup. 
// So we can add a string, with an opening list item element.
// Then we add the number, then finally the closing list item element. 

filtered.map(n => '<li>' + n + '</li>');

// So with this markup, we can display each number using a bullet point. 
// Of course we need to put these inside of a ul element, 
// and I'm going to show you that in a second. 

// So, let's see the result of the map method. I'm going to store the
// result in a constant called items, and now, let's display this on the console. 

const numbers = [1, -1, 2, 3]
const filtered = numbers.filter(n => n >= 0);

const items = filtered.map(n => '<li>' + n + '</li>');

console.log(items);
// output:
// [ '<li>1</li>', '<li>2</li>', '<li>3</li>' ]

// So, you can see each number is now mapped to a string, that's our list item. 

// So now we have an array of strings, we can use the join method that you 
// learned about earlier to join the elements of this array and create a string. 

// So, constant, html, we set it to items.join and then, display this on the console. 

const html = items.join();
console.log(html);
// output:
// <li>1</li>,<li>2</li>,<li>3</li>

// Now instead of an array we have a string. 
// Notice that by default comma is used as the separator, 
// we don't want to have comma in our html markup, 
// we just want to combine these using an empty character like this. 
// Save the changes, now comma is gone, 

const html = items.join('');
console.log(html);
// output:
// <li>1</li><li>2</li><li>3</li>


// the only bit that is remaining is the ul element. 
// So the very simple implementation would be like this, 
// you add ul then concatenate it with all these items and finally another ul.
// Save the changes, and here's our html markup to display all these numbers using bullet points.

const html = '<ul>' + items.join('') + '</ul>';
console.log(html);
// output:
// <ul><li>1</li><li>2</li><li>3</li></ul>

// Now later in the course I will show you a more elegant way to implement
// the same thing

// all I want you to take away from this lecture is that 
// WE CAN USE THE MAP METHOD TO MAP EACH ELEMENT IN AN ARRAY INTO SOMETHING ELSE. 

// Now in this example, you are mapping these numbers to strings, 
// but YOU CAN ALSO MAP THEM TO OBJECTS, let me show you another example.

// So I'm going to delete this html, let's expand this a little bit more,

// instead of mapping a number to a string, let's say you want to map them
// to an object. 

// So here I'm going to define an object in this object 
// we want to have a value property and set that to this number. 
// And finally you want to return this object. Let's look at the result.

const numbers = [1, -1, 2, 3]
const filtered = numbers.filter(n => n >= 0);

const items = filtered.map(n => {
    const obj = { value: n };
    return obj;
});

console.log(items);
[{ value: 1 }, { value: 2 }, { value: 3 }]


// So, let's display the items constant. 
// Now here's the result of our map. 
// We've MAPPED EACH NUMBER TO AN OBJECT WITH A VALUE PROPERTY. 
// Okay? So VERY USEFUL WHEN BUILDING REAL WORLD APPLICATIONS.

// Now let me show you something tricky here, in our callback function
// we are declaring this constant and then returning it. 

// Technically we don't need to declare this as a separate constant, 
// we can simply put the return keyword here and return this object.

// Because we are not working with that constant, with that object
// constant, okay? So, save the changes, you still get the same result

const items = filtered.map(n => {
    return { value: n };
});

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// Now earlier I told you that in your arrow function if you have a single line 
// of code and you're returning an value you can exclude the return keyword 
// as well as the curly braces. So let's do that and see what happens. 
// So remove the return key word, and the curly braces and put everything 
// on one line like this. 
// Now, if we save the changes, we don't get the same result.

const items = filtered.map(n => { value: n });

console.log(items);
// output:
// [ undefined, undefined, undefined ]

// We get an array of 3 undefined elements. 

// The reason for this is by default these curly braces in an arrow function, 
// represent a code block. 
// So when the JavaScript engine tries to parse this arrow function it
// tHINKS HERE WE ARE DEFINING A CODE BLOCK AS OPPOSED TO AN OBJECT TO RETURN. 

// SO IF YOU'RE RETURNING AN OBJECT YOU NEED TO PUT THAT OBJECT IN PARENTHESIS.
// Like this. So, we put this object in parenthesis. 
// And with this our JavaScript engine will not look at this as a code block. 
// Now save the changes, now once again you get 3 objects.

const items = filtered.map(n => ({ value: n }));

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// And one last thing before we finish this lecture.

// SO YOU HAVE NOTICED THAT BOTH THE FILTER AND THE MAP METHOD RETURN A NEW ARRAY, 
// THEY DON'T MODIFY THE ORIGINAL ARRAY, 
// THESE METHODS ARE CHAINABLE 
// WHICH MEANS WE CAN CALL THEM ONE AFTER ANOTHER IN A CHAIN

// so in this case, this filtered constant is only used here. 
// We haven't used this anywhere else in the code.

// So we don't have to explicitly store the result of this statement inside
// a separate constant. 

// We can get rid of this, we call the filter method, 
// now we don't want to have a semi colon here because we are not going to terminate 
// this statement. Instead we're going to immediately call the map method on the result
// that is returned from this statement. 

// So, I'm going to copy our map method here. 
// This is what we call chaining. 

const numbers = [1, -1, 2, 3]
//const filtered = numbers.filter(n => n >= 0);
numbers.filter(n => n >= 0).map(n => ({ value: n }))
//const items = filtered.map(n => ({ value: n }));

// So we're calling 1 method, that method returns some result, 
// now we're immediately calling the map method on that result.

// Now, WHEN CHAINING MULTIPLE METHODS, BY CONVENTION WE PUT EACH METHOD CALL 
// ON A SEPARATE LINE, AND THIS MAKES OUR CODE CLEANER. 

// Have a look. So, numbers.filter and then.map and so on. 

numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }));

// And finally we store the result in the items. 
// That's a better and cleaner code. Save the changes, we still get the same result.

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }));

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// Great, now note that here BECAUSE THE MAP METHOD IS RETUNING A NEW ARRAY, 
// AGAIN WE CAN CALL THE FILTER OR THE MAP METHOD ON THAT ARRAY. 

// So here we can call the filter one more time, we get an object, 
// and maybe we want to get objects with value greater than 1. 
// See what happens?
// Now in the result we have only 1 of 2 objects in our array, objects with value 2 and 3,

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }))
    .filter(obj => obj.value > 1);

console.log(items);
// output:
// [ { value: 2 }, { value: 3 } ]

// and again we can call the map method and maybe map each object to a number. 
// So to read the value property and return it, save the changes, 
// now we have an array of 2 numbers. 

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }))
    .filter(obj => obj.value > 1)
    .map(obj => obj.value);

console.log(items);
// output:
// [ 2, 3 ]

// So THIS IS THE POWER OF CHAINING THESE METHODS.




// --------------------------------------------------
// 6.16 Arrays - Reducing an Array

// Once again with our array of numbers, 
// let's say we want to CALCULATE THE SUM OF ALL THESE NUMBERS IN THIS ARRAY.

// This will be similar to calculating the total cost of all the items in a shopping cart.
// So each numbers here could represent the price of an item in a shopping cart,
// of course we wouldn't have a negative number there, but you get the point.

// So here's a very simple algorithm for calculating the sum of all the
// numbers in this array. 

const numbers = [1, -1, 2, 3];

// You start by declaring a variable called sum and we initialize it to 0. 

let sum = 0;

// Next we loop over the array, get each element for each number and add it to sum.
// Something like this.
// for let n of numbers, now we want to add n to sum.

for (let n of numbers) { }

// So we can write an expression like this.
// Sum = sum + n, 

for (let n of numbers)
    sum = sum + n;

// or a better way is to use the addition assignment operator.
// So we can exclude the second sum, so this is exactly like the statement we had before,

for (let n of numbers)
    sum += n;

// and finally we display sum on the console.

const numbers = [1, -1, 2, 3];

let sum = 0;

for (let n of numbers)
    sum += n;

console.log(sum);
// output:
// 5

// So, we get 5. 

// Now THERE IS A CLEANER AND MORE ELEGANT WAY TO WRITE THE SAME CODE 
// USING THE REDUCE METHOD IN ARRAYS.

// So ALL THESE ARRAYS HAVE THIS REDUCE METHOD, 

numbers.reduce();

// and WITH THIS METHOD WE CAN 
// REDUCE ALL THESE ELEMENTS IN AN ARRAY INTO A SINGLE VALUE.

// That single value can be a number, it can be a string, it can be an object, 
// it can be anything.

// In this example, we want to reduce all these elements into a single
// number, that is the sum of all the numbers in this array.

// So let's see how we can use the reduce method. 

// THIS METHOD TAKES A CALLBACK FUNCTION WITH TWO PARAMETERS,
// ACCUMULATOR AND CURRENT VALUE.

// So here I'm using an arrow function. Like this.

numbers.reduce((accumulator, currentValue) => {

});

// This accumulator parameter here is exactly like this sum we have here (let sum = 0).

// It's something that we initialize and this callback function ((accumulator, currentValue) => ) 
// is executed multiple times,
// each time this currentValue will be set to one element in this array (cost numbers).

// So in each call, we want to get this current value and add it to accumulator.
// So we simply return the sum of accumulator plus currentValue.

numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
});

// Now INTERNALLY, THIS REDUCE METHOD WILL GET THIS RESULT (THE RETURN STATEMENT)
// AND STORE IT IN THE ACCUMULATOR, YOU WILL SEE THAT IN A SECOND. 

// And one last thing here, is to initialize this accumulator to 0. 
// So, as the second argument to the reduce method, we pass 0. 

numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Note that THIS REDUCE METHOD HAS TWO ARGUMENTS, THE FIRST ARGUMENT IS A CALLBACK FUNCTION, 
// AND THE SECOND ARGUMENT IS THE INITIAL VALUE FOR THE ACCUMULATOR.

// Finally we get the result as a single value. In this case, sum. 

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Now we don't need this code anymore and finally let's bring this console.log here. 
// Save the changes, you can see we get the same result 5, 

const numbers = [1, -1, 2, 3];

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

console.log(sum);
// output:
// 5

// but let's see what exactly is happening here.

// So, initially we set accumulator to 0, so I'm going to set a=0. 
// In the first round, current value will be set to the first number. So, c = 1. 

// a = 0, cV = 1 ==> a = 1
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Now we add these together, so we get 1 and a will be set to 1 
// after this callback function is executed. (return accumulator + currentValue;)
// So, as a result a will be 1. 

// Now in a second round, a is 1, 
// current value will be set to the second number in this array. So, minus 1. 
// Now once again we add them together, 
// now a will be 0 after the second call.

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// Now the third call so a is 0, 
// the current value is going to be set to the third element in this array.
// So 2 and as a result a will be 2, 

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// and finally in the last call, we start with a set to 2,
// and current value will be 3. 
// So, the (a) result will be 5, and that's why we saw 5 on the console.

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
// a = 2, cV = 3 ==> a = 5
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// SO ESSENTIALLY WITH THIS REDUCE METHOD, 
// WE START WITH AN ACCUMULATOR, 
// THEN WE LOOP THROUGH THIS ARRAY, 
/// AND CONVERT ALL THESE ELEMENTS INTO A SINGLE VALUE, 
// WHICH IS IN THIS CASE ACCUMULATOR, OR THE SUM OF ALL THE NUMBERS IN THIS ARRAY.

// Now we can make this code even shorter.
// We can exclude the initialization of the accumulator, and with this, 
// accumulator will be set to the first element. 

// So let me show you what will happen. 

// A will initially be set to 1. 
// And current value will be set to - 1. 
// That is exactly like our second call here. 
// Right ? So as a result, a will be set to 0,

// now in our second round a will be 0,
// and current value will be 2, because in the previous call, 
// current value was here, so now we are here.
// So current value will be 2, and as a result a will be 2, 
// and finally, in the last call, a will be 2, 
// and current value will be 3. 
// The last element in this array and once again we get 5. 

// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
// a = 2, cV = 3 ==> a = 5
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
});

// So if we supply an initial value (0) we'll have one more call, 
// if we don't the first element in this array will be used as the initial value.

// So this is how the reduce method works.

// And finally, to make this code a little bit shorter, 
// we can get rid of this return keyword, because we have a single line, 
// but we are simply reducing a value. 
// So, remove the return, the semi colon and the curly braces
// put everything on a single line, like this.

const sum = numbers.reduce(
    (accumulator, currentValue) => accumulator + currentValue
);

// So with this single line of code, 
// we reduce the numbers array 
// and this is how our reduction algorithm works.
// We simply get the current value and add it to our accumulator.

// This is far cleaner and more elegant 
// than declaring a sum and then looping over this array 
// like let n of numbers and then add n to the sum, 
// that's a very old way of writing code.

let sum = 0;
for (let n of numbers) {
    sum += n;
}




// --------------------------------------------------
// 7.1 Functions - Function Declarations vs Expressions 


// So you have learned a little bit about functions in JavaScript, 
// in this section we're going to examine functions in more detail. 

// So I'm going to start defining a function called walk and here we do a console.log of walk. 

function walk() {
    console.log('walk');
}

// What we have here is what we refer to as a FUNCTION DECLARATION.

// But in JavaScript THERE IS ANOTHER WAY TO DEFINE A FUNCTION, 
// AND THAT IS USING A FUNCTION EXPRESSION. 

// So we START BY DECLARING A VARIABLE OR A CONSTANT 
// GIVE IT A NAME like run and THEN WE SET THAT TO A FUNCTION. 

let run = function () { }

// So just like we can set a variable to a number, or a string, or an object, 
// WE CAN ALSO SET IT TO A FUNCTION. 

// And you know that in JavaScript functions are objects. 

// So SETTING THE VARIABLE TO A FUNCTION IS SIMILAR TO SETTING IT TO AN OBJECT, okay? 

// And at the end here we need to add a semi colon, 
// because when ever we declare a variable or a constant, 
// we terminate this statement, with a semi colon. 

// So here's another example. We set x to 1, and terminate it with a semi colon. 

let run = function () { }; // terminate it with a semi colon (because its a variable)
let x = 1;

// In contrast, we don't put the semi colon when we define a function 
// using the function declaration syntax,
// it doesn't really matter, so if you run this code you're not going to get any errors, 
// but by convention, we don't do this. 

function walk() {
    console.log('walk');
} // no semi colon here

// So that's one difference between function declarations and function expressions. 

// Now, let's do a console.log, of run here. 
// So basically HERE WE HAVE DEFINED A FUNCTION, AND THIS FUNCTION DOES NOT HAVE A NAME. 
// Its SYNTAX IS VERY SIMILAR TO WHAT WE HAVE IN A FUNCTION DECLARATION,
// except that here we don't have a name, 

let run = function () {
    console.log('run');
};

// WE CAN GIVE IT A NAME and then we would REFER TO THIS AS A NAMED FUNCTION EXPRESSION.

let run = function walk() {
    console.log('run');
};

// Or we CAN EXCLUDE THE NAME and with this we have AN ANONYMOUS FUNCTION EXPRESSION. 
// So WE HAVE DEFINED AN ANONYMOUS FUNCTION THAT DOESN'T HAVE A NAME, 
// AND SET A VARIABLE (run) (a variable) TO REFERENCE THAT FUNCTION.

// So now WE CAN CALL THAT ANONYMOUS FUNCTION USING THIS REFERENCE.
// Just like how we call a function in JavaScript.
// So, save the changes, and we get the run message on the console. 

let run = function () {
    console.log('run');
};
run(); // this is calling the function BY REFERENCE NOT BY NAME 


// Now we can declare another variable, call it move, and set it to run. 

let run = function () {
    console.log('run');
};
let move = run;
run();

// So now both (move) and (run) ARE REFERENCING THE SAME ANONYMOUS FUNCTION, 
// WHICH IS ONE OBJECT IN MEMORY.

// So WE CAN CALL THAT ANONYMOUS FUNCTION USING THIS OTHER REFERENCE (move). 
// So if we call move, we get the same result. 

let run = function () {
    console.log('run');
};
let move = run;
run();
move();

// So to recap, in JavaScript THERE ARE TWO WAYS TO DEFINE A FUNCTION, 
// we can use THE FUNCTION DECLARATION SYNTAX, 
// or FUNCTION EXPRESSION WHICH BASICALLY INVOLVES DECLARING A VARIABLE OR A CONSTANT
// AND THEN SETTING IT TO A FUNCTION. 

// In the next lecture, we'll look at the key difference 
// between a function declaration and a function expression.




// --------------------------------------------------
// 7.2 Functions - Hoisting

// Function Declaration
function walk() {
    console.log('walk');
}

// Function Expression
const run = function () {
    console.log('run');
};

// In the last lecture you learned about function declaration and expression. 
// Now the KEY DIFFERENCE between these two functions, is WE CAN CALL THIS FUNCTION
// THE ONE THAT IS DEFINED USING THE FUNCTION DECLARATION SYNTAX, BEFORE IT IS DEFINED.

// So here, we can call walk, save the changes, and we get this message on the console. 

walk();
// Function Declaration
function walk() {
    console.log('walk');
}

// Function Expression
const run = function () {
    console.log('run');
};
// output:
// walk

// But WE CANNOT DO THIS WITHOUT A FUNCTION THAT IS DEFINED USING THE FUNCTION EXPRESSION SYNTAX. 

// So here, if I call run before it is initialized I get this error. 
// Uncaught reference error. Run is not defined. 

walk();
// Function Declaration
function walk() {
    console.log('walk');
}

run();
// Function Expression
const run = function () {
    console.log('run');
};

// output:
// walk
// ReferenceError: Cannot access 'run' before initialization

// THIS IS EXACTLY LIKE USING A VARIABLE OR A CONSTANT BEFORE IT IS DEFINED. 

// For example, here I'm going to define x, and set it to 1, 
// but I want to log it on the console, before it's declaration. 
// Look, we get the same error. 
// Reference error, x is not defined.

console.log(x);
let x = 1;
// output:
// ReferenceError: Cannot access 'x' before initialization

// So, WE CAN CALL A FUNCTION THAT IS DEFINED USING THE FUNCTION DECLARATION SYNTAX 
// BEFORE IT'S DEFINITION, but why is that? 

// The reason for this is because WHEN OUR JAVASCRIPT ENGINE EXECUTES THIS CODE, 
// IT MOVES ALL THE FUNCTION DECLARATIONS TO THE TOP, 
// SO OUR CODE WILL LOOK LIKE THIS AT RUN TIME. 

// THIS IS WHAT WE CALL HOISTING. 

// So if you are at a job interview and someone asks you "what is hoisting in JavaScript?"
// HOISTING IS THE PROCESS OF MOVING FUNCTION DECLARATIONS TO THE TOP OF THE FILE. 

// And this is done automatically by the JavaScript engine that is executing this code. 
// SO THAT'S THE REASON WE CAN CALL FUNCTIONS THAT ARE DEFINED USING THE FUNCTION DECLARATION SYNTAX
// BEFORE THEIR DEFINITION.




// --------------------------------------------------
// 7.2 Functions - Arguments

// Earlier in the course, you learned that JavaScript is a dynamic language, 
// so we can declare a variable, set it to a number, 
// and then change it's type and set it to a string, 
// and that's perfectly fine from the perspective of a JavaScript engine. 

let x = 1;
x = 'a';

// This is one of the characteristics of a dynamic language. 

// But WE HAVE THE SAME CONCEPT IN THE ARGUMENTS OF A FUNCTION. 

// So I'm going to define a function here call it sum, that has two parameters,
// a and b. And here we simply return the sum of a and b. 
// Now, let's do a console.log, 
// and call the sum function, pass 1 and 2.
// Save the changes, so we get 3.

function sum(a, b) {
    return a + b;
}

console.log(sum(1, 2))
// output:
// 3

// But in JavaScript, it doesn't matter that this function has 2 parameters, 
// we can pass only 1 argument. 
// So in this case we get Not a Number. 
// Because here a is 1 and b BY DEFAULT IS UNDEFINED. 
// So when we have 1 plus undefined, the result is not a number, 
// this is not a valid arithmetic operation. 

function sum(a, b) {
    return a + b; // 1 + undefined
}

console.log(sum(1)); // only 1 of 2 arguments
// output:
// NaN

// The SAME HAPPENS IF WE DON'T PASS ANY ARGUMENTS. 
// So we don't get an error, we get not a number as a result.

function sum(a, b) {
    return a + b; // undefined + undefined
}

console.log(sum()); // no arguments
// output:
// NaN

// By the same token, WE CAN PASS ADDITIONAL ARGUMENTS. 
// So in this case we can pass let's say 5 arguments. 
// And that's perfectly valid JavaScript code. 
// So when you save this, we still get 3, because ONLY THE FIRST 2 ARGUMENTS ARE USED.

function sum(a, b) {
    return a + b;
}

console.log(sum(1, 2, 3, 4, 5)); // only the first 2 arguments are used
// output:
// 3

// But WHAT IF YOU WANT TO HAVE A VARYING NUMBER OF PARAMETERS IN A FUNCTION? 
// WHAT IF YOU WANT TO HAVE THE FLEXIBILITY TO PASS AS MANY ARGUMENTS AS WE WANT, 
// and get their sum. 

// Well, EVERY FUNCTION IN JAVASCRIPT HAS A SPECIAL OBJECT CALLED ARGUMENTS. 
// Let's log this on the console, 

function sum(a, b) {
    console.log(arguments);
    return a + b;
}

console.log(sum(1, 2, 3, 4, 5));

// output:
// [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
// 3

// so THIS IS THE Arguments OBJECT,
// you can see that it kind of looks like an array, 
// but it's not an array, it's an object. 

// But tHE KEYS WE HAVE IN THIS OBJECT ARE INDEXES OF THE ARGUMENTS PASSED TO THIS FUNCTION. 
// So, the first argument is 1, the second argument is 2, and so on. 

// Here we have a LENGTH PROPERTY that returns THE NUMBER OF ARGUMENTS THAT ARE PASSED, 

// length: 5

// we have this CALLEE PROPERTY which returns THE CURRENTLY EXECUTED FUNCTION, 
// so you see we have a reference to our sum function. 

// callee: f sum(a, b)

// So THIS IS THE Arguments OBJECT. 

// Now IF YOU WANT TO HAVE A FUNCTION WITH A VARYING NUMBER OF PARAMETERS TO WORK
// WITH ALL THE ARGUMENTS THAT ARE PASSED TO THIS FUNCTION. 

// So let's say we want to change this function to return the sum of all these arguments. 

// Here's a very simple algorithm. 

// So, we declare a variable called total, set it to 0, then we can use the for of loop. 
// So let value of arguments we can use this loop to iterate over this arguments object. 

function sum(a, b) {
    let total = 0
    for (let value of arguments);
}

console.log(sum(1, 2, 3, 4, 5));

// Now earlier, I told you that we can use THE FOR OF LOOP, on arrays, 
// but TECHNICALLY THIS LOOP CAN BE USED ON ANY OBJECT THAT HAS AN ITERATOR. 

// So THE PLAIN OBJECTS THAT WE CREATE WITH THE OBJECT LITERAL SYNTAX, 
// THEY DON'T HAVE AN ITERATOR, BUT THIS PARTICULAR OBJECT YOU CAN SEE HERE WE HAVE 
// Symbol.iterator THAT MEANS THIS OBJECT HAS AN ITERATOR 
// SO WE CAN USE THE FOR OF LOOP TO ITERATE THIS OBJECT. 

// Now for every argument we're going to get that and add it to our total variable. 
// And finally we will return total.
// Now save the changes, we get 15, 

function sum(a, b) {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5));
// output:
// 15

// we can add another argument, and we get 25. 

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// 25

// Now here's the interesting thing. 
// WE CAN COMPLETELY REMOVE THESE PARAMETERS here (a, b)
// because TECHNICALLY HERE WE'RE WORKING WITH THE
// Arguments OBJECT TO ACCESS THE ARGUMENTS THAT HAVE PASSED HERE. 
// WE'RE NOT REFERENCING THE PARAMETERS (a or b) ANYWHERE IN THE BODY OF THIS FUNCTION. 
// So we can simplify this code and remove these parameters. 

function sum() {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5, 10));

// In the next lecture, we're going to look at a better way to implement this function.

// Baz Additional Practice
function bazStringAddition() {
    let outputString = '';
    for (let eachInputString of arguments)
        outputString = outputString + eachInputString + ' ';
    return outputString;
}

console.log(bazStringAddition('Hello', 'my', 'name', 'is', 'Baz'));
// output:
// Hello my name is Baz




// --------------------------------------------------
// 7.4 Functions - The Rest Operator

// In modern JavaScript, IF YOU WANT TO HAVE A FUNCTION WITH A VARYING NUMBER OF PARAMETERS
// YOU CAN USE THE REST OPERATOR. 

// Let me show you how that works. 

// So here we modify the declaration of this function. 
// Add a parameter, let's call it args, and then prefix it with ... 

(...args)

// THIS IS WHAT WE CALL THE REST OPERATOR. 

function sum(...args) {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5, 10));

// Now don't confuse this with the spread operator, 
// because spread operator looks exactly the same. 

// Earlier we used the spread operator with arrays. 
// So with the spread operator we can spread an array 
// which basically means taking it's individual elements.

// But WHEN WE USE THIS ALONG WITH THE PARAMETER OF A FUNCTION,
// WE REFER TO THIS AS THE REST OPERATOR. 
// And you will know why this is called rest in a second. 

// So, let's see how the rest operator works. 

// I'm going to delete all this code. 
// And simply do a console.log of args. 

// So here we call in this function with 6 arguments, save the changes,
// now here on the console, you can see args is an array of 6 elements.

function sum(...args) {
    console.log(args);
}

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// [ 1, 2, 3, 4, 5, 10 ]
// undefined

// This is a real array. 
// Note that if I remove these three dots, (args)
// that basically means this function has a single parameter called args. 
// So when I save the changes, instead of this array you're going to see one, 
// because the first argument passing through this function is 1. 
// Save the changes, you get 1.

// So here's the lesson. 

// WHEN WE APPLY THE REST OPERATOR TO A PARAMETER OF A FUNCTION, 
// WE CAN PASS A VARYING NUMBER OF ARGUMENTS AND THE REST OPERATOR WILL TAKE ALL OF THEM 
// AND PUT THEM IN AN ARRAY. 

// Now IF YOU WANT TO GET THE SUM OF ALL THE NUMBERS IN AN ARRAY, 
// WE CAN USE THE REDUCE METHOD. 
// YOU LEARNT ABOUT THAT IN THE SECTION ABOUT ARRAYS. 

// So args is an array, 
// we can call the reduce method and pass an arrow function here.
// a and b, => a + b. 
// You've done this before, right? 
// So, you'd simply return the result. 
// Save the changes, and we get 25. 

function sum(...args) {
    return args.reduce((a, b) => a + b);
}

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// 25


// So you see in modern JavaScript we can achieve the same functionality with less code. 
// INSTEAD OF DEFINING A TOTAL VARIABLE, SETTING IT TO 0, 
// AND THEN LOOPING OVER THE ARGUMENTS OBJECT,
// WE CAN HAVE 1 LINE OF CODE THAT GIVES US THE SAME THING. 
// This is more elegant and more professional. 

// Now let's take this example to the next level. 

// Imagine we're going to use this function to calculate the total costs of items in a shopping cart.

// Here, let's say we want to have a discount factor, 
// so I'm going to add a parameter here, discount, and then rename args to let's say prices. 

function sum(discount, ...prices) {

}

// So we're passing the price of all the items, in a shopping cart, 
// now let's change line 8 where we call the sum function, 

// let's say we're going to pass 0.1 or 10% for the discount, 
// and we have two products in our shopping cart, we have prices 20 and 30 dollars. 

console.log(sum(0.1, 20, 30));

// So here, instead of returning the sum of all the items in the prices array,
// we're going to store the sum here, in total we don't need this anymore. 
// And then we want to return total times 1 - discount.

// So if discount is 0.1 we subtract it from 1, we get 0.9. 
// Then we multiply it by the total and this will return the final price after the discount is applied. 
// Save the changes, so we get 45.

function sum(discount, ...prices) {
    const total = prices.reduce((a, b) => a + b);
    return total * (1 - discount);
}

console.log(sum(0.1, 20, 30));
// output:
// 45

// Now let me show you something, I'm going to add 1 parameter after prices. 
// Let's call that someValue. 
// Now on line 7 where we call this function, 
// let's pass a new value like 1, save the changes, we get this error. 
// Rest parameter must be last formal parameter. 

function sum(discount, ...prices, someValue) {
    const total = prices.reduce((a, b) => a + b);
    return total * (1 - discount);
}

console.log(sum(0.1, 20, 30, 1));
// output:
// SyntaxError: Rest parameter must be last formal parameter

// So WE CANNOT HAVE A PARAMETER AFTER USING THE REST OPERATOR 
// so here prices is the rest parameter, 
// so IT SHOULD BE THE LAST PARAMETER IN THE FUNCTION.

// Let's remove this AND THIS IS THE REASON WE CALL THIS REST. 

// Because WE CAN HAVE 0 OR MORE PARAMETERS BEFORE THIS, 
// in this case we have discount, 
// so we have discount AND THE REST OF THE PARAMETERS, 
// or the rest of the arguments that have passed to this function. 

// That's the reason this operator is called the rest operator.




// --------------------------------------------------
// 7.5 Functions - Default Parameters

// There are times that WE WANT TO SUPPLY DEFAULT VALUES TO THE PARAMETERS OF A FUNCTION.

// For example, let's imagine we want to write a function for calculating the total interest. 

// So here we have there parameters, principle, interest rate and years.

function interest(principal, rate, years) {

}

// And here's the formula, to calculate the total interest. 
// Principle times rate divided by 100 times years. 

function interest(principal, rate, years) {
    return principal * rate / 100 * years;
}

// Now, let's call this function, 
// let's imagine the principle is 10,000 dollars, 
// rate is 3.5 percent,
// and we want to pay this back over 5 years. 
// So let's log this on the console, 
// so the total interest we have to pay is just over 1700. 

function interest(principal, rate, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, 3.5, 5));
// output:
// 1750

// Now, WHAT IF WE WANT TO HAVE DEFAULT VALUES for an interest rate and the number of years. 
// Well, earlier in the section about operators, I showed you a technique like this. 
// So rate equals rate or 3.5.

// So IF RATE HAS A VALUE, IF IT'S TRUTHY, WE'RE GOING TO USE THAT, OTHERWISE WE'RE GOING TO USE 3.5.
// So WE CAN USE THE LOGICAL OR OPERATOR TO GIVE A VARIABLE A DEFAULT VALUE, 
// similarly we can set years, years or 5.

// With this, IF WE EXCLUDE THESE ARGUMENTS (WHEN CALLLING THE FUNCTION)
// THOSE DEFAULT VALUES WILL BE USED. 
// So I'm going to delete these arguments, save the changes, and see we still get the same result. 

function interest(principal, rate, years) {
    rate = rate || 3.5; // if rate has a value it is truthy, (OR) otherwise use 3.5
    years = years || 5; // if years has a value it is truthy, (OR) otherwise use 5

    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// 1750

// But starting from ES6, WE HAVE A CLEANER WAY TO ACTUALLY HAVE THE SAME THING. 
// So INSTEAD OF HAVING THESE LOGICAL EXPRESSIONS

// rate = rate || 3.5;
// years = years || 5;

// WE CAN SET THE DEFAULT VALUES RIGHT HERE (IN THE PARAMETERS). 

// So, we set to rate to 3.5, and years to 5. 
// And now we can delete these two lines, save the changes, you still get the same result,

function interest(principal, rate = 3.5, years = 5) {
    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// 1750

// So we can see that setting the default value for function parameters is really easy. 

// There is just ONE CAVEAT HERE, ONCE YOU GIVE A PARAMETER A DEFAULT VALUE, 
// YOU SHOULD ALSO GIVE ALL THE OTHER PARAMETERS AFTER THAT A DEFAULT VALUE. 

// For example, let's see what happens if we set the default value for rate, but not years.
// When we save the changes, we get Not a Number, 

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// NaN

// because we passed 10,000, so principle is 10,000, 
// rate is by default 3.5 
// But years doesn't have a value, so it's undefined. 
// That's why the result of this expression is Not a Number. 

// Now what if we passed 5 for the years?

// Well this is confusing for the JavaScript engine because 
// it doesn't know if 5 should be used for rate or the years. 
// So if I save the changes, you still get the same result, not a number.

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, 5));
// output:
// NaN

// Because in this case 5 is used for the rate, but years is still undefined. 

// Now THERE IS A TRICK AROUND THIS, SO, WE CAN PASS UNDEFINED FOR THE SECOND PARAMETER, 
// and with this, rate will be set to 3.5 and years will be set to 5, 
// now we get the same result as before. 

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, undefined, 5));
// output:
// 1750

// But code like this is really ugly.
// Somebody looking at this code, they wonder, what is this undefined? 
// They have to look at the function to figure out what parameter is associated with undefined? 

// So as a best practice, WHENEVER YOU WANT TO GIVE A FUNCTION PARAMETER A DEFAULT VALUE, 
// MAKE SURE THAT THAT PARAMETER IS THE LAST PARAMETER IN THE LIST, 
// OR GIVE ALL THE PARAMETERS AFTER THAT A DEFAULT VALUE.



// --------------------------------------------------
// 7.6 Functions - Getters and Setters

// In this lecture, we're going to look at A SPECIAL KIND OF METHODS IN OBJECTS 
// CALLED GETTERS AND SETTERS. 

// So let's imagine we have the person object with two properties.
// First name, set this to Mosh, and last name, set this to Hamedani. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani'
};

// Now somewhere in our application we want to display a person's full name. 
// So, we have to do something like this. 
// Console.log we can either get the person.firstName, 
// concatenate it with space and the last name, 

console.log(person.firstName + ' ' + person.lastName);

// or a better way, as I told you before,is to use a template literal. 
// So we use the back tick and then we add a couple arguments here, 
// so, here's the first one, the argument is person.firstname, 
// now we have a space, and here's the second argument, person.lastname

console.log(`${person.firstName} ${person.lastName}`);

// however, the problem with this approach is maybe there 
// are multiple places in our application where we want to display someone's full name. 

// With the current implementation, we'll have to repeat this template literal in multiple places. 

// A BETTER APPROACH IS TO DEFINE A METHOD IN THIS OBJECT, 
// CALL IT FULLNAME, AND MOVE THIS EXPRESSION RIGHT THERE (inside the console.log()).

// AND THEN WHENEVER WE WANT TO DISPLAY A PERSON'S FULL NAME 
// WE SIMPLY CALL THAT METHOD.

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName: function () { }
};

// So, we can add another key value pair, full name, but we set the value to a function, 
// or as I told you before, IN ES6 WE HAVE A SHORTER SYNTAX, 
// TO ADD A METHOD TO AN OBJECT (SO INSTEAD OF ADDING IT AS A KEY VALUE PAIR), 
// WE CAN ADD IT AS A FUNCTION WITHOUT THE FUNCTION KEYWORD.

// So, (normally) if you want to define a function outside of an object, what do we do?
// We add function, the name of the function, parenthesis, and curly braces.

function fullName() { }

// However, WHEN WE NEED TO ADD THIS INSIDE OF AN OBJECT, WE JUST DROP THE FUNCTION KEYWORD.

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName() { }
};

// So you can see, this new syntax is shorter and cleaner than the older syntax
// fullName: function() {}

// So here's our fullName method, we simply return this expression here. 

// Now with this new implementation, every time we need to display someone's full name, 
// we simply call person.fullname. Save the changes, we get Mosh Hamedani. Beautiful. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName() {
        return `${person.firstName} ${person.lastName}`
    }
};

console.log(person.fullName());
// output:
// Mosh Hamedani

// However, there are a couple problems with this approach.

// The FIRST PROBLEM, IS THAT THIS IS READ ONLY.
// In other words, we cannot set a person's full name from the outside. 

// It would be nice if we could do this, and then the first name and last name properties 
// would be automatically set based on what we passed here.

// The OTHER ISSUE IS THAT I DON'T LIKE TO CALL THIS LIKE A METHOD.
// IT WOULD BE NICER, IF WE COULD TREAT THIS AS A PROPERTY.
// So, we could drop the parenthesis. Like this. 

// So how do we do this? 

// Well, THAT'S WHERE GETTERS AND SETTERS COME IN the picture. 

// We USE GETTERS TO ACCESS PROPERTIES IN AN OBJECT 
// and SETTERS TO CHANGE OR MUTATE THEM. 

// So in this object we should add a getter, 
// and WITH THAT GETTER WE CAN READ THIS person's full name, like a property, 
// and WITH A SETTER WE CAN SET IT from the outside. 

// So here is how it works. 

// WE PREFIX THIS METHOD WITH THE GET KEYWORD, AND NOW THIS METHOD IS A GETTER. 

get fullName() {

}

// So we can access the full name like a property on line 15. 
// Let me temporarily comment out this line, save the changes, 
// you can see our program is still working, beautiful, so THIS IS OUR GETTER, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    }
};

console.log(person.fullName);
// output:
// Mosh Hamedani

// now to be able to set this from the outside we need to add a setter. 
// A setter is very similar. 
// So WE ADD THE SET KEYWORD, THE NAME OF THE PROPERTY OR METHOD, AND THEN CODE BLOCK. 

set fullName(value) {

}

// HOWEVER, THIS METHOD NEEDS A PARAMETER, YOU CAN CALL IT VALUE OR ANYTHING. 
// AND THE VALUE OF THIS PARAMETER WILL BE WHAT WE HAVE IN THE RIGHT SIDE OF THE ASSIGNMENT OPERATOR.

set fullName(value) {

}

person.fullName = 'John Smith'; // this 'John Smith' is value of the "value" PARAMETER of set fullName

// So here let's assume that value is a valid string, 
// we need to split that string by a space, 
// take the parts and set the first name and last name properties. 

// So, value call the split method of string, we want to split it by a space, 
// this will return array, we can call that parts.

// Now we can set the first name to parts of 0, and last name to parts of 1. 
// And finally, instead of logging the person's full name, let's just log the person object. 

// So, initially, we set the first and last name to Mosh Hamedani, 
// now with this new property which is actually a setter, 
// we are changing the name to John Smith. 

// Save the changes, here's our person object, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = 'John Smith';

console.log(person);
// output:
// { firstName: 'John', lastName: 'Smith', fullName: [Getter/Setter] }

// you can see first name and last name properties are updated, also note that full name, 
// it's value is ... 
// Sometimes when you're logging objects in the console, 
// you may see properties with this kind of value. 
// As you can see from the tool tip, this is a getter. 

// In order to read the value you need to click here, 
// and now this method is executed and the result is returned in the console. 
// So this is the benefit of getters and setters. 

// In the next lecture we're going to look at error handling.

// Baz Extra Practice
const phoneNumber = {
    firstPart: '020',
    secondPart: '81234567',
    get fullNumber() {
        return `${this.firstPart} ${this.secondPart}`;
    },
    set fullNumber(value) {
        const arrayFromParts = Array.from(value);
        this.firstPart = arrayFromParts.slice(0, 3).join('');
        this.secondPart = arrayFromParts.slice(3, 13).join('');
    }
};
console.log(phoneNumber.fullNumber); // before with harcoded value
phoneNumber.fullNumber = '02089876543' // use the SETTER on fullNumber
console.log(phoneNumber.fullNumber); // after using Setter
// output:
// 020 81234567
// 020 89876543




// --------------------------------------------------
// 7.7 Functions - Try and Catch

// In the last lecture we assume that the value that we receive here is a
// valid string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = 'John Smith';

console.log(person);

// But what would happen if we pass a boolean here? 
// That doesn't make sense, right? 

// So let's run this code we get this error. 
// Uncaught type error, value.split is not a function. 

// Because split is a method that belongs to strings. 
// Booleans don't have a split method, right? 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = true; // changed to a Boolean

console.log(person);
// output:
// TypeError: value.split is not a function

// What would happen if we pass null or undefined? 
// Save the changes, we get a different error.
// Cannot read property split of null. 

// Again, for the same reason we cannot call the split method on a null, 
// it's only available on a string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// TypeError: Cannot read property 'split' of null

// So here WE NEED TO ADD ERROR HANDLING.

// TYPICALLY, IN SITUATIONS LIKE THIS, WE SHOULD DO ERROR HANDLING
// AT THE BEGINNING OF A FUNCTION OR A METHOD, 
// THIS IS WHAT WE CALL DEFENSIVE PROGRAMMING. 

// So WE WANT TO MAKE SURE THAT THE VALUES COMING IN ARE VALID, 
// THEY'RE IN THE RIGHT SHAPE, SO WE CAN EXECUTE OUR LOGIC. 

// So, the first line of this method should be something like this. 

// You want to make sure that this value is a string.

// So, WE CAN USE THE TYPEOF OPERATOR, 
// if typeof value is not String, then, one simple approach is to return 
// and with this we'll no longer see this error message here. 
// Save the changes, 

// so we can see the person object with the ORIGINAL first name and last name. 
// So what we passed here (person.fullName = null) did not take effect. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string') return;

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// { firstName: 'Mosh', lastName: 'Hamedani', fullName: [Getter/Setter] }


// But SOMETIMES WE WANT TO REPORT AN ERROR IN OUR APPLICATION. 

// THAT'S WHERE WE NEED TO THROW AN EXCEPTION. 

// THROWING AN EXCEPTION IS A TECHNICAL JARGON THAT YOU MIGHT HERE IN A LOT OF
// PROGRAMMING LANGUAGES. 

// So let's see how that works in JavaScript.

// So instead of returning from this method, 
// USE THE THROW KEYWORD AND THEN CREATE A NEW ERROR OBJECT. 

// So new Error, 
// that looks familiar right, 
// so Error IS A CONSTRUCTOR FUNCTION, because here we have the Pascal case.

// And WE'RE CALLING THIS FUNCTION USING THE NEW OPERATOR TO CREATE A NEW Error OBJECT. 
// Right? 

// Now, as an argument we can pass an error message. So value is not a string.
// SO THIS IS HOW WE THROW AN EXCEPTION, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// Error: Value is not a string.


// Now some people confuse errors with exceptions, 
// but there is a slight difference between the two, 

// here WE CAN CREATE AN ERROR OBJECT, let's call it const e = new Error. 
// This is JUST A PLAIN JAVASCRIPT OBJECT, there's NOTHING SPECIAL about this. 

// BUT THE MOMENT YOU THROW THIS ERROR, WE REFER TO THAT AS AN EXCEPTION. 
// So this is an exceptional situation that should not have happened. Okay?

const e = new Error(); // PLAIN JAVASCRIPT OBJECT
throw e; // THE MOMENT WE THROW THIS ERROR, WE REFER TO THAT AS AN EXCEPTION.

// Now, in this method, WE HAVE SOME BASIC ERROR HANDLING,
// SO THIS METHOD IS THROWING AN EXCEPTION, 

// NOW SOMEWHERE ELSE WE NEED TO CATCH THAT EXCEPTION, 

// we need to catch that, and QUITE OFTEN WHEN WE CATCH AN EXCEPTION, 
// WE DISPLAY AN ERROR TO THE USER

// so this is how we accomplish this. 

// Line 15 is where we receive this exception, 

// so WE NEED TO WRAP THIS LINE, IN A TRY BLOCK
// so, try, we move this line (person.fullName = null;) here

// so TRY BLOCK CAN HAVE 1 OR MORE STATEMENTS, 
// ONE OF THESE STATEMENTS AT LEAST CAN THROW AN EXCEPTION, 

// now, WE ADD THE CATCH BLOCK AFTER, IN PARENTHESIS, WE GIVE AN IDENTIFIER, 
// THIS IS THE ERROR OBJECT THAT WE ARE THROWING HERE. 

// SO IN THE CATCH BLOCK WE CAN GET THAT ERROR OBJECT AND
// DO SOMETHING WITH IT. 

// So here, we can display it on the console, 
// but as you know this is only visible to developers, 
// so an end user will not see this error, so temporarily we can use the alert function, 

// this is not something I'd recommend you to do, 
// because that's a very old and poor way of reporting errors to users.

// The proper way is to display a label, perhaps a red label on the user interface, 
// but that's a topic for a future video, so for now let's just use the built in alert function. 

// Now, save the changes, and here's our alert. 
// Value is not a string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = null; // changed to null
}
catch (e) {
    console.log(e);
}

console.log(person);
// output:
// Error: Value is not a string.


// Now, let's take this to the next level. 
// Instead of passing null, I'm going to pass an empty string. Save the changes,
// we don't get any errors, but first name is an empty string and last name is undefined. 
// Hm, again that's not desirable. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = ''; // changed to empty string
}
catch (e) {
    console.log(e);
}

console.log(person);
// output:
// { firstName: '', lastName: undefined, fullName: [Getter/Setter] }


// So, ideally we want to make sure that our user is typing a first name and last name. 
// So, when splitting that string, we can check the length of this array, 
// so, if parts.length is not 2, that means something is missing. 

// So HERE WE CAN THROW ANOTHER EXCEPTION. 
// throw new Error, with a different message. 
// Enter a first and last name. Okay, now, save the changes, 
// and here's our new exception. Enter a first and last name.


const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        if (parts.length !== 2) // check the length of the array
            throw new Error('Enter a first and last name.') // throw an error

        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = '';
}
catch (e) {
    console.log(e);
}

console.log(person);
// Error: Enter a first and last name.

// So, BASICALLY WHEN WE THROW AN EXCEPTION, THE LINES AFTER THE THROW STATEMENT ARE NOT EXECUTED. 
// WE WILL JUMP OUT OF THIS METHOD AND THE CONTROL WILL MOVE TO THE CATCH BLOCK. 
// HERE WE CATCH THE EXCEPTION, AND DO SOMETHING WITH IT. 

// So this is the basics of error handling in JavaScript.




// --------------------------------------------------
// 7.8 Functions - Local vs Global Scope

// In this lecture we're going to talk about A VERY IMPORTANT CONCEPT CALLED SCOPE.

// So I'm going to define a constant called message and set it to hi. 
// Now let's log this in the console so obviously we get hi on the console.

const message = "hi";
console.log(message);
// output:
// hi

// But what would happen if I add this message in a code block? 
// Let's save the changes and see what happens. 
// We get this error. 
// Uncaught reference error, message is not defined. 

{
    const message = "hi";
}
console.log(message); // message is not accesible outside of its scope
// output:
// ReferenceError: message is not defined


// This is all about SCOPING. 

// So A SCOPE OF A VARIABLE OR A CONSTANT, 
// DETERMINES WHERE THAT VARIABLE OR CONSTANT IS ACCESSIBLE.

// And WHEN WE DECLARE VARIABLES OR CONSTANTS WITH LET OR CONST,
// THEIR SCOPE IS LIMITED TO THE BLOCK IN WHICH THEY ARE DEFINED. 

// So message IS ACCESSIBLE IN THIS BLOCK, 
// BUT IT'S NOT ACCESSIBLE OUTSIDE OF THIS BLOCK. 

// Now you might be wondering why do we need this code block here? 

// Well, this code block can be part of a function. 
// So here we can have a function called start. 
// And now WE HAVE A CONSTANT IN THIS FUNCTION. 
// So BECAUSE THE SCOPE OF THIS CONSTANT IS LIMITED TO THE BLOCK IN WHICH IT'S DEFINED, 
// WE CANNOT ACCESS THIS CONSTANT OUTSIDE OF THE start FUNCTION.

function start() {
    const message = 'hi';
}
console.log(message); // message is not accesible outside of its scope
// output:
// ReferenceError: message is not defined

// THE SAME IS TRUE WHEN WE DECLARE A VARIABLE OR A CONSTANT IN AN IF BLOCK.

// So, let's add an if block here, 
// some condition, we don't care, 
// let's declare another constant, and set it to bye.

// Now, THIS CONSTANT IS ONLY ACCESSIBLE IN THIS BLOCK, 
// if I go out of this block, and try to log it on the console, we're going to get an error.

// So, I'm going to remove the last line, let's just call the start function. 
// Save the changes, we get the same error. Reference error. Another is not defined. 

function start() {
    const message = 'hi';

    if (true) {
        const another = 'bye';
    }

    console.log(another); // another is not accesible outside of its scope
}

start();
// output:
// ReferenceError: another is not defined

// We have the same concept in our loops. 
// So let's define a for loop, let i = 0, we're gonna run it 5 times, 
// now i is a variable that is only accessible in this block. 
// So here, we can log i, let's save the changes, we get numbers 0-4. 
// But if we go outside of this for block, and log i, we're going to get the same error. 
// Reference error, i is not defined.

function start() {

    for (let i = 0; i < 5; i++) {
        console.log(i);
    }

    console.log(i); // i is not accesible outside of its scope
}

start();
// output:
// ReferenceError: i is not defined

// Now, let me simplify this code. 
// So we're going to have a function with a constant called message. 
// We can have another function, let's call that stop. 
// And in this function we can have a constant called message, 
// with a different value. 

function start() {
    const message = 'hi';
}

function stop() {
    const message = 'bye';
}

// That's perfectly valid JavaScript code. 

// Because THE SCOPE OF THIS CONSTANT IS LIMITED, TO THE BLOCK IN WHICH IT'S DEFINED.

// So WE CAN HAVE TWO VARIABLES OR CONSTANTS WITH THE SAME NAME 
// BUT IN DIFFERENT FUNCTIONS. That's perfectly valid. 

// Now, WHAT IF WE DEFINE A VARIABLE OR A CONSTANT OUTSIDE OF A FUNCTION? 

// So here I'm going to define a constant, color, and set it to red. 

// Now here we don't have any code blocks, 
// so what do you think is the scope of this constant? 

// THIS CONSTANT HAS GLOBAL SCOPE. 

const color = 'red';

function start() {
    const message = 'hi';
}

function stop() {
    const message = 'bye';
}

// GLOBAL MEANS THIS CONSTANT IS ACCESSIBLE EVERYWHERE, GLOBALLY.

// So we can go to the start function and log color, save the changes 
// you can see we have access to this constant, color, 

// so THIS CONSTANT IS ACCESSIBLE IN ALL THE FUNCTIONS WE HAVE IN OUR PROGRAM.

const color = 'red';

function start() {
    const message = 'hi';
    console.log(color);
}

function stop() {
    const message = 'bye';
}

start();
// output:
// red

// Now WHAT IF WE HAVE A CONSTANT WITH THE EXACT SAME NAME, IN OUR FUNCTION?

// So let's take a look, I'm going to define this color constant, we'll set it to blue.
// What do you think we're going to see when I save the changes, let's take a look.
// We get blue. 

const color = 'red';

function start() {
    const message = 'hi';
    const color = 'blue';
    console.log(color);
}

function stop() {
    const message = 'bye';
}

start();
// output:
// blue

// So, LOCAL VARIABLES, or local constants IN A FUNCTION TAKE PRECEDENCE 
// OVER GLOBAL VARIABLES or global constants. 

// Now in general you should avoid defining global variables or constants, 
// that is considered bad practice. 

// Let me give you a metaphor. 

// Imagine this is a tooth brush, and each function is a person. 
// You don't want to have a tooth brush that is shared between multiple people. 
// Each person should have their own tooth brush. 

// So YOU SHOULD AVOID DEFINING GLOBAL VARIABLES OR CONSTANTS 
// BECAUSE THEY'RE ACCESSIBLE EVERYWHERE, GLOBALLY, 
// AND EACH FUNCTION CAN ACCIDENTALLY CHANGE THEIR VALUE, 
// AND THIS WILL LEAD TO ALL KINDS OF BUGS AND ISSUES IN OUR PROGRAMS.




// --------------------------------------------------
// 7.9 Functions - Let vs Var

// So far we have been declaring variables using the let keyword. 

let x = 0;

// But at the beginning of course, 
// I briefly mentioned that there is another way to declare variables,
// using the var keyword. 

var y = 0;

// And we see this in a lot of JavaScript code online. 

// In this lecture  we're going to look at the var keyword, 
// you're going to LEARN ABOUT THE PROBLEMS WITH THE VAR,
// and why you should avoid it. 

// So let's start by defining a function, start, 
// here we're going to have a loop, let i = 0.
// We're going to run this loop 5 times, and in each iteration 
// we're going to display i on the console. 
// Now, let's call the start function, save the changes, so we get numbers 0-4. 

function start() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
    }
}

start();
// output:
// 0
// 1
// 2
// 3
// 4

// Now in the last lecture you learned that i is only accessible inside this block.
// So if you try to log i outside this block, we're going to get an error, 
// i is not defined. 

function start() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
    }

    console.log(i); // i is not accesible outside of its scope
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// ReferenceError: i is not defined

// Now I just want to clarify something. 

// We still have the same concept if I remove these curly braces, 
// because here WE HAVE A SINGLE STATEMENT, 
// SO THE SCOPE OF I IS STILL THIS BLOCK HERE. 
// Okay? So save the changes, we still get the same error. 

function start() {
    for (let i = 0; i < 5; i++) // start curly brace removed
        console.log(i);
    // end curly brace removed
    console.log(i); // i still not not accesible outside of its scope
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// ReferenceError: i is not defined

// However, LET'S SEE WHAT HAPPENS WHEN WE REPLACE LET WITH VAR.
// Save the changes. What happened to our error?

function start() {
    for (var i = 0; i < 5; i++) // let changed to var
        console.log(i);

    console.log(i);
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// 5

// So, IT TURNS OUT THAT i IS ACCESSIBLE OUTSIDE OF THIS FOR BLOCK. 

// So in the last iteration, i becomes 5. 
// Because 5 is not less than 5 so the loop terminates, 
// and here on line 6, we're displaying the current value of i. 

// So THIS IS THE ISSUE WITH THE VAR KEYWORD. 

// WHEN YOU DECLARE A VARIABLE WITH VAR. 
// IT'S SCOPE, IS NOT LIMITED TO THE BLOCK IN WHICH IT'S DEFINED. 

// IT'S LIMITED TO THE FUNCTION IN WHICH IT'S DEFINED, 
// AND THIS IS NOT HOW MOST OR ALL PROGRAMMING LANGUAGES OUT THERE WORK.

// It's one of those weird things in JavaScript that we have had for a long time.
// So BEFORE ES6, VAR WAS THE ONLY WAY TO DECLARE VARIABLES AND CONSTANTS. 

// Starting from ES6, also called ES2015, 
// NOW WE HAVE TWO NEW KEYWORDS LET AND CONST, 
// TO DEFINE DIFFERENT VARIABLES AND CONSTANTS. 

// THESE TWO (LET, CONST) KEYWORDS CREATE BLOCK SCOPED VARIABLES,
// BUT VAR CREATES FUNCTION SCOPED VARIABLES.

var x = 1; // FUNCTION SCOPED VARIABLES

let x = 1; // BLOCK SCOPED VARIABLES
const x = 1; // BLOCK SCOPED VARIABLES 

// Let's take a look at another example. 

// So in this for loop, let's add a code block here, 
// now I'm going to add an if statement, 
// now in the if block I'm going to declare a variable using var, 
// color set it to red.

// Now TECHNICALLY IN ALMOST ALL PROGRAMMING LANGUAGES OUT THERE, 
// THIS VARIABLES SHOULD ONLY BE ACCESSIBLE IN THIS IF BLOCK. 

// But because we have used var, color is accessible anywhere in this WHOLE function. 

// So, at the end of this function, you can log color, save the changes, 
// look we get red here.

function start() {
    for (let i = 0; i < 5; i++) {
        if (true) {
            var color = 'red';
        }
    }

    console.log(color);
}

start();
// output:
// red


// But IF WE REPLACE VAR WITH LET, YOU GET AN ERROR, 
// BECAUSE COLOR IS NOT ACCESSIBLE HERE. AND THAT'S HOW MOST LANGUAGES WORK.

function start() {
    for (let i = 0; i < 5; i++) {
        if (true) {
            let color = 'red';
        }
    }

    console.log(color);
}

start();
// output:
// ReferenceError: color is not defined


// So this is the first problem, with the var keyword. 

// THE SECOND ISSUE IS WITH GLOBAL VARIABLES. 

// So let's delete all the code, 
// I'm going to declare two variables,
// one with var color we set it to red, 
// and one with let, Let's say age and set it to 30. 

var color = 'red';
let age = 30;

// NOW WHEN WE USE VAR, OUTSIDE OF A FUNCTION, 
// THIS CREATES A GLOBAL VARIABLE 
// AND ATTACHES THAT GLOBAL VARIABLE TO THE WINDOW OBJECT IN THE BROWSER. 

// So IN BROWSERS WE HAVE THIS WINDOW OBJECT,

// WHICH IS A COMPLEX OBJECT WITH LOTS OF PROPRTIES AND METHODS. 

// WHEN YOU WANT TO BUILD FRONTEND APPLICATIONS YOU'RE GOING TO WORK 
// WITH THIS WINDOW OBJECT A LOT. 

// Now what matters here is THIS VAR KEYWORD ATTACHES THIS COLOR VARIABLE 
// TO THE WINDOW OBJECT. 

// So if you type window. 
// look our color variable is here. 

window.color // does exist (declared with var)

// IN CONTRAST WHEN WE USE THE LET KEYWORD TO DEFINE A GLOBAL VARIABLE, 
// THAT GLOBAL VARIABLE IS NOT ATTACHED TO THE WINDOW OBJECT.

// So, if we type window.age 
// you can see it's undefined.

window.age // doesnt exist (declared with let)

// So WHY IS IT BAD TO ATTACH A WINDOW TO A VARIABLE OBJECT?

// Well, BECAUSE WINDOW OBJECT IS SOMETHING CENTRAL, 
// THERE IS ONLY ONE INSTANCE OF THE WINDOW OBJECT, 
// AND LET'S SAY YOU'RE USING A THIRD PARTY LIBRARY. 

// IF THAT THIRD PARTY LIBRARY ALSO HAS A VARIABLE WITH THE SAME NAME, 
// THAT VARIABLE CAN OVERRIDE YOUR VARIABLE. 

// So you should avoid adding stuff to the window object. 
// Otherwise you're going to create all sorts of issues in your program. 

// Now, for a curious developer, 
// I need to mention that WHEN WE DEFINE A FUNCTION lets say sayHi, 
// THIS FUNCTION IS TECHNICALLY A GLOBAL FUNCTION 
// AND IS ADDED TO THE WINDOW OBJECT. 
// So let me save the changes.
// If you type window.sayHi, see our function is here so we can call it.

function sayHi() {
    console.log('hi');
}

window.sayHi

// So TECHNICALLY THIS IS A GLOBAL FUNCTION, IT'S ATTACHED TO THE WINDOW OBJECT, 
// AND THAT IS BAD PRACTICE. 

// But how can we prevent this? 

// Well, later in the course where I talk about modules, 
// YOU WILL LEARN HOW TO ENCAPSULATE THESE FUNCTIONS IN SEPARATE MODULES 
// SO THEY ARE NOT ADDED TO THE WINDOW OBJECT.

// So here's what I want you to take away from this lecture. 

// AVOID USING THE VAR KEYWORD, 
// BECAUSE IT CREATES VARIABLES THAT ARE FUNCTION SCOPED, NOT BLOCK SCOPED.



// --------------------------------------------------
// 7.10 Functions - the "this" Keyword

// In this lecture, we're going to have a closer look at 
// the "this" keyword in JavaScript, 

// this is one of those features that confuses a lot of developers, 
// but honestly, I think it's because of the poor teaching materials out there, 

// because I personally was confused about the "this" keyword for a long time. 

// So in this lecture I'm going to make it super simple for you, 
// so you can explain it to your 7 year old brother. 

// So what is "this"? 

// "This" REFERENCES THE ***OBJECT*** THAT IS EXECUTING THE CURRENT FUNCTION. 

// Here I'm going to give you a very simple rule of thumb. 

// IF THE FUNCTION IS PART OF AN OBJECT, WE CALL THAT FUNCTION A METHOD, right? 

// So IF THAT FUNCTION IS A METHOD IN AN OBJECT, 
// "this" REFERENCES THAT OBJECT ITSELF. 

// [1] (if the function is part of an object) : 
// METHOD (in an Object) "this" references that object ITSELF

// Othewise,
// IF THAT FUNCTION IS A REGULAR FUNCTION, WHICH MEANS IT'S NOT PART OF AN OBJECT, 
// "this" MEANS THE GLOBAL OBJECT, 
// which is the window object in browsers and global in Node.

// [2] (if it is a regular function (not part of an object) :
// FUNCTION (not part of an Object) "this" references the GLOBAL object 
// (which is the window object in browsers, and global in node)

// Let's take a look at a few examples.

// So, I'm going to start by creating a video object, 
// in this object we're going to have a title property and a play method. 
// Let's log this here, and finally call video.play.
// Save the changes

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

video.play();
// output:
// { title: 'a', play: [Function: play] }

// so we get our video object on the console.
// So in this example, 
// because play is a METHOD IN the video OBJECT, 
// "this" REFERENCES THIS (video) OBJECT ITSELF. 

// By the same token, we can add method later in this object, 
// and we'll get the same result.

// For example, we can add a stop method here, set it to a function, 
// and here we can do console.log of this,
// if we call the stop method, once again we're going to see the video object 
// on the console. So save the changes

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

video.stop = function () {
    console.log(this);
};

video.stop();
// output:
// { title: 'a', play: [Function: play], stop: [Function] }

// and here is our video object.
// Because again, stop IS A METHOD IN THE video OBJECT. 

// SO THAT'S AN EXAMPLE OF THE FIRST RULE.


// Now let's take a LOOK AT AN EXAMPLE OF THE SECOND RULE. 

// A REGULAR FUNCTION. 
// So let's delete this, and instead add a function called playVideo. 
// If we log this on the console, we're going to see the global object 
// which is window in browsers and global in Node.
// So let's call this function playVideo and save the changes 

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

function playVideo() {
    console.log(this);
}

playVideo();
// output:
// Window (in browser)

// so we get the window object here. 

// NOW WHAT IF THIS IS A CONSTRUCTOR FUNCTION?
// WE CALL THE CONSTRUCTOR FUNCTIONS USING THE new OPERATOR.

// So, let's rename play video to video with a capital V, 
// that's the convention for constructor functions, 
// now here we're going to pass a title property, and set this.title = title.

// Now we can use this constructor function to create a new video object.
// So we use the new operator, pass a title, save the changes,

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

function Video(title) {
    this.title = title;
    console.log(this);
}

const v = new Video('b');
// output:
// Video { title: 'b' }

// so, what do we get here, 
// instead of a window object, we get a new object, we get this Video object,

// because earlier in the course I told you that when you use the "new" operator
// this "new" operator creates a new empty object like this {}
// and sets "this" in this constructor function to point to this empty object {}. 

// So, here on line 12, we add the title property to this new object.
// this.title = title;

// So let's recap. 
// WHEN DEALING WITH A REGULAR FUNCTION, 
// "this" BY DEFAULT REFERENCES THE GLOBAL OBJECT, 

// bUT IF YOU CALL A FUNCTION, USING THE new OPERATOR, 
// WHICH IS THE CASE FOR CONSTRUCTOR FUNCTIONS, 
// "this" WILL REFERENCE A NEW EMPTY OBJECT. 


// Now THE LAST EXAMPLE. 
// I'm going to clean up this code. 

// Let's add another property in this object, 
// tags, we set it to an array of 3 strings.

// Now let's rename the play method to showTags 

// so here you can use "this" TO GET THE CURRENT OBJECT,
// AND THEN GET THE TAGS PROPERTY, 
// because this is an array we can call the forEach method, 
// and here we need to pass a callback function.

// So function, in each iteration this function will get a tag, 
// and then we can display the tag on the console. 
// So console.log of tag. 

// Finally, let's call video.showTags. 
// Save the changes, so we get a, b, c. Beautiful.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(tag);
        });
    }
};

video.showTags();
// output:
// a
// b
// c

// But what if we want to display the title of the video next to each tag? 
// Well, you can add this.title here, save the changes,

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        });
    }
};

video.showTags();
// output:
// undefined a
// undefined b
// undefined c

// We've got undefined. What's going on here? 
// Well, let's remove the title property and see what "this" is referencing. 
// Save the changes, 

// IT'S REFERENCING THE WINDOW OBJECT, 
// BUT AREN'T WE INSIDE A VIDEO OBJECT HERE? 
// SHOULDN'T THIS REFERENCE THE VIDEO OBJECT? 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        });
    }
};

video.showTags();
// output:
// Window a
// Window b
// Window c


// NO, BECAUSE HERE WE ARE INSIDE THIS CALLBACK FUNCTION (function(tag) {}) 
// THIS FUNCTION IS JUST A REGULAR FUNCTION. 
// IT'S NOT A METHOD IN THE video OBJECT. 
// THE ONLY METHOD WE HAVE HERE IS showTags() {}.

// SO BECAUSE THIS IS A REGULAR FUNCTION (function(tag) {})
// "this" REFERENCES THE GLOBAL OBJECT. 

// SO IT'S THE GLOBAL OBJECT THAT IS EXECUTING THIS ANONYMOUS CALLBACK FUNCTION. 

// But how can we solve this problem 
// and display the title of the video next to each tag?

// Well, we have A FEW DIFFERENT SOLUTIONS FOR THIS, 

// in this particular case, the forEach method has two parameters, 
// THE FIRST PARAMETER IS OUR CALLBACK FUNCTION, 
// THE SECOND PARAMETER IS thisArg? 

// So WE CAN PASS AN OBJECT HERE (as the second parameter) AND THIS WILL REFERENCE THAT OBJECT.

// For example, here I can pass a new object, the firstName, set to Mosh,
// now when we save the changes.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        }, { firstName: 'Mosh' });
    }
};

video.showTags();
// output:
// { firstName: 'Mosh' } a
// { firstName: 'Mosh' } b
// { firstName: 'Mosh' } c

// WE CAN SEE "this" IS REFERENCING THIS NEW OBJECT. 

// Now in this example, we don't really want this object, we want our video object. 
// So we can pass "this" here (where {firsName: 'Mosh'} is). 

// Because at this point, we are in the showTags method, 
// so "this" references the current object. 

// So here (after the {} of the anonymous function(tag)) 
// WE ARE NOT INSIDE OF A CALLBACK FUNCTION. 
// WE ARE STILL IN THE EXECUTION CONTEXT OF THE showTags METHOD. 

// So now if you save the changes

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        }, this);
    }
};

video.showTags();
// output:
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } a
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } b
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } c

// next to each tag we can see our video object 
// with this title property, so we can add the title property here, 
// and with this, we see the title of the video next to each tag, beautiful.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        }, this);
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// BUT NOT ALL METHODS IN JAVASCRIPT GIVE YOU THE ABILITY TO PASS THE THIS ARGUMENT.

// So we have a few different solutions for that, 
// and that's the topic for the next lecture.




// --------------------------------------------------
// 7.11 Functions - Changing "this"

// So in the last lecture you learned that 
// "this" REFERENCES THE OBJECT THAT IS EXECUTING THE CURRENT FUNCTION. 

// Alright, now let me show you A FEW DIFFERENT SOLUTIONS
// TO CHANGE THE VALUE OF "this" IN A FUNCTION.

// So, let's imagine our forEach method doesn't have the second parameter. 

// How can we change the value of "this"?

// Well, here's one simple solution. 

// BEFORE WE CALL THE FOREACH METHOD, WE CAN DEFINE A CONSTANT, 
// CALL IT "self" AND SET IT TO "this".  
// const self = this;

// Some people also call this that. 
// It's one of a personal preference there is no right or wrong. 

// So lets call "this" self,
// now at this point, self is referencing the video object here (const video = {}) 

// SO IN OUR CALLBACK FUNCTION WE CAN USE SELF INSTEAD OF THIS.
// BECAUSE THE VALUE OF THIS CHANGES WHEN A NEW FUNCTION IS CALLED.

// SO AT THIS POINT (in the showTags method) "this" REFERENCES THE video OBJECT, 
// BUT WHEN WE GET TO THIS ANONYMOUS CALLBACK FUNCTION (function (tag) { this.title }), 
// "this" REFERENCES THE GLOBAL OBJECT. 

// SO HERE WE CAN USE self.title INSTEAD OF this.title 
// WHICH IS THE ORIGINAL VALUE OF THIS, save the changes, 
// and we get the title of the video here. Beautiful. 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        const self = this;
        this.tags.forEach(function (tag) {
            console.log(self.title, tag);
        });
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// Now this is not the preferred approach, but it's something that you see 
// in a lot of JavaScript applications out there.

// So I JUST WANT YOU TO UNDERSTAND IT BUT DON'T USE THIS APPROACH. 

// Now let's take a LOOK AT ANOTHER APPROACH. 

// Earlier in the course, you learned that functions are objects in JavaScript. 

// So let's define a function call it playVideo, 
// here we do a console.log of "this". 

function playVideo() {
    console.log(this);
}
// output:
// Object [global] {
//  [a lot of text]
// }

// SO THIS FUNCTION IS TECHNICALLY, AN Object. 
// SO IT HAS PROPERTIES AND METHODS THAT WE CAN ACCESS USING THE DOT NOTATION. 

// Here we have 3 METHODS:

// APPLY
// BIND 
// CALL

// AND WITH THESE WE CAN CHANGE THE VALUE OF "this" FOR THIS FUNCTION. 

// THE SIMPLEST IS THE "call" METHOD. 

// THE FIRST PARAMETER OF THIS METHOD IS thisArg, 
// SO HERE WE CAN PASS AN OBJECT AND "this" WILL REFERENCE THAT OBJECT. 

// For example, I can pass a new object with the name property set to Mosh,
// now when we save the changes, we're going to see this object on the console. 

// But before we get there let me temporarily comment out this previous code, 
// so save the changes, you see this new object. 

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' });
// output:
// { name: 'Mosh' }


// IN CONTRAST IF WE CALL THIS FUNCTION USING THE STANDARD FUNCTION CALL SYNTAX,
// "this" REFERENCES THE WINDOW OBJECT. 

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }); // this references this Object
playVideo(); // this references the Window Object
// output:
// { name: 'Mosh' }
// Window

// So THIS IS A BENEFIT OF USING THE "call" METHOD. 


// We have ANOTHER METHOD THAT IS SIMILAR TO CALL AND THAT IS CALLED "apply". 

// So let me duplicate this line, change this to "apply", save the changes, 
// again, we get the same result.

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' });
playVideo.apply({ name: 'Mosh' });
playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window

// SO WHAT WE PASS AS THE FIRST ARGUMENT HERE WILL BE USED AS THE VALUE OF "this", 
// THE DIFFERENCE BETWEEN CALL AND APPLY IS ONLY ABOUT PASSING ARGUMENTS.

// So IF THIS FUNCTION HAS MULTIPLE PARAMETERS, let's say a and b, 
// we can supply multiple arguments here (as the call method's parameters), 1 and 2, 

// BUT WITH THE APPLY METHOD WE HAVE TO PASS THEM AS AN ARRAY. So, [1, 2].
// That's the only difference. 

function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2); // multiple parameters
playVideo.apply({ name: 'Mosh' }, [1, 2]); // mutiple parameters must be passed as an array
playVideo();


// WE HAVE ANOTHER METHOD THAT IS "BIND".

// So playVideo.bind
// once again the first argument is thisArg 
// so we can pass this object { name: Mosh } 

// bUT THIS BIND METHOD DOES NOT CALL OUR playVideo FUNCTION.

// IT RETURNS A NEW FUNCTION, 
// AND SETS "this" TO POINT TO THIS OBJECT { name: Mosh } PERMANENTLY. 

// SO NO MATTER HOW WE CALL THAT FUNCTION, "this" WILL ALWAYS, ALWAYS 
// POINT TO THIS OBJECT THAT WE PASS HERE { name: Mosh }. 

// So this returns the new function
// we can store the result in a constant, 
// and now call this function just like a regular function. 
// Save the changes,


function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2); // multiple parameters
playVideo.apply({ name: 'Mosh' }, [1, 2]); // mutiple parameters must be passed as an array
const fn = playVideo.bind({ name: 'Mosh' });
fn();

playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window

// once again we get this new object here. 

// Now in this particular case we don't really need the separate constant, 
// we can delete const fn and fn(); 
// and immediately call the function that is returned from the bind method. 
// Save the changes, we get the same result. 

function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2);
playVideo.apply({ name: 'Mosh' }, [1, 2]);
playVideo.bind({ name: 'Mosh' })(); // added () here to call it immediately

playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window


// SO WITH CALL, APPLY, AND BIND 
// WE CAN SET THE "this" ARGUMENT FOR A GIVEN FUNCTION. 

// Now, let's go back to our previous example. 
// So, let's delete all this code here.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        const self = this; // remove this self constant
        this.tags.forEach(function (tag) {
            console.log(self.title, tag); // change self.title to this.title
        }); // add .bind(this) method to the function (function(tag){}.bind(this));
    }
};

video.showTags();

// Back in the showTags method,
// so here we're passing this callback function, 
// and in this function we're going to use "this". 

// So we no longer need this self constant. 

// However as you know, by default, here "this" references the global object, 
// but we want to change this.

// So here we have a function, WE CAN CALL THE BIND METHOD IMMEDIATELY HERE 
// (AFTER THE {} OF THE ANONYMOUS CALLBACK FUNCTION), 
// AND THEN, PASS AN OBJECT TO BE USED AS THE VALUE OF "this".

// What should we pass here? "this".
// BECAUSE AS I TOLD YOU BEFORE, AT THIS POINT WE ARE IN THE showTags METHOD, 
// SO "this" REFERENCES OUR video OBJECT.

// So, save the changes, and once again you can see the title of the
// video next to each tag.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        }.bind(this));
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// SO USING THE BIND METHOD IS THE SECOND SOLUTION TO SOLVE THIS PROBLEM, 
// but THERE IS A NEWER AND BETTER SOLUTION.

// Starting from ECMA script 6, WE HAVE ARROW FUNCTIONS.
// THE GOOD THING ABOUT THE ARROW FUNCTIONS IS THAT THEY INHERIT
// THE "this" VALUE. 

// Let me show you what I mean by that. 

// So, let's remove the call to the bind method, 
// and change this function to an arrow function. 

// So we remove the function keyword 
// put a fat arrow between the parameter and the body,
// and because we have a single parameter we remove parenthesis.

// Clear syntax, now if you save the changes, we still get the same result,
// without doing anything extra. 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(tag => { // remove function keyword, add fat arrow, single parameter so remove parenthesis
            console.log(this.title, tag);
        });
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// THE REASON FOR THIS IS BECAUSE ARROW FUNCTIONS INHERIT "this" 
// FROM THE CONTAINING FUNCTION. 

// SO IN THIS FUNCTION "this" REFERENCES THE video OBJECT, 
// SO WHEN WE PASS AN ARROW FUNCTION HERE, THE SAME "this" VALUE, 
// IS USED IN THIS ARROW FUNCTION. 

// IN OTHER WORDS "this" IS NOT REBOUND TO A NEW OBJECT. 

// So let's quickly recap.

// In this lecture, you learned about 3 WAYS TO CHANGE THE VALUE OF "this".

// THE FIRST SOLUTION was using the "self" APPROACH

const self = this;

// THE SECOND SOLUTION WAS USING THE "bind" METHOD, 
// so right after defining this function, call bind, and pass this as the argument

(function (tag) { }.bind(this));

// but again this is the old way of doing things, 
// it's a little bit noisy but you may still see it in a lot of JavaScript applications 
// out there. 

// So GOING FORWARD THE MODERN APPROACH TO SOLVE THIS PARTICULAR PROBLEM 
// WHEN DEALING WITH CALLBACKS IS TO USE AN ARROW FUNCTION.

((tag) => { this });




// --------------------------------------------------
    </code></pre>
    <script src=prism.js></script>
</body>

</html>