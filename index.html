<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="prism.css">
    <title>Baz JavaScript Learning</title>
    <style>
        body {
            background-color: #1f2430;
        }
    </style>
</head>

<body>
    <pre class="line-numbers"><code class="language-javascript">
// --------------------------------------------------
// JavaScript Basics for Beginners

// --------------------------------------------------
// 2.1 Variables

// By default variables in Javascript are undefined.

let name;
console.log(name);
// output:
// undefined

// Declared a variable called name, and set it to this value, a string

let name = 'Baz';
console.log(name);
// output:
// Baz

// Variable Naming Rules:

// Cannot be a reserved keyword (if, else, for, etc.)
// Should be meaningful (meaningful labels, descriptive)
// Cannot start with a number (1name)
// Cannot contain a space or hyphen
// Variables are Case Sensitive
// Using camelCase -- convention we use to name our variables

let firstName;

// you can declare multiple variables either:
// on one line and separate them with a comma

let firstName, lastName;

// can optionally initialise one, or both of them

firstName = 'Baz', lastName = 'Murphy';

// but the modern best practise is to declare each variable on a single line

firstName = 'Baz';
lastName = 'Murphy';




// --------------------------------------------------
// 2.2 Constants

let interestRate = 0.3;

// this is the initial value we can always change that later

interestRate = 1;
console.log(interestRate);
// output:
// 1

// we see the new value in the console

// However sometimes we don't want the value of a variable to change,
// because it can create bugs in our application.

// In those situations we use a CONSTANT instead of a VARIABLE

// the Value of a VARIABLE (as the name implies) can VARY
// the Value of a CONSTANT cannot CHANGE

const interestRate = 0.3;
interestRate = 1;
console.log(interestRate);
// output:
// TypeError: Assignment to constant variable.

// Here is the best practice:

// If you don't need to RE-ASSIGN CONST should be your default choice

// Otherwise if you need to RE-ASSIGN a variable use LET




// --------------------------------------------------
// 2.3 Primitive Types

// 2 types in Javascript
// PRIMITIVE(/Value) Types and REFERENCE Types

// In Primitives we have:

// STRING
// NUMBER
// BOOLEAN
// UNDEFINED
// NULL


let name = 'Baz'; // String Literal

let age = 30; // Number Literal

let isApproved = true; // Boolean Literal

// we use a Boolean in a case where we want some logic,
// so if the order is approved then it needs to be shipped,
// so the value of a boolean variable can be true or false

let firsName; // if we don't initialise it, by default its value is undefined
let firstName = undefined; // this is not very common

let lastName = null;

// we use null when we want to explicitly clear the value of a variable

// for example, we present the user with a selection of colors
// if the user has not selected a color we want it to be null

let selectedColor = null;

// in the future when the user selects a colour we are going to reassign
// this variable to a color

let selectedColor = 'red';

// These are the examples of Primitive/Value Types

// in ES6 we have another primitive SYMBOL 
// but you will learn about that later in the course.




// --------------------------------------------------
// 2.4 Dynamic Typing

// One thing that separates JavaScript from a lot of programming languages, 
// is that JavaScript is a dynamic language. 

// What do I mean by Dynamic? 

// Well, we have two types of programming languages. 

// Static languages or Dynamic languages. 

// In Static languages, when we declare a variable, 
// the type of that variable is set and it cannot be changed in the future.

// In a Dynamic language like JavaScript, the type of a variable can change at run time. 
// Let's see this in code. 

// So back in the example from the last lecture we have declared this name variable, 
// and we have set that to a string, so the type of name is currently a string, 
// but it can change in the future. 

// Let's take a look. So here in the console, we can execute some JavaScript code, 
// we have this typeof operator, and with that we can check the type of a variable. 

// So after that we add the name of the variable. 
// In this case the name variable

let name = 'Baz';
typeof name;
// output:
// string

// So note that the type of name is a string. 
// So, if you reassign name to a different value, like a number, and check it's type,
// look, the type is now changed to a number, this is what we call a dynamic language, 

let name = 1;
typeof name;
// output:
// number

// so unlike static languages the type of these variables will be determined at runtime 
// based on the values that we assign to them. 

// Now, let's take a look at a few more examples of the "typeof" operator. 
// And by the way, note that typeof is another reserved keyword, 
// so we cannot have a variable called typeof. 

// So, we can clear the console by pressing control and L. 

// So now let's take a look at typeof age, it's a number. 

let age = 30;
typeof age;
// output:
// number

// Now if we change age to a floating point number, and I know it doesn't make sense, 
// but let's just stick to this for example, 30.1,
// and then look at typeof age, it's still a number. 

let age = 30.1;
typeof age;
// output:
// number

// So in JavaScript, unlike other programming languages 
// we don't have two kinds of numbers, we don't have floating point numbers
// and integers, all numbers are of type number.

// Now, let's look at the typeof isApproved, it's a boolean as I told you before,

let isApproved = true;
typeof isApproved;
// output:
// boolean

// what about the firstName, let's have a look.

let firstName = undefined;
typeof firstName;
// output:
// undefined

// It's undefined. And that's funny, because the value of this variable is undefined
// but it's type is also undefined. What does this mean?

// Well, earlier I told you that we had two categories of types,
// we have Primitives or value types, and Reference types.

// In the Primitive types category, we have STRINGS, NUMBERS, BOOLEANS, UNDEFINED and NULL. 

// So undefined is actually a TYPE, but it's ALSO a VALUE.

// In this example, because we have set firstName,to undefined as a value 
// it's type is also undefined, 

// Okay? But what about selectedColour. Let's have a look, so;

let selectedColor = null;
typeof selectedColour;
// output:
// object

// The type of this variable is an object.

// What is an object? That's a topic for the next lecture.




// --------------------------------------------------
// 2.5 Objects

// So you have seen all the primitive types in JavaScript. 
// Now let's look at the Reference Types.

// In the Reference Types category, we have:

// OBJECT
// ARRAY
// FUNCTION

// In this lecture we're going to explore Objects,
// and you will learn about Arrays and Functions later in this section. 

// So, what is an Object. 
// An object in JavaScript and other programming languages is like an object in real life. 

// Think of a person. A person has name, age, address and so on. 
// These are the properties of a person. You have the same concept in JavaScript.

// So when we're dealing with multiple related variables, 
// we can put these variables inside of an object. 

// For example, here we have two variables name and age, they're highly related, 
// they are part of the representation of a person, 

let name = 'Baz';
let age = 30;

// so instead of declaring two variables, we can declare the person object.
// And then instead of referencing these two variables we can
// just reference the person object, it makes our code cleaner.

// So, let's see how we can declare a person object.

// We start with let or const (if we don't want to reassign the person object), 
// and set it to an object literal. 

let person = {}

// So the syntax we have here use curly braces is what we call an Object Literal. 

// Now between these curly braces we add one or more key value pairs.
// So, the keys are what we call the properties of this object. 

// In this case we want this person object to have two properties or two keys, name and age,
// So, we add name here, that's the key, 
// then we add a colon, and after that we set the value so Mosh. 
// Now, we add a comma, and add another key value pair. Age 30 

let person = {
    name: 'Baz',
    age: 30
}

// So now we have this person object with two properties or two key value pairs, name and age. 
// And with that we don't need these two variables, we delete:
// let name = 'Baz';
// let age = 30;
// Now let's log person on the console.log, Save the changes.

let person = {
    name: 'Baz',
    age: 30
};

console.log(person);
// output:
// { name: "Baz", age: 30 }

// So here's our person object, again note the Object Literal syntax,
// so we have curly braces, and in between them we have one or more key value pairs, 
// and these are the properties of the person object.

// Now, there are two ways to work with these properties. 
// Let's say we want to change the name of this person, so we need to access the name property. 

// There are two ways, the first way is what we call the DOT NOTATION.
// So, we add the name of our object in the name of this person

person.                ;

// now you can see it's properties, age, and name.

// So you can change the name of to John.

// Now we can choose the dot notation to also read the value of a property, 
// so here on line 10, instead of logging the person object we can log it's name property.
// Save the changes, and in the console we get John.

person.name = 'John';

console.log(person.name);
// output:
// John

// The other way to access a property is using Bracket Notation.

// So instead of dot we use square brackets, 
// and we pass a string that determined the name of the target property
// so single or double quotes, but single quotes are more common.

// The name of the target property is name. 
// So, we can change that to let's say Mary.
// Again when reading that we can use the dot notation or the bracket notation.
// If you save the changes, now we get mary on the console.

person['name'] = 'Mary';

console.log(person['name']);
// output:
// Mary

// Now you might be asking, which approach is better?
// Dot Notation or Bracket Notation? 

// Well as you can see, dot notation is a bit more concise. 
// It's shorter, so that should be your default choice.

// However, bracket notation has it's own uses, sometimes, you don't know the name of the
// target property until the run time.

// For example, in our user interface, the user might be selecting the name of the target property.
// In that case, at the time of writing code, we don't know what property we're going to access. 
// That is going to be selected at run time by the user.

// So we might have another variable somewhere else like selection, 
// that determines the name of the target property that the user is selecting, 
// and that can change at run time.

// With this, we can access that property using the bracket notation in a dynamic way.
// So, we pass selection here, and we get the same result.


let selection = 'name';
person[selection] = 'Mary';

console.log(person['name']);
// output:
// Mary

// Now, if this is confusing, don't worry, we're going to see this again in the future, 
// as you gain more experience with JavaScript.

// For now, just stick to the dot notation, because that's cleaner and easier. 

// Next we're going to look at Arrays.




// --------------------------------------------------
// 2.6 Arrays

// Sometimes in your applications, you might be dealing with a list of objects.

// For example, the list of products in a shopping cart,
// or the list of colors the user has selected,
// In situations like that, you use an ARRAY to store that list.
// Let me show you how.

// So here I'm going to declare another variable called selectedColors. 
// Note that I'm using a meaningful name, I don't have sc or some other weird name.

// Now we can initialize this, and set it to an empty array.
// So these square brackets are what we call Array Literal, and they indicate an empty array.

let selectedColors = [];

// Now we can initialize this array and add a couple of items, like red and blue.

let selectedColors = ['red', 'blue'];

// Let's log this on the console, so Save the changes, 
// so here's our array with two elements.
// We can expand that, note that each element has an index,
// and that determines that position of the element in that array. 

console.log(selectedColors);
// output:
// 0: "red"
// 1: "blue"

// So, the index of the first element is 0, 
// and the index of the second element is 1.
// So if you want to access an element in an array, we use this index.

// Here's how. 
// For example, let's say you want to display the first element in this array, 
// we use these square brackets, and then specify the index.
// Save the changes, and now we have red.

console.log(selectedColors[0]);
// output:
// red

// Now earlier, I told you that JavaScript is a dynamic language.
// So the type of variables can change at run time. 
// The same principle applies to our arrays. 

// So the length of arrays as well as the type of objects we have in an array are dynamic, 
// they can change.

// So, on line 2, we initialize this array with 2 elements, right? 
// Now, on line 3 we can add another element to this array, so the array will expand.
// So, let's say 

selectedColors[2] = 'green';

// that means the third item in this array will also be green.
// Now, let's display this array on the console, 

let selectedColors = ['red', 'blue'];
selectedColors[2] = 'green';
console.log(selectedColors);
// output:
// (3)["red", "blue", "green"]

// so, we have an array with 3 elements. 
// So the length is dynamic, it can change

// Also the type of objects we have in this array is dynamic, 
// so unlike other programming languages, where every item or
// every object in the array, should have the same type, 
// in JavaScript we can store different types in an array. 

// So, we can make the last element a number.

selectedColors[2] = 1;
console.log(selectedColors);
// output:
// ["red", "blue", 1]

// Save the changes, now we have 2 strings and a number.

// So the objects in the array as well as the size of the array are dynamic.

// Now technically an array is an object, 
// so just like the person object we defined in the last lecture
// it has a bunch of key value pairs, or properties that we can access using the dot notation.

// Let me prove that to you.
// So here on the console, let's look at the type of selectedColors.

typeof selectedColors;
// output:
// "object"

// So the type of this array is an object.
// So an array is an object in JavaScript.

// So here on line 4, we can look at the properties of this array, or this object, 
// using the dot notation

selectedColors.         ;

// look these are  all the properties defined in arrays in JavaScript, 

// So, every time we declare an array using square brackets, 
// that array will automatically receive these properties, 
// we didn't explicitly define them, 
// they are just somehow magically inherited from somewhere else.

// We're going to learn about that later when we talk about prototypes.

// Now in this lecture, we're going to look at one of these properties.

// That is the length property.

// This property returns a number of items or elements in an array.
// So, save the changes, you can see we have three elements in this array.

console.log(selectedColours.length);
// output:
// 3


// Now later in the course, we have a comprehensive section about arrays, 
// you will learn about all kinds of operations you can perform on arrays,
// for now, all I want you to take away is

// an ARRAY, is a data structure, that we use to represent a list of items.




// --------------------------------------------------
// 2.7 Functions

// In the category of Reference Types, you have learned about Objects and Arrays. 
// Now, let's take a look at Functions.

// Functions are one of the fundamental building blocks in JavaScript. 

// A function is basically a set of statements that performs a task or calculates a value. 

// Let me show you a couple examples. 
// So I'm going to declare a function using the function keyword.

// Now we need to give it a name, let's call that greet. 

// After that we need to add parenthesis, 
// that's part of the syntax for declaring functions.
// And then curly braces.

function greet() {

}

// Now what we have here, inside the curly braces is what we refer 
// to as the BODY of this function. 
// And this is where we add all the statements to define some kind of logic in our application. 

// For example, The logic for this function should be to display a message on the console. 
// So here we can add:

function greet() {
    console.log('Hello World');
}

// Now note that here we have a statement, so we terminate it with a semi colon, 
// but when we are declaring a function, we DON'T NEED TO ADD semi colon at the END, 
// because we are not declaring it like a variable like this. Okay.

// This is a function declaration, right. 

// So, now we have a function we can call this function like this. 

// So we add the name of the function, and parenthesis again, 
// and then semi colon to indicate that this is a statement. 

greet();

// Save the changes, now we have Hello World on the console.
// But that's pretty boring, what would we do with this? 
// Let me show you how to make this more interesting.

// Our functions can have inputs, and these inputs can change how the function behaves.

// So, let's say instead of displaying Hello World 
// we want to display the name of the person here. Like Hello John.

// So we can add a variable here in between parenthesis, 
// we refer to this variable as a PARAMETER.

function greet(name) {
    console.log('Hello World');
}

greet();

// So, this greet function has one parameter called name, and essentially name is 
// like a variable that is only meaningful inside of this function.

// So inside of this function we can work with this name variable but 
// it will not be accessible outside of this function.

// Now name is an input to this function.

// So instead of displaying Hello World you can display Hello then add a plus here 
// to concatenate two strings.

// So, we can add name after.

function greet(name) {
    console.log('Hello' + name);
}

greet();

// Now, when calling the greet function, 
// we need to pass a value for the name variable,
// or name PARAMETER more accurately. 
// So, we can pass John here, 
// now we refer to this as an ARGUMENT.

// So John is an ARGUMENT to the greet function 
// and name is a PARAMETER of the greet function

// it's one of the things that a lot of programmers don't know. 
// They don't know the difference between a PARAMETER and an ARGUMENT.

// So a parameter is what we have here at the time of declaration (name),
// but the argument is the actual value of supply for that parameter ('John').

// Okay? 
// Now, I save the changes, so we have Hello John.

function greet(name) {
    console.log('Hello' + name);
}

greet('John');
// output:
// Hello John

// Now we can reuse this function but with a different input.
// So, we can change this line here and change John to Mary.
// Save the changes now we have two different messages on the console.

function greet(name) {
    console.log('Hello' + name);
}

greet('John');
greet('Mary');
// output:
// Hello John
// Hello Mary

// Now a function can have MULTIPLE PARAMETERS.
// So here we can separate parameters using a comma, so let's add another parameter, like lastName, 
// now we can change our console.log add a space here, and then display the lastName.

// Now, when calling this greet function, we should pass another argument for the last name.
// Well let's see what happens if we don't do this. 
// So I'm going to save the changes, see what we got 

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}

greet('John');
// output:
// Hello John
// undefined

// Because as I told you before that the fault value of variables in JavaScript is undefined.
// So because we did not pass a value for the last name, by default it's undefined.

// So I'm going to pass another argument here, 
// we separate them using comma John Smith 
// and we don't need this second call to the greet function.
// Save the changes, now we have Hello John Smith.

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}

greet('John', 'Smith');
// output:
// Hello John Smith




// --------------------------------------------------
// 2.8 Types of Functions

// Now there is a cleaner way to write this code on line 3, 
// all this concatenations are kind of ugly, they're getting in the way, 
// later in the course I will show you how to use template literals to 
// clean up this code. 
// For now, don't worry about it, let's look at another example of a function.

// This function we have here is performing a task. 
// This task is to display something on the console. 

function greet(name, lastName) {
    console.log('Hello' + name + ' ' + lastName);
}
greet('John', 'Smith');

// But sometimes our functions might calculate something, so, 
// here is an example of a function that calculates a value. 

// So again, function, let's call this function square, 
// this function should take a parameter, let's call that number, 
// now we need to calculate the square of that number, that is number times number.
// Just basic math. Right? 

function square(number) {
    number * number;
}

// Now we need to return this value to whoever is calling this function. 
// For that we use the RETURN KEYWORD. 
// That's another reserve keyword so we cannot have a variable called return, okay? 

function square(number) {
    return number * number;
}

// Now instead of calling the greet function, let's call the square function. 
// So, square, we pass 2, now this returns a value so we can use that value to initialize a variable.

function square(number) {
    return number * number;
}

square(2);

// For example, you can declare another variable called result, and set it to a square of 2.
// And then we can display that on the console. Save the changes, so we get 4. 

function square(number) {
    return number * number;
}

let result = square(2);
console.log(object);
// output:
// 4

// Now, in this particular example, 
// we don't necessarily have to declare a separate variable (result) 
// if all we want to do is display the square of 2 on the console. 
// We can exclude this variable declaration (let result =)
// and simply pass square(2) to console.log.

// So, when the JavaScript engine executes this code, 
// first it's going to call this function, 
// it will get a value and then pass that value to console.log.
// Save the changes and look we still get 4.

function square(number) {
    return number * number;
}

console.log(square(2));
// output:
// 4

// Now, I have a question for you. 

// How many function calls do you think we have in this code? 

// We have 2 function calls. 

// Square of 2, is one function call, 
// but console.log is also another function call, 

// right? Because here we have parenthesis, so, we're calling the log function, 
// which is defined somewhere, and passing an argument, 
// we can pass a simple string, like Hello, 
// or we can pass an expression, that expression can be a call to another function, like square of 2.
// Okay? 

// So this is the basics of functions. 
// Again, later, in the course we have a comprehensive section about functions, 

// for now, all I want you to take away is that

// a FUNCTION is a set of statements that either performs a task, 
// or calculates and returns a value. 

// A real world application is essentially a collection of hundreds or thousands 
// of functions working together to provide the functionality of that application.




// --------------------------------------------------
// 3.1 JavaScript Operators

// So you have learned how to declare variables and constants, 
// now let's take a look at OPERATORS.

// In JavaScript we have different kinds of Operators. 

// We use these operators along with our variables and constants to create expressions. 
// And with these expressions we can implement logic and algorithms.

// [Variables+Operators] --> [Expressions] --> [Algorithms]

// So here are the different kinds of operators in JavaScript. 
// We have:

// ARITHMETIC operators, 
// ASSIGNMENT operators, 
// COMPARISON operators 
// LOGICAL operators, 
// BITWISE operators. 

// Over the next few lectures, you're going to learn each of these in detail.




// --------------------------------------------------
// 3.2 Arithemetic Operators

// The first category of operators we're going to look at is ARITHMETIC OPERATORS.
// We use this for performing calculations, just like the calculations in mathematics, 
// so here we have two variables x and y, 
// let's take a look at all the arithmetic operators in JavaScript. 

let x = 10;
let y = 3;

// So I'm going to do a console.log, 
// here's the first example, x plus y, 
// that is the addition operator.

console.log(x + y);

// So these arithmetic operators usually take two up OPERANDS in this case x and y. 
// And then produce a new value.

// What we have here is "x + y" is what we refer to as an EXPRESSION in JavaScript. 

// So an EXPRESSION is something that produces a value. 

// So here's the addition operator. 

// We also have subtraction.

console.log(x - y);

// We have multiplication:

console.log(x * y);

// Division:

console.log(x / y);

// And remainder of division: 

console.log(x % y);

// So just like basic arithmetic operators in mathematics

// We have a new operator in JavaScript that is exponentiation
// it's indicated by two stars, and that is x, to the power of y. 

console.log(x ** y);

// So these are pretty straight forward 

// we have two additional arithmetic operators that are a little bit more tricky.

// So I'm going to focus on those. 
// For now I'm going to comment out these few lines, you can do that by selecting a piece of code, 
// and pressing command and / on Mac, or control and / on Windows.

// So, these two other operators, are INCREMENT and DECREMENT operators

// let's see how they work. 
// So increment is indicated by two plus signs, 
// and DEPENDING ON WHERE WE PUT the plus signs this operator will behave DIFFERENTLY.

// So I'm going to do a console.log of x, 
// x is initialized to 10, so if I save the changes, we see 10 on the console.

let x = 10;

console.log(x);
// output:
// 10

// Now, if I put the increment operator BEFORE x 
// the value of x will be incremented by 1 first 
// and then we will see that on the console.
// Let's take a look so save the changes, see we get 11.

let x = 10;

console.log(++x); // applied before
// output:
// 11

// In contrast, if you put this operator AFTER x, 
// we will see x on the console first, 
// and then the value of x will be incremented by 1. 
// Have a look, save the changes we see 10, but at this point x is incremented by 1,

let x = 10;

console.log(x++); // applied after
// output:
// 10

// so if we do another console.log of x, now we should see 11. 
// Have a look. Here it is. 

let x = 10;

console.log(x++); // applied after
console.log(x);

// output:
// 10
// 11

// The DECREMENT operator is pretty similar.
// So, instead of two plus signs, we have two minus signs, 
// and here I'm gonna apply this before x, 
// so we're going to decrement the value of x by 1, 
// and then display it on the console.

let x = 10;

console.log(--x); // applied before

// output:
// 9

// So for this demo, I'm going to comment out these two lines, have a look, 
// we see 9 on the console, because we apply this operator first and then displayed x on the console. 

let x = 10;

console.log(x--); // applied after
// output:
// 10

let x = 10;

console.log(x--); // applied after
console.log(x); // then logged
// output:
// 10
// 9

// So these are all the arithmetic operators we have in JavaScript. 

// To recap, we have 
// addition, subtraction, multiplication, division, remainder of division, 
// exponentiation which is x to the power of y, as well as increment and decrement operators.




// --------------------------------------------------
// 3.3 Assignment Operators

let x = 10;

// The second category of operators we're going to look at is Assignment Operators.

// We have already seen an example of an assignment operator. 
// So here, we are using the simple assignment operator to assign a value in this case 10 to x, 
// but we have a few more assignment operators. Let me show you. 

// So in the last lecture you learned about the increment operator.  
// With this we increment the value of x by 1. 
// This expression here is exactly equivalent to this.

x++;
x = x + 1;

// So, we read the value of x, add 1 to it, and then using the assignment operator, 
// assign this new value to x.

// But what if in this example instead of adding 1 to x we want to add let's say 5. 

x = x + 5;

// Well, this increment operator x++ will not work. 

// So, how can we do that.
// Well this is one simple way, but we have a short hand, 
// we can use the addition, assignment operator like this. 

x += 5;

// So line 5, and line 4 are exactly the same.

// Here's another example. Let's imagine we want to multiply the value of x by 3. 
// So, we can write it like this

x = x * 3

// or we can use the multiplication assignment operator like this.

x *= 3;

// So all the other arithmetic operators you learned about in the last lecture, 
// addition, subtraction, division, multiplication, and the remainder operators, 
// all of them have this combination with the assignment operator.




// --------------------------------------------------
// 3.4 Comparison Operators

// Alright now let's take a look at comparison operators. 


// As the name implies we use these operators to compare 
// the value of a variable with something else.

// So here we have x set to 1
// Let's look at the first comparison operator, that is greater than. 
// So we want to check if x is greater than 0.
// I'm going to save the changes, look what we get, true.

let x = 1;

console.log(x > 0);
// output:
// true

// So the RESULT of an EXPRESSION that INCLUDES a COMPARISON OPERATOR is a Boolean,
// it's True or False. 

// Now, let's look at another example, 
// this second operator is greater than or equal to
// so we can change 0 to 1 to see if x is greater than or equal to 1.
// Obviously it is, so save the changes to get true again.

let x = 1;

console.log(x >= 1);
// output:
// true

// The other operators are very similar.
// So we have less than as well as less than or equal to.
// Now let's save the changes. Look at what we get on the console.

let x = 1;

console.log(x < 1);
console.log(x <= 1);
// output:
// false
// true

// So the third item is false, because x is not less than 1.
// It's less than or equal to 1, that's why we got a false here.

// So these 4 operators we have here, you refer to them as RELATIONAL operators.

// We also have EQUALITY operators,

// so we can check to see if x is equal to 1.
// So we have triple equal signs.
// Save the changes, obviously x is 1, that's why we get true.

let x = 1;

console.log(x === 1);
// output:
// true

// Now if you want to check if x is not equal to a given value,
// you replace the first equal sign with an exclamation mark.
// So, let's save the changes, 
// the result of the last expression is false, because x is equal to 1.

let x = 1;

console.log(x !== 1);
// output:
// false

// So these are all the COMPARISON OPERATORS in JavaScript.




// --------------------------------------------------
// 3.5 Equality Operators

// In the last lecture you learned about the equality operator.

console.log(1 === 1);

// Now technically in JavaScript we have ANOTHER equality operator,
// that is indicated by 2 EQUAL SIGNS instead of 3 EQUAL SIGNS. 

console.log(1 == 1);

// So you might be wondering what the difference is.

// Well, first of all what we have on the top is what we refer to as STRICT EQUALITY OPERATOR.
// What we have on the bottom is what we call LOOSE EQUALITY OPERATOR. 

// Now this STRICT equality operator ENSURES that both these values we have
// on the sides of this operator have the SAME TYPE and SAME VALUE.

// What do I mean by that? 
// Well, in this example, on both sides of this operator we have two numbers. 
// so their type as well as their value are equal. 
// So if you save the changes, we get true and true. 

// Strict Equality Operator (Type + Value)
console.log(1 === 1);
// Loose Equality Operator ()
console.log(1 == 1);
// output:
// true
// true

// Now, let's take a look at another example, this time, 
// I'm going to change one of these numbers to a string. Now if I save the changes, 
// this expression is going to evaluate to false because here we're comparing a string to a number.
// So the types here do not match, that's why we'll get false.
// Let's have a look. Save, and here's false, right? 

console.log(1 === 1);
console.log('1' === 1);

// output:
// true
// false

// So the strict equality operator ensures that both operands are of the 
// same type and of the same value.

// Now LOOSE equality operator behaves DIFFERENTLY.

// So, to focus on this operator, I'm going to comment out these two lines, 
// so here we're comparing one with one, and we get true. 

// Now, what if we compare 1 as a string with 1.
// We still get true. In contrast, in a previous example, we got false. 

console.log(1 == 1);
console.log('1' == 1);
// output:
// true
// true


// So let's see what's happening here.
// In this case, this operator looks at the value on the left side. 
// Here we have a string, so it will automatically convert what we have on the right side, 
// to a string, so it will look like this, 
// and now because these values are exactly the same,
// we get true on the console.

console.log('1' == '1');
// output:
// true

// Now what if on the left side we have a boolean
// well, this operator, looks at what we have on the left side, 
// because it's a boolean, it will automatically convert the value on the right side to a boolean. 
// So, it's like comparing true with true. And if you save the changes, again we get true. 

console.log(true == 1); // console.log(true == true); CONVERTS THE 1 TO TRUE
// output:
// true

// So here's what you need to take away. 

// The STRICT EQUALITY OPERATOR ensures that BOTH VALUES have the SAME TYPE and the SAME VALUE. 

// The LOOSE EQUALITY OPERATOR doesn't care about the types matching, if the types don't match, 
// it will convert the type of what we have on the right side to match what we have on the left side. 
// And THEN it will only check if the values are equal.

// Now most of the time, we should be using the strict equality operator, because it's more
// precise and accurate.

// FINAL CODE
// Strict Equality (Type + Value)
console.log(1 === 1);
console.log('1' === 1);
// Loose Equality (Value)
console.log(1 == 1);
console.log('1' == 1);
console.log(true == 1);
// output:
// true
// false
// true
// true
// true




// --------------------------------------------------
// 3.6 Ternary Operators

// Now let's take a look at the TERNARY or CONDITIONAL OPERATOR, 
// which is one of my favorite operators in JavaScript. 

// Let's imagine we want to implement a rule like this.
// If a customer has more than 100 points, they are a gold customer
// otherwise, they are a silver customer, how do we implement this?

// Well, first I want to start by declaring a variable to keep track of the number of points. 
// So, let points we set that to let's say 110, now we want to declare another variable 
// called type that represents the type of customer, 
// and here is where we use the ternary or conditional operator.

let points = 110;

// So this is how it works, first we start with a condition. 
// We want to compare the number of points with hundred, 
// so we use the comparison operator here, points greater than 100. 

let type = points > 100 // (points > 100) IS AN EXPRESSION

// Now as you learned earlier, this expression produces a boolean.
// So the result of this expression is either true or false.

// Now depending on the result, we're going to set this type variable to a different value. 
// So here we add a question mark, now if this expression value is to true, 
// that means this is a gold customer, so we want to set type to gold.

// Otherwise, if this expression devalues to false, we want to set the type to silver.

let type = points > 100 ? 'gold' : 'silver';

// So this is the ternary or conditional operator, 
// we start with a condition, 
// if that condition evalues to true, we use this value (gold), 
// otherwise we use this other value (silver).

// Now, let's log type on the console, save the changes, so we have a gold customer,
// in contrast, if I change the number of points to 90, and save the changes, we get a silver customer.

let points = 110;
let type = points > 100 ? 'gold' : 'silver';

console.log(type);
// output:
// gold

let points = 90
let type = points > 100 ? 'gold' : 'silver';

console.log(type);
// output:
// silver




// --------------------------------------------------
// 3.7 Logical Operators with Boolean Values

// Alright now let's take a look at the LOGICAL OPERATORS. 

// We use these operators to make decisions based on multiple conditions.
// In JavaScript we have three types of logical operators, 

// LOGICAL AND  &&
// LOGICAL OR   ||
// LOGICAL NOT  ! 

// Let's see each of these operators in action. 

// So I'm going to start with the LOGICAL AND which indicated by &&
// So here's the basic rule of thumb.

// This LOGICAL AND RETURNS TRUE IF BOTH OPERANDS ARE TRUE. 

// What do I mean by that?
// Well, let's do a console.log, true and true. 

// So we have two operands, they are both true, 
// so the result of evaluating, this expression will be true. 
// Let's have a look on the console. Look, here we get true. 

console.log(true && true);
// output:
// true

// Now if either of these is false, the result will be false, 
// so I'm going to change this to false, save the changes, 
// note that we get false on the console, 

console.log(false) && true);
// output:
// false

// it doesn't matter which one is false, if I make the other one false, 
// or both of them false, we'll still get false. 

// So LOGICAL AND returns true if BOTH operands are true. 

// Now you might be asking what is a real world use case for this operator? 

// Well, let's imagine we want to build an application for approving loans.
// So we want to see if the applicant has high income and a good credit score, 
// then they will be eligible for loans. 

// So, I'm going to delete all this, and declare a couple variables, 
// high income, we're going to set that to true, 
// and good credit score, we're going to set that to true as well.

let highIncome = true;
let goodCreditScore = true;

// So here we're dealing with two conditions, 
// we want to make sure that the applicant has high income, and good credit score.

// That's where we use the LOGICAL AND.

// So we can declare another variable, eligibleForLoan 
// and this is where we use the logical and operator.
// So high income && goodCreditScore.

// Now, if we log this on the console, eligible for loan, we should get true, 
// and here's the result, 

let highIncome = true;
let goodCreditScore = true;

let eligbleForLoan = highIncome && goodCreditScore;

console.log(eligbleForLoan);
// output:
// true

// Now let's take a look at the LOGICAL OR. 
// So, LOGICAL OR is indicated by two vertical lines ||
// and this RETURNS TRUE IF ONE OF the operands is True. 
// It doesn't matter which one, whether the one on the left, or the one on the right or both of them, 
// as long as we have one true operand, the result of this expression will be true. 

// So here's an example. 
// I'm going to replace this logical and with logical or, 
// now in this case both operands are true, so the result of this expression will also be true. 
// Let's have a look. So I'm going to save the changes to get true, 
// now if I set one of these to false, we still get true.

let highIncome = true;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

console.log(eligbleForLoan);
// output:
// true


let highIncome = false;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

console.log(eligbleForLoan);
// output:
// true

// It doesn't matter which one is true.
// As long as we have one operand in this expression that evalues to true, 
// the result of this expression will also be true. 

// So this is how we use the logical or. 

// And finally, let's look at the LOGICAL NOT OPERATOR. 
// That is indicated by an exclamation mark !

// So let's imagine if the applicant is not eligibleForLoan, 
// we want to consider the application as refused.

// So we can declare another variable applicationRefused 
// here we use the NOT OPERATOR we apply it on eligibleForLoan, 

let highIncome = false;
let goodCreditScore = true;

let eligbleForLoan = highIncome || goodCreditScore;

let applicationRefused = !eligbleForLoan; // this converts it to the opposite

console.log(eligbleForLoan);
// output:
// true

// so this is what happens here..
// If eligibleForloan is true, this not operator will convert that to false.

// So whatever we give it, it will give us the opposite, 
// in this case if eligibleForLoan is true, this will convert that to false, 
// and applicationRefused will be false.

// Because if someone is eligible for a loan, we don't want to refuse their application, right?

// So applicationRefused, is always the opposite of eligibleForLoan, 
// and that's where we used the NOT OPERATOR. 

// So let's see this in action. I'm going to change both these conditions to false. 
// So we're dealing with someone who has low income and a bad credit score, 
// obviously they are not eligible for a loan, so let's log this on the console,
// eligibleForLoan, and we can also add a label so I'm going to add a string, Eligible, 
// and here we add comma, then we apply the not operator, to set the application refused variable, 
// let's do another console.log, application refused, and here we log application refused variable.
// Now let's see what we get on the console, so save the changes

let highIncome = false;
let goodCreditScore = false;

let eligbleForLoan = highIncome || goodCreditScore;

console.log('Eligible', eligbleForLoan);

let applicationRefused = !eligbleForLoan; // this converts it to the opposite

console.log('Application Refused', applicationRefused);
// output:
// Eligible false
// Application Refused true

// you can see if this applicant is not eligible because eligible is false, 
// and application refused is true because it's always the opposite of eligible for loan.




// --------------------------------------------------
// 3.8 Logical Operators with Non-Boolean Values

// In the last lecture you learned about logical operators, 
// in all the examples you saw in the last lecture, 
// we used these logical operators with boolean values. 

// But in JavaScript, UNLIKE in many programming languages, 
// WE CAN USE THESE LOGICAL OPERTORS WITH NON BOOLEAN VALUES.
// And that's extremely powerful. 

// Let me show you a few examples.
// Let's say we have false or true.
// What do you think is the result of this expression? 
// Well, it's true, right?

false || true
// output:
// true

// Now what if we have false or the string Mosh? 
// What do you think is the result of this expression? 
// Well let's take a look, we get Mosh back

false || 'Mosh'
// output:
// "Mosh"

// what if we have false or number 1? 
// We get number 1 back.

false || 1
// output:
// 1

// So here's the first thing you need to realize, 
// THE RESULT OF A LOGICAL EXPRESSION IS NOT NECCESSARILY a true or a false.
// That DEPENDS on the VALUE of the OPERANDS we have. 

// In the first example our second operand is true, that's why we get true back.
// In the second example, our second operand is a string, that's why we get a string back, 
// and by the same token, in the third example. We get a number back. 

// So when our JavaScript engine tries to evaluate this expression, 
// it looks at each operand, if that operand is not a boolean true or false, 
// it will TRY TO INTERPRET IT AS TRUTHY OR FALSY, 

// so in JavaScript we have these values which we refer to as FALSY, 
// that's NOT a boolean false, it's FALSY.

// What are these Falsy values? Well we have:
undefined
null
0 // number 0
false // boolean false
'' // an empty string
NaN // Not a Number

// Now we haven't talked about this yet, that's going to come later in the course, 
// for now, just remember, Not a Number is a special value in JavaScript, 
// and when we are dealing with a mathematical calculation that does not produce a valid number,
// this value is returned, NaN "Not a Number". 
// Now we're going to look at that later in the course, so don't worry about it. 

// So these are the Falsy values in JavaScript, 
// IF WE USE ANY OF THESE VALUES IN A LOGICAL EXPRESSION THEY WILL BE TREATED AS FALSY
// which is kind of like a boolean false, but it's not exactly the same.

// Now, ANYTHING THAT IS NOT Falsy IS Truthy.

// So, back to these examples.

// In the second example, our second operand is a string with 4 characters.

false || 'Mosh'
// output:
// "Mosh"

// Truthy

// So this is not an empty string, it's not Falsy, so it's Truthy. 
// So when our JavaScript engine tries to evaluate this, it looks at the first operand
// it's false, so the search continues, because with a logical or operator, 
// as you learned in the last lecture, as long as one of the operands is true 
// the result will be true. 

// Now here in the second example, the first operand is false, so the search continues
// hoping that maybe the other operand is true or Truthy.

// In this case 'Mosh' we are dealing with a Truthy value, 
// so this value is immediately returned. 

// The same goes for third example. So here 1 is not a boolean true, it's Truthy,
// that's why the value of this operand is returned.

false || 1
// output:
// 1

// Truthy

// Now, what if we have an expression like this

false || 1 || 2
// output:
// 1

// What do you think we're going to get? Let's take a look. You get 1. 

// So this is another thing you need to understand about the logical or operator. 
// The EVALUATION starts here (at the false), AS SOON AS WE FIND AN OPERAND THAT IS TRUTHY,
// THAT OPERAND IS RETURNED, so here our second operand (1) is Truthy, 
// it's value is returned, and here the evaluation stops (at the 1).

// It doesn't matter what we have on the right side (2 etc), 
// we could have a million other operands, they are completely ignored, 
// this is what we call SHORT-CIRCUITING. 
// Just exactly like short circuiting that we have in electricity.

// Now that you understand how these logical operators work with non-boolean values,
// let me give you a real world example on when to use this. 

// So let's imagine an application, and somewhere the user has to pick a color, 
// or we're going to use a default color.
// Maybe this is the color of the t-shirt they want to buy. 

// So, I'm going to declare a few variables, userColor. We set that to red, 
// defaultColor we set that to blue, 
// and currentColor, which we set to userColor or defaultColor. 

let userColor = 'red';
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

// Now let's read this exprsssion in plain English. 
// userColor or defaultColor that basically means 
// if we have a value for userColor we're going to use that,
// if we don't, we're going to use the defaultColor.
// Now, let's log this on the console.

let userColor = 'red';
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

console.log(currentColor);
// output:
// red

// So currentColor we get red.
// Because our user has selected a color.

// In contrast, if the user has not selected a color, let's set this to undefined,
// save the changes, we get blue. Because defaultColor is blue.

let userColor = undefined;
let defaultColor = 'blue';
let currentColor = userColor || defaultColor;

console.log(currentColor);
// output:
// blue

// So this is the POWEER OF USING THE LOGICAL OR OPERATOR, BETWEEN NON-BOOLEANS.
// With this technique, we can provide default values.

// So if the user has selected a color, we're going to use that 
// otherwise we're going to use our defaultColor and that determines
// the current color which we are going to display on the screen.




// --------------------------------------------------
// 3.9 Bitwise Operators

// Finally, the last group of operators we're going to look at is BITWISE OPERATORS.

// Now, this really requires me to go beyond the scope of this course, 
// I have to talk about some computer science stuff, 
// and honestly I don't really want to bore you, 
// because this stuff doesn't really have that much practical usage in the real world, 
// I'm not saying they're useless, they definitely have their own use, 
// but they are more on the theoretical side 
// and it's not something that you will use on a daily basis. 

// However, if you're really enthusiastic, 
// I'm going to explain what bitwise operators are, 
// and how they work, but feel free to skip this lecture if you just want to focus on the practicality. 

// So you know that we humans use the decimal system to represent numbers. 
// So 12345. 
// But in computers, these numbers are stored in the binary format, 
// which is a combination of 0's and 1's. 

// So let's take a look at a few examples. 
// The number 1 in the decimal system, is represented as 
1 = 00000001

// So we have 8 digits, each digit is what we call a bit, 
// so here we have 8 bits, which represents 1 byte of information in a computer. 

// Here's another example. 
// Number 2 in the decimal system equals to 
2 = 00000010

// There are mathematical formulas behind this, for converting numbers between decimal
// and binary systems, if you don't want to learn the mathematics, you can simply
// Google decimal to binary converter.

// Now, bitwise operators in JavaScript or any other programming languages, 
// are similar to logical operators, but they work in the individual bits of a number.

// Let me show you what I mean by this.

// So, I'm going to do

console.log(1 | 2);

// Note that here we have a single vertical line |
// that represents a Bitwise OR 
// logical or's have double vertical lines ||

// So when we apply the BITWISE OR between 1 and 2, 
// this is what's going to happen. 
// So, I add r as the result here.

1 = 0000001
2 = 0000010

R = 0000011

// Now, this operator is going to look at each of these bits like this,
// in a vertical way, 
// if either of these bits is 1, the result will be 1, otherwise it will be 0. 
// So here, in both these numbers, the first 6 bits are 0, 
// so, in the result you also have 6 0's.

// Now the 7th bit will be 1, because here (at the 7th digit of 2) 
// we have 1 at this position, right? 
// And similarly, the 8th bit will be 1, because here (at the 8th digit of 1) 
// we have a 1.
// Now if we convert this binary number to a decimal number the result will be 3. 

// So let's save the changes and you can see on the console we have 3.

console.log(1 | 2);
// output:
// 3


// Bitwise AND is similar.
// So let's duplicate this, BITWISE AND will use a single ampersand for that &

console.log(1 & 2);

// Now the result is going to be something like this.
// So, if both numbers are 1, 1 will be returned otherwise will be 0. 

1 = 0000001
2 = 0000010

R = 0000000

// So in this case all the bits will end up being 0, 
// because if you look if you look at these two first numbers, 1 and 2,
// their first 6 bits are 0,
// and here in the second number (2) we have this bit that is 1 (at the 7th digit of 2),
// but the bit at the equivalent position (at the 7th digit of 1) here is 0. 

// So if we apply the Bitwise AND between these two bits the results will be 0, okay?
// So, this binary number equals 0 in the decimal system. 
// So save the changes, and see this on the console. Save, here it is.

console.log(1 & 2);
// output:
// 0

// So this is the fundamentals of BITWISE OPERATORS.
// Now in JavaScript we have a few more bitwise operators,
// but in the real world they are not that common.

// Now let me give you a real world example of when we can use these bitwise operators 
// so at least they make sense to you.

// Imagine we want to implement an access control system. 
// So the user can have these permissions, read, write or execute.

// Now we can use 1 BYTE of information, or 8 BITS, to determine the kind of information
// a user can have. For example, we can use 5 0's, we don't care about the first 5 bits, 
// but for the other 3 bits, if the user has a permission we will use 1, 
// otherwise we will use 0.

// So if the user has only the read permission, you will use 1 for the read, 
// and for write and execute you will use 0.

Read = 00000100

// Similarly if the user has read and write permissions.
// We can represent this permission using this binary number. 

Write = 00000110

// And finally if the user has all these permissions. 
// We can represent that like this.

Execute = 00000111

// Now, this is where we use bitwise operators.

// Let's see how we can implement these access control system, using bitwise operators.

// So, I'm going to define a constant called readPermission,
// now I need to set this to a decimal number that is equivalent to this binary number.
// That decimal number is 4.
// Again, you can use an online converter to get this.

// just the Read flag on = 00000100

const readPermission = 4;

// Similarly I'm going to define another constant, writePermission
// now what I want now is the decimal representation of this binary number.
// So all these bits or flags are off, only the right flag is on it, okay? 

// just the Write flag on = 00000010

const writePermission = 2

// So this binary number, is equivalent to 2 in the decimal system.

// And finally, executePermission.
// So what we want is the decimal representation of this binary number.
// All these flags are 0, oney the execute flag or execute bit is 1. 
// And that number is 1.

// just the Execute flag on = 00000001

const executePermission = 1;

// Now, I can declare a variable like myPermission inititally set that to 0, 
// now I can give myself extra permissions.

let myPermission = 0;

// So, I can update my permission like this, myPermission, here we apply the bit
// wise or to add a permission like readPermission, as well as the writePermission.

myPermission = myPermission | readPermission | writePermission;

// Now let's take a look at the value of my permission on the console.
// So, we get 6. 

console.log(myPermission);
// output:
// 6

// Now technically, we don't care about this decimal number, 
// we can use the bitwise and operator to see if I have a given permission.

// So here's an example, I'm going to declare a variable, 
// let's call that message, now here I'm going to use the ternary operator, 
// the conditional operator, remember? 

// So we start with a condition, we take myPermission, 
// and use the bitwise and operator along with readPermission.

let message = (myPermission & readPermission)

// Now, if this evalues to true, that means I have the readPermission.
// So, let's say you want to display a message like yes, otherwise we want to display no.

let message = (myPermission & readPermission) ? 'yes' : 'no';

// So here's our ternary operator.
// You have a condition, if that evalues to true, this value will be used, 
// otherwise this value will be used.

// Finally, let's log this message on the console.

console.log(message);
// output:
// yes

// So I have the readPermission. 
// But if I move this readPermission here, and save the changes. 
// Now, you can see our readPermission is gone.

const readPermission = 4;
const writePermission = 2;
const executePermission = 1;

let myPermission = 0;
myPermission = myPermission | writePermission // readPermission deleted

let message = (myPermission & readPermission) ? 'yes' : 'no';

console.log(message);
// output:
// no

// So here's what I want you to take away. 

// With the Bitwise OR operator, we can add permissions, 
// and with the Bitwise AND operator, we can check to see if we have a given permission.

// Of course this is just 1 real world use case for using the bitwise operators, 
// there are other use cases but as I told you before, they are really not that common, 
// so if this lecture was confusing, don't worry about it.




// --------------------------------------------------
// 3.10 Operators Precedence

// When working with complex expressions, 
// one thing that you need to account for is the PRECENDENCE OF OPERATORS. 

// Let me show you an example. 
// So, let's declare x and set it to 2, plus 3 x 4.

let x = 2 + 3 * 4;

// What do you think is the result of this expression. 
// Well, let's log this and have a look. So, we get 14. 

let x = 2 + 3 * 4;

console.log(x);
// output:
// 14

// The reason for that is because the multiplication operator has HIGHER PRECEDENCE 
// so this expression is evaluated first, so 3 x 4 is 12, and then the result is added to 2.

// Now, all these operators you have learned in this section, they have their own precedence. 

// It's really hard to memorize which operators have HIGHER PRECEDENCE or LOWER PRECEDENCE . 
// So when working with complex expressions you can USE PARENTHESIS  
// to determine HOW these operators are applied. 

// For example, here we can put parenthesis around 2 plus 3,
// and this means this expression is evaluated first, 
// so we get 5, and then the result is multiplied by 4. 
// So now if we save the changes we get 20.

let x = (2 + 3) * 4;

console.log(x);
// output:
// 20




// --------------------------------------------------
// 3.12 Exercise

let a = 'red';
let b = 'blue';

console.log(a);
console.log(b);

// Alright let's finish this section with a simple programming exercise. 
// Let's declare 2 variables, and set it to red, and b, set it to blue. 
// Now when we log these on the console, obviously we're going to get red and blue. 
// Right? 

// Now what I want you to do, is to write some code here to swap the value of
// these two variables. 

// So when we log these on the console, instead of getting red and blue, 
// we're going to get blue and red. 

// So pause the video, spend a couple of minutes on this exercise, when you are done come
// back and continue watching.

let a = 'red';
let b = 'blue';

let c = a;
a = b;
b = c;

console.log(a);
console.log(b);

// Alright to swap the value of two variables we need a third variable.
// So we're going to declare another variable let's call it c, we're going to use that as a backup.

// So whatever you're storing in a, we're going to put that in another variable that is c, 
// then we're going to copy b to a and finally what we have in c, 
// which was the value of a before we're going to copy that to b. 

// Let me show you. So we declare c, and set it to a.
// So what we have in a which is red will be copied to c. 

// Now we want to overwrite a with b. So we set a to be.
// The value of b is copied to a, now both these variables at this point are blue.

// Finally we're going to copy what we have with c which is the original value of a, we're going to copy that to b. 
// So we set b to c, now, when we save the changes, instead of red and blue we're going to see blue and red. 

// So this proves that we have swapped the value of these two variables.
// Now if you couldn't do this exercise, don't worry, this is because you have not trained your programming brain.
// And this requires a bit of time. Just like some one who wants to go to the gym, they are not going to build muscle on day 1.
// It requires time and effort.

// Now to help you train your programming brain, I have designed lots of exercises for you in this course, 
// so, as you go through these exercises and look at my solutions, you'll start to pick up some patterns and techniques to solve programming problems.
// So once again, if you couldn't do this exercise, don't be disappointed, that's perfectly fine.




// --------------------------------------------------
// 4.1 If...else

// In the last section you learned about expressions and operators. 

// In this section we're going to use these expressions and operators 
// along with CONDITIONAL STATEMENTS to implement interactivity in our applications. 

// In JavaScript we have TWO types of CONDITIONAL statements, we have:

// If ... else

// and 

// Switch ... case

// You're going to learn about if and else in this lecture, 
// and we'll look at switch and case in the next lecture.

// So imagine in our application we're going to get the current hour 
// and depending on it's value, we're going to greet the user with a different message

// so if the hour is between let's say 6am and 12pm, you display something like good morning. 
// Similarly, if it is between 12pm and 6pm we're going to display good afternoon. 
// Otherwise we're going to display good evening. 
// So we want to have some logic like this in our application.

// That's where we use if and else. 

// So we start with the IF, then we add parenthesis.

if (); // IGNORE ; 

// And in between these parenthesis, we add a condition. 

if (condition)
    statement

// If this condition evaluates to true, the statement we put after will be executed. 

// Now if you have multiple statements, we need to put them in between these curly braces. 
// We refer to these as a BLOCK of code. Okay? 

if (condition) {
    statement
}

// Now optionally, we can have another condition so we write ELSE IF 
// once again parenthesis, anotherCondition. 
// Now, if this condition is true, then this other statement will be executed

if (condition) {
    statement
}

else if (anotherCondition)
    statement

// and similarly, if we have multiple statements, 
// we need to surround them with curly braces. Like this: 

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}

// Also note that as a convention, when we want to define a block of code,
// we put the first curly brace on the same line, not here (on a new line below),
// that's kind of ugly in JavaScript, so take that into account,

// now back to our if and else, we could have yet another condition like this, 
// yetAnotherCondition, we could have as many conditions as we want, there is no limitation.
// And once again here we have 1 or more statements

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}
else if (yetAnotherCondition)
    statement

// now optionally if none of these conditions evaluate to true, 
// we could use else to execute 1 or more other statements.

if (condition) {
    statement
}
else if (anotherCondition) {
    statement
}
else if (yetAnotherCondition)
    statement
else
    statement

// So this is the basic structure. 

// Now, we want to get this logic and map it into this structure.
// It's very easy. 

// So let's start with our first condition. 
// If hour is between 6am and 12 pm, so that's the condition, 
// and the statement we want to execute is good morning, okay?
// So I'm going to declare a variable here, hour and set it to 10, 
// now in a real world application we want to read the current hour. 
// For now, let's not worry about getting the current time and hard code this number here, 10.

// So we want to compare the value of hour with these two numbers. 

// Now for simplicity, let's go with 24 hour time format 
// so we want to see if hour is greater than or equal to 6, and hour is less than 12.

if (hour >= 6 && hour < 12); // IGNORE ;

// You learned this in the last section, right?
// So here we're using this COMPARISON OPERATOR, we have two EXPRESSIONS, 
// here's the first one, here's the second one, and we're applying the LOGICAL AND in between them.

// So, if both these expressions evaluate to true, 
// then the result of this expression will also be true. 

// Now let's add the statement. You want to display good morning.
// And of course we need to terminate this statement with a semi colon. 

if (hour >= 6 && hour < 12) {
    console.log('Good morning');
}

// Now here's my suggestion for you. If you want to master JavaScript pause the video now and continue implementing this logic
// using if and else then come back continue watching and see my solution.

let hour = 10;

if (hour >= 6 && hour < 12) {
    console.log('Good morning');
}
else if (hour >= 12 && hour < 18) {
    console.log('Good afternoon');
}
else {
    console.log('Good evening');
}

// Alright let's continue. Here's a second condition. 

// You want to check to see if hour is between 12 and 18. 
// So, very easy. 
// If hour is greater than or equal to 12, and it's less than 18. 
// We want to display good afternoon. So console.log good afternoon.

// Now in this example, we don't need this other else if because otherwise 
// we want to display good evening. So let's delete this, we do a console.log
// of good evening. 

// Now in this example, because we're dealing with a single statement
// these curly braces are getting in the way and creating noise in the code.
// So it's better to get rid of them and simplify the code, here's another pair, okay, that's better.
// Now save the changes, we get good morning here

let hour = 10;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good morning

// If I change the hour to 13, we get good afternoon, 
// and if I change this to 20, we get good evening.

let hour = 13;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good afternoon

let hour = 20;

if (hour >= 6 && hour < 12)
    console.log('Good morning');
else if (hour >= 12 && hour < 18)
    console.log('Good afternoon');
else
    console.log('Good evening');

// output:
// Good evening

// So this is all about IF and ELSE. 

// In the next lecture, you're going to learn about switch and case.




// --------------------------------------------------
// 4.2 Switch...case

// Alright, now let's take a look at SWITCH and CASE. 

// So let's start by declaring a variable called role. 

let role;

// Let's imagine this represents the role of the current user. 
// Now we want to see if this user is a guest, or a moderator or an admin.

// We can easily implement this logic, using a bunch of if and else statements.
// But there is another way, using SWITCH and CASE.

// So let's have a look. 
// We start with this SWITCH statement, we add parenthesis, 
// but INSTEAD of adding a condition here, we add a VARIABLE,
// in this case we're going to add the role variable. 

let role;

switch (role)

// Now we add curly braces, 

let role;

switch (role) {

}

// then we add one or more case statements, 
// each case statement is used to compare the value of this variable with something.

// So, here's our first case. 

let role;

switch (role) {
    case:
}

// If this role equals guest, so I'm COMPARING the value of role with guest,

let role;

switch (role) {
    case 'guest':
}

// now we add colon, and then after that we add one or more statements. 

let role;

switch (role) {
    case 'guest':

}

// So, we can do a console.log guest user. Like this.

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
}

// Now here we need to add the BREAK statement. 
// So we jump out of this switch block. 

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;
}


// Otherwise the other statements here will be executed, let me show you.

// So, we need to add another case statement. 
// If this user is a moderator, we want to display console.log Moderator User
// once again we need to add the BREAK

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;
}

// so in this case, if I don't add this break statement here (after guest), 
// and the role equals guest, both these console.log statements will be executed. 

let role;

switch (role) {
    case 'guest':
        console.log('Guest User');
    // break; deleted here

    case 'moderator':
        console.log('Moderator User');
        break;
}
// output:
// Guest User
// Moderator User

// That's why we need to add a BREAK TO JUMP OUT OF this switch block, right?

// Now, we can have as many case statements here there is no limitation. 

// Optionally, if none of these cases are matched, 
// we can have a DEFAULT STATEMENT and execute 1 or more statements 
// so console.log, Unknown User. Or more accurately, unknown role. 

switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
    // dont need a break here because the control auto exits the block here
}

// Now here FOR THE DEFAULLT STATEMENT WE DON'T NEED A BREAK, 
// because at this point THE CONTROL WILL AUTOMATICALLY GET OUT OF THIS SWITCH BLOCK.
// Alright, so, let's save the changes and see what we get on the console.
// Save. We get Unknown User, because I have not initialized role, 
// so it's default value is undefined and it doesn't match any of these case statements. 

// Now if I change role to guest, save the changes, we get guest user

let role = 'guest';
switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
}
// output:
// Guest User

// and similarly if I change role to moderator, we get the moderator user message. 

let role = 'moderator';
switch (role) {
    case 'guest':
        console.log('Guest User');
        break;

    case 'moderator':
        console.log('Moderator User');
        break;

    default:
        console.log('Unknown User');
}
// output:
// Moderator User

// So here's the takeaway:

// With switch and case, 
// we can compare the value of a variable (role) against a bunch of other values (guest/moderator etc). 

// Now they don't have to be string, they can be numbers or even booleans. 
// But using booleans here is less common. 
// Because if you want to compare the value of a variable with true or false, 
// it makes more sense to use an if statement. 

// Now just to let you know we can implement this exact logic using 
// if and else statements, Let me show you.

// So, if role equals guest, note that I'm using strict equality here, 
// so triple equal signs, and that means we're checking the type and value of this variable 
// against what we have on the right side. 

// So, if role is guest we want to do a console.log of guest or guest user. 
// Else if role equals moderator then then we're going to do a console.log of moderator
// finally else if the role is something else we want to display unknown user. 

if (role === 'guest') console.log('Guest');
else if (role === 'moderator') console.log('Moderator');
else console.log('Unknown User');

// Now compare these two implementations 
// you can see implementing this logic with if and else is cleaner and shorter, 
// we don't have all these break statements or default, 
// or these curly braces, these are extra noise in the code. 

// So it doesn't mean you should never use switch and case, ...well it depends who you ask. 
// I personally tend to use if and else more often, switch and case are kind of outdated, 
// they look a little bit ugly, in my personal opinion. 
// But there is nothing terribly wrong with them, sometimes they are more explicit. 
// It comes back to your personal preference.




// --------------------------------------------------
// 4.3 For

// Sometimes we want to repeat an action a number of times. 
// For example, let's imagine we want to display hello world 5 times on the console.
// The poor way of doing that is like this.
// So console.log hello world, and then repeat it five times. 

console.log('Hello World');
console.log('Hello World');
console.log('Hello World');
console.log('Hello World');
console.log('Hello World');

// This code is ugly, there is a better way to achieve the same result, 
// and that's where we use LOOPS.

// In JavaScript we have various kinds of loops, 
// and all these loops essentially do the same thing. 

// THEY REPEAT AN ACTION A NUMBER OF TIMES

// We have:

// For          loops
// While        loops
// Do...While   loops
// For...In     loops
// For...Of     loops 

// All these loops essentially do the same thing. 
// But there is a SUBTLE DIFFERENCE BETWEEN HOW THEY START AND END. 
// Let's start by looking at the for loop. 

// So, back to this code, this is how we write a for loop, so for we add parenthesis, 

// and here we need 3 statements. 
// The FIRST statement is what we call INITIAL EXPRESSION. 
// And here we declare an initialized variable. 
// So, we use let to declare a variable like i and set it to 0. 

for (initialExpression; condition; incrementExpression) {
    statement;
}

// Now i is short for index and is a common convention to use in for loops. 
// This is what we call the LOOP VARIABLE.
// So we initialize it to 0, then we terminate this statement with a semi-colon,

for (let i = 0;) {
}

// and the SECOND part of the for loop is what we call a CONDITION.
// so here we want to add a condition and compare the value of i with something else. 

for (let i = 0; condition;) {
}

// This loop will run as long as this condition evaluates to true. 

// So if you want this loop to run 5 times, we compare i with 5. 
// So as long as i is less than 5, this loop will execute. 
// You will see that in a second.

for (let i = 0; i < 5;) {
}

// Once again, we terminate this statement with a semi colon, 

for (let i = 0; i < 5; incrementExpression) {
}

// and finally the THIRD PART. This is what we call INCREMENT EXPRESSION,
// and quite often what we have here is something like this.
// So, we use the increment operator to increment the value of i with 1.

for (let i = 0; i < 5; i++) {
}

// Now, after this for statement we can add 1 or more statements, 
// just like the if statements if you have multiple statements here, 
// you need to put them in code block. Like this.

for (let i = 0; i < 5; i++) {
    statement
}

// Now here we want to display hello world on the console. 
// So our statement is console.log Hello World.
// So instead of repeating this line 5 times, we put it in a for loop, 
// and this loop will run 5 times. 
// Now, save the changes, so we get 5 Hello World messages, on the console. 

for (let i = 0; i < 5; i++) {
    console.log('Hello World')
}
// output:
// Hello World
// Hello World
// Hello World
// Hello World
// Hello World


// Alright now that you have seen a for loop reaction,
// let's see exactly how this loop works. 

// So earlier I told you this is what we call an INITIAL EXPRESSION, 
// here we're initializing i to 0, ( let i = 0 )

// now this loop will execute AS LONG AS this condition ( i < 5 ) is true. 
// So as long as i is less than 5, the statements we have here 
// ( console.log 'Hello World' ) will be executed. 

// Now, after the first iteration, i is incremented by 1. 
// THEN this CONDITION IS EVALUATED AGAIN, so 1 is less than 5, 
// so one more time, this loop is executed so we have the second iteration,
// now after the second iteration, once again, i is incremented by 1,
// so now we are in the third iteration. 
// Again, this condition is evaluated, and because it is true, the loop is executed.

// To show you this in action, I'm going to output i on the console. 
// So, save the changes, this is what we get.

for (let i = 0; i < 5; i++) {
    console.log('Hello World', i)
}
// output:
// Hello World 0
// Hello World 1
// Hello World 2
// Hello World 3
// Hello World 4

// So note that in the first iteration i is 0, 
// then is incremented by 1 until it reaches 4. 
// So at the end of the 5th iteration i will be 4, 
// and when we increment that by 1, it will be 5, 
// so this condition ( i < 5 ) will evaluate to false. 

// So essentially there are two ways to repeat an action a number of times
// using the for loop. 

// Let's say we want to repeat something 5 times, we can initialize i to 0, 
// and check to see if it's less than 5. 
// Alternatively, we can initialize this to 1, 
// and check to see if it's less than or equal to 5.
// Now, if you save the changes, you can see i starts from 1, and finishes at 5. 

for (let i = 1; i <= 5; i++) {
    console.log('Hello World', i)
}
// output:
// Hello World 1
// Hello World 2
// Hello World 3
// Hello World 4
// Hello World 5

// Now we can make this program a bit more interesting. 
// Let's say we want to display the odd numbers between 1 to 5. 

// So instead of logging Hello World in the console, 
// we can have an if statement and check the remainder of the division of i by 2.

// So, if the remainder of division of i by 2 is not 0, that means i is an odd number. 
// So we can display it on the console. 
// Save the changes, so here are the odd numbers between one and five. 

for (let i = 1; i <= 5; i++) {
    if (i % 2 !== 0) console.log(i);
}
// output:
// 1
// 3
// 5

// There is also another way to write this loop. 
// Instead if starting from 1 and going all the way to 5, 
// we can start from 5 and go back to 1. 
// So, we change the initial expression, set i to 5, 
// as long as i is greater than or equal to 1, now we want to decrement i.
// Save the changes. Now we get the odd numbers in the reverse order.

for (let i = 5; i >= 1; i--) {
    if (i % 2 !== 0) console.log(i);
}
// output:
// 5
// 3
// 1

// It's more common to use the previous form, 
// so we initialize i to 0 or 1 and increment it in every iteration. 
// But in certain problems, you want to use the for loop in reverse order.




// --------------------------------------------------
// 4.4 While

// In the last lecture, we wrote this for loop to display all the odd numbers
// between 0 and 5. 

// And in this lecture, I'm going to show you how to implement 
// the same logic by using a while loop. 

// Now one key difference between a while loop and a for loop 
// is that IN FOR LOOPS THE LOOP VARIABLE ( let i = 0; ) IS PART OF THE LOOP ITSELF.

// For Loop
for (let i = 0; i <= 5; i++) {
    if (i % 2 !== 0) console.log(i);
}

// But IN WHILE LOOPS YOU HAVE TO DECLARE THIS WHILE VARIABLE EXTERNALLY. 
// Let me show you what I mean. 
// So we start with declaring a variable like i and set it to 0. 

// While Loop
let i = 0;

// Note that this i we have here is different from the i we have in this for loop,
// because this variable is only meaningful and accessible inside of this for loop. 

// This is called scope, and I'm going to talk about it later in the course, 
// all I want you to know is that these two variables are completely different, 
// even though their names are the same. 

// Now, we have our loop variable initialized to 0.
// Next we add a while statement, 
// in parenthesis we need to add our condition. 

let i = 0;
while (condition) { }

// What is the condition here? 
// That is i less than or equal to 5. 
// So I'm going to add that here.

let i = 0;
while (i <= 5) {

}

// Next, we need to add our statements. 
// So what is the statement that we want to repeat, 
// here's the statement, we want to display the odd numbers, 
// so we add that here as well,

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
}

// and finally, at the end of this while block we need to increment i.

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}

// So this is a DIRECT TRANSLATION of this for loop INTO a while loop.

// So this is what happens when we execute this code. 

let i = 0; // Initially i is 0, 
while (i <= 5) { // now in the while loop, first this condition is evaluated, 
    if (i % 2 !== 0) console.log(i);  // if this condition is true,
    i++;                              // then the body of the while loop will be executed. 
}

// Again, in the next iteration the condition is evaluated again, 
// if it's true, the statements in the while BLOCK will be executed, 
// otherwise the while block will terminate. 

// In the next lecture we're going to look at another kind of loop in JavaScript.




// --------------------------------------------------
// 4.4 Do While

// Alright now let's take a look at the third kind of loop we have in JavaScript.
// That is a Do While loop. 

// Do While loops are very similar to while loops, 
// but they're slightly different. 

// It's easier to show you in code. 

// So I'm going to REWRITE this WHILE LOOP using a DO WHILE LOOP. 

// let i = 0;
// while (i <= 5) {
//     if (i % 2 !== 0) console.log(i);
//     i++;
// }

// Just like the while loops, WE HAVE TO DECLARE OUR LOOP VARIABLE EXTERNALLY, 
// so we declare i and initialize it to 0. 
// So we add the do statement here, then a code block, 
// in this block we should have our statements. 

let i = 0;
do {

}

// So I'm going to borrow them from our while loop, copy these, paste them here,

let i = 0;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
}

// and then finally at the end of this block,
// we add the while statement along with our condition. 
// That is i less than or equal to 5, followed by a semi colon.

let i = 0;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
} while (i <= 5);

// Now you might be wondering WHAT IS THE DIFFERENCE between a WHILE loop and a DO WHILE loop
// DO WHILE loops ARE ALWAYS EXECUTED AT LEAST ONCE.
// EVEN IF this condition (while (i <= 5)) evaluates to false. 

// Let me show you what I mean.

// So I'm going to temporarily comment out these few lines. 
// And bring back our while loop.
// Now if you save the changes, we get 1, 3, 5 on the console. 

let i = 0;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}
// output:
// 1
// 3
// 5

// However, if I change i to 9, we are not going to see anything, 
// because the first time we try to execute this while loop, 
// this condition evaluates to false.

let i = 9;
while (i <= 5) {
    if (i % 2 !== 0) console.log(i);
    i++;
}
// output:
// nothing

// So these statements (inside the while block) ARE NEVER EXECUTED. 
// So save the changes, look, there's nothing in the console.

// So in WHILE loops, THIS CONDITION (i <= 5) IS EVALUATED AHEAD OF TIME.
// AT THE BEGINNING OF EVERY ITERATION. 

// In contrast in DO WHILE loops, THIS CONDITION IS EVALUATED AT THE END. 
// And that means THESE STATEMENTS (inside the do block) ARE ALWAYS EXECUTED AT LEAST ONCE. 
// Even if the condition is false. 

// So let's try this, I'm going to comment out this while loop,
// and change i to 9, just like before. Save the changes, we get 9 on the console

let i = 9;
do {
    if (i % 2 !== 0) console.log(i);
    i++;
} while (i <= 5);
// output:
// 9

// Why? Because in our do-while loop here, on line 15, 
// we check to see if this is an odd-number it is, and display it on the console. 

// Next, we increment i by 1, so i, is 10. 
// Then, the condition is evaluated, of course it's false. 

// So our loop will terminate. 

// Now, realistically we're not going to use these Do While a lot in programming,
// there are situations you may want to use this, but in practical terms,
// most of the time you will be using a for or while loop. 

// Just be aware of the difference between a while loop and a do while loop.




// --------------------------------------------------
// 4.5 Infinite Loops

// When writing loops something that you need to be aware of 
// is what we call an INFINITE LOOP.

// So an infinite loop as the name implies, executes infinitely or forever. 

// So if you accidentally create one of these loops, 
// you're going to crash your browser or your computer. 

// Let me show you an example. 
// So here I'm going to declare a variable, set it to 0, 
// put it in a while loop, so as long as i is less than 5, 
// we're going to do a console.log, of i,
// now here technically we should increment i, 
// but if you forget to do so, you END UP CREATING AN INFINITE LOOP, 
// because in the first iteration, i is 0. 
// And it's less than 5, so will display an i on the console.

let i = 0;
while (i < 5) {
    console.log(i);
    //i++;
}

// Now, in the second iteration i is still 0, and is less than 5.
// So this loop could run forever. Let me show you.

// So I'm going to save the changes, 
// now on the console, this number you see before 0 
// is the number of times you're displaying 0 on the console,
// so you can see this number is increasing rapidly so far we have displayed 0, 
// more than 35 hundred times.

// And if you look at the browser, you can see this spinner going forever.
// So the only way to get rid of this is to close this window,
// or if this doesn't work, you'll have to force quit Chrome. 

// So this is one example of an infinite loop. 

// Here's another example while true. 

while (true) {

}

// Again, this loop is going to run forever.
// So it's an infinite loop. 

// And by the way, infinite loops are not limited to while loops, 
// we can create an infinite do while loop, so:

do {

} while (true);

// Or similar to the last example, 
// maybe we'll create a loop variable like 0 
// and then have a condition like x is less than 5, 
// but we forget to increment x here.

let x = 0;
do {
    // x++;
} while (x < 5);

// We can also create an infinite for loop. 
// So, for let i equal to 0, as long as i is greater than 0, i ++, 

for (let i = 0; i > 0; i++) { }

// again with the condition that we have placed here (i > 0)
// this loop is going run forever, 

// or maybe we have the right condition, like i is less than 10, 
// but we forget to add the third part.

for (let i = 0; i < 10;) { }

// So we don't increment i, and this is exactly like this while loop 
// that we had earlier. Without incrementing i. 

// So be aware of the infinite loops, avoid them, 
// because they can crash your browser or your computer.




// --------------------------------------------------
// 4.7 For...In

// So far you have learned about 3 kinds of loops in JavaScript.
// FOR LOOPS, WHILE LOOPS and DO WHILE LOOPS.

// With all these loops we can repeat an action a number of times.

// But we have TWO MORE kinds of loops in JavaScript and
// WE USE THEM TO ITERATE OVER THE PROPERTIES OF AN OBJECT OR ELEMENTS IN AN ARRAY

// Let me show you. 
// In this lecture, we're going to look at the FOR IN loop.

// So let's say we have an object like person, with two properties name, 
// Mosh and age 30.

const person = {
    name: 'Mosh',
    age: 30
}

// Let's say we want to display all the properties of this person object.

// That's when we use the FOR IN loop. 

// So for, now in parenthesis, unlike the for loop that we learned about earlier,
// we don't have three parts, so we don't have that initial expression 
// followed by a semi colon, a condition, followed by the increment part.

// NOT WRITTEN LIKE A For Loop
// for (initialExpression; condition; increment)

// It looks a little but different, let me show you.

// So we have let key in person.

for (let key in person) { }

// So in EVERY ITERATION THIS KEY VARIABLE IN THE LOOP
// WILL HOLD THE NAME OF ONE OF THE PROPERTIES OF THE person object

// Let me show you.
// So here I'm going to do a simple console.log of key, save the changes.

for (let key in person)
    console.log(key);

// output:
// name
// age

// So in the first iteration, key is name, and in the second iteration it is age.

// Now what if you want to display the VALUE OF EACH PROPERTY next to it.
// Well earlier i told you that there are two ways to access the properties of an object.

// We can use the DOT NOTATION which looks like this

person.name

// or we can use the BRACKET NOTATION.
// So person square brackets, the name of the target property as a string.

person['name']

// Earlier I told you, that we used the bracket notation 
// when we don't know ahead of time, at the time of writing code, 
// what property we're going to access.

// Perhaps the name of the target property is calculated at run time.

// Here is a real example.

// When we iterate over the properties of the person object, 
// in EACH ITERATION THE VALUE OF KEY IS GOING TO BE DIFFERENT.

// So here WE CAN'T USE THE DOT NOTATION to display the value of this property, 
// in other words, we can't do something like this

console.log(key, person.key)

// BECAUSE WE DON'T HAVE A PROPERTY CALLED KEY IN THE PERSON OBJECT

// So that's when we use the BRACKET NOTATION.
// So we add square brackets, and pass key as the name of the target property.
// Save the changes

const person = {
    name: 'Mosh',
    age: 30
}

for (let key in person)
    console.log(key, person[key]);

// output:
// name Mosh
// age 30

// so you can see the value of name is Mosh and the value of age is 30.

// So this is the FOR IN LOOP and WE USE IT TO ITERATE OVER THE PROPERTIES OF AN OBJECT.

// WE CAN ALSO USE THIS TO ITERATE OVER AN ARRAY.

// BUT IT'S NOT AN IDEAL WAY, in the next lecture I'm going to show you a better way, 
// but let's see how that works before we finish this lecture.

// So I'm going to define an array called colors, 
// with three values, red, green, and blue.

const colors = ['red', 'green', 'blue'];

// Now we can use the FOR IN LOOP TO ITERATE OVER THIS ARRAY. 

// So for let index in colors
// note that I named this LOOP VARIABLE index, 
// because in each iteration, this index variable will be set to the 
// INDEX of one of the elements in this array.

// So it's going to be 0 1 and 2. Let's take a look. 
// So console.log index. Save the changes.
// So, we get 0, 1, and 2. 

const colors = ['red', 'green', 'blue'];

for (let index in colors)
    console.log(index);

// output:
// 0
// 1
// 2

// Now if you want to get the elements of a given index.
// Once again we use the square bracket notation. 
// So, comma, colors of index. Save the changes,
// and now we can see each element in our colors array.

const colors = ['red', 'green', 'blue'];

for (let index in colors)
    console.log(index, colors[index]);

// output:
// 0 red
// 1 green
// 2 blue

// Now starting from Ecma Script 6, or ES6, which is the modern version 
// of JavaScript we have a NEW KIND OF LOOP that is called FOR OF LOOP, 
// and that is an IDEAL WAY TO ITERATE OVER ARRAYS,
// and that's what you're going to learn in the next lecture.




// --------------------------------------------------
// 4.8 For...of

// So as I told you in the last lecture, starting from Ecma Script 6, or ES6,
// we have a new way to iterate over arrays and that is using the FOR OF LOOP.

// It's very similar to the for in loop but instead of the IN keyword we use the OF keyword. 

// So here's an example, for let, color of colors,
// you can simply log this color on the console.

const colors = ['red', 'green', 'blue'];

for (let color of colors)
    console.log(color);
// output:
// red
// green
// blue

// You can see with this new for loop, we don't have to deal with this index.
// And we don't have to access this element at the given index.

// So in each iteration this color which is our loop variable 
// will hold one of the items in this array.
// So when I save the changes, we see red green and blue

// So WE USE THE FOR IN LOOP TO ITERATE OVER THE PROPERTIES OF AN OBJECT:

// FOR IN LOOP
const person = {
    name: 'Mosh',
    age: 30
}

for (let key in person)
    console.log(key, person[key]);

// and THE FOR OF LOOP TO ITERATE OVER THE ELEMENTS OR ITEMS IN AN ARRAY:

// FOR OF LOOP
const colors = ['red', 'green', 'blue'];

for (let color of colors)
    console.log(color);




// --------------------------------------------------
// 4.9 Break and Continue

// With all the loops you have learned about in this section, there are two keywords,
// BREAK and CONTINUE that can change how the loop behaves. 

// In this demo I'm going to use a while loop. 
// But what you're going to learn applies to all loops we have learned in this section. 

// So let's start by declaring a variable called i and initialize it to 0.
// Now we put this in a while loop, as long as while is less than or equal to 10, 
// we're going to display i on the console and then increment it. 
// Save the changes, so this gives us numbers 0-10. 

let i = 0;
while (i <= 10) {
    console.log(i);
    i++;
}
// output:
// 0
// 1
// 2
// 3
// 4
// 5
// 6
// 7
// 8
// 9
// 10

// Now sometimes YOU WANT TO JUMP OUT OF A LOOP FOR SOME REASON
// that may happen at run time.

// For example, here we can have an if condition an if statement, 
// with a condition like this. 

// If i equals 5, we want to jump out of this loop. 
// That's where we use the BREAK keyword. 
// Now when we save the changes, see what happens we get the numbers 0 to 4. 

let i = 0;
while (i <= 10) {
    if (i === 5) break;

    console.log(i);
    i++;
}
// output:
// 0
// 1
// 2
// 3
// 4

// So at the end of the 5th iteration here we increment i, 
// now i is 5, so we break out of the loop. 

// Now let me comment this out and look at the CONTINUE keyword.

// So I'm going to write another if statement, 
// I want to see if i is an even number or not. 
// So i, modulus 2, equals 0.
// If that's the case, I want to increment i and then continue.
// Let's see what happens when we run this code. Save the changes,

let i = 0;
while (i <= 10) {
    //if (i === 5) break;
    if (i % 2 === 0) {
        i++;
        continue;
    }

    console.log(i);
    i++;
}
// output:
// 1
// 3
// 5
// 7
// 9

// we only get the odd numbers, why is that? 
// Alright let's take a look at an example. 
// So when i becomes 2, it's an even number, at this point increment i, i will be 3. 

// Now when the JavaScript engine sees the CONTINUE keyword. 
// IT WILL JUMP TO THE BEGINNING OF THE LOOP. 
// AND CONTINUES IT'S EXECUTION IN THE NEXT ITERATION.

// while (i <= 10) {   <-- it jumps here to the beginning of the loop

// At this point i is 3, so this if statement is not executed,
// that's why we see i on the console. 

// Now, in my personal experience, continue is not something you will use that often,
// it's one of those old legacy things in the JavaScript language, 
// I'm only explaining it here in case you see it in projects you're working on. 

// It's not something that I recommend you to use, it's an ugly way of writing code.

// So just to recap 
// with the BREAK keyword we JUMP OUT OF A LOOP, 
// and with the CONTINUE keyword we JUMP TO THE NEXT ITERATION.




// --------------------------------------------------
// 5.1 Objects - Basics

// Earlier in the course you learned a little bit about objects, 
// you learned that objects are collections of key value pairs, 
// so if you have properties that are highly related, 
// we want to encapsulate them inside of an object.

// Here's an example. 
// Let's say we are building an application for drawing different kinds of shapes, 
// like circles, rectangles and so on. 

// So we could declare multiple variables, around circles for example 
// radius we set that to 1, then x and y
// we're defining multiple variables, but all these variables are highly related, 
// they represent the circle. 

let radius = 1;
let x = 1;
let y = 1;

// A better approach is to put these variables inside of an object. 

// Now we can send that object anywhere in our programs, 
// we can pass that to any functions,
// and all these variables will be available in that object. 

// So, I'm going to define an object, we could use let or const, 
// in this case it doesn't really matter, 
// so let's define a circle object using the object literal syntax, 
// so we add these curly braces, and inside them we add 1 or more key value pairs. 

const circle = {};

// So, the first key is radius, and the value is 1. 

const circle = {
    radius: 1
};

// Now this value we have here can be any type in JavaScript, 
// it can be a number, a string, a boolean, null, undefined, 
// it can even be another object, or an array, or a function. 

// Let me show you 
// so instead of defining two other key value pairs as x and y, 
// I'm going to add a key called location, and set it's value to another object. 
// Now in this object we can have two key value pairs or properties 
// the first one is x and the second one is y.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
};

// We can also have another property here like isVisible, and set that to a boolean, 
// true or false, okay?

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
};

// So the purpose of an object is to group related variables. 

// But it's not just grouping related variables, 
// quite often we have functions that should operate on these variables.

// For example, we can have a function like draw, for drawing a circle. 
// Or, we could have another function for moving a circle, right?

function draw() { }
function move() { }

// So again these functions are highly related to these variables we have to find here.

// So INSTEAD OF defining these functions, in a STANDALONE way, 
// it's BETTER TO PUT THESE FUNCTIONS, INSIDE OF THE circle OBJECT. 

// Again with this, 
// WHERE WE HAVE THE circle OBJECT in our program, 
// WE HAVE ACCESS TO ALL OF IT'S PROPERTIES AND FUNCTIONS. 

// So let me show you how to add this draw function inside of the circle object. 

// We add another key value pair, 
// the key is draw, 
// and the value is a function, 
// so I told you that the value of a key value pair can be anything in JavaScript, 
// here the value is a function.

// Now for simplicity I just want to do a console.log here, 
// let's log draw on the console.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

// So now with this circle object, we no longer need 
// these independent variables, 

// let radius = 1;
// let x = 1;
// let y = 1;

// and functions, 

// function draw() { }
// function move() { }

// all of THESE ARE NOW PART OF A circle OBJECT.

// So we can access them using the dot notation, circle. 
// look, all of them are here. 
// We can simply call this draw function like this. 
// And if I save the changes, you see the draw message here. 

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

circle.draw();
// output:
// draw

// Now what you see here, is what we refer to as OBJECT ORIENTED STYLE of programming. 
// So OBJECT ORIENTED PROGRAMMING, also abbreviated as OOP. 

// Object oriented programming is basically a style of programming
// where we see a program as a collection of objects 
// that talk to each other to perform some functionality.

// So here we have a circle object, and this object has a few properties and a function. 

// In object oriented programming terms, 
// IF A FUNCTION IS PART OF AN OBJECT,
// WE CALL THAT FUNCTION A METHOD. 

// So here more accurately instead of saying we're calling the draw function of the circle object, 
// we say WE'RE CALLING THE DRAW METHOD OF THE circle OBJECT.

// So that's the difference between a function and a method 
// if a function is part of an object, in object oriented programming terms, 
// we refer to that function as a method. 

// Now, using this object literal syntax, is an easy way to create an object, 
// but as our applications get more complex we need a different way to create objects. 

// And that's what you're going to learn next.




// --------------------------------------------------
// 5.2 Objects - Factory Functions

// In the last lecture you learned how to use the object literal syntax to create an object
// but there is a tiny problem here. 

// Imagine you want to create two circle objects, so, I'm going to copy this code here, 
// and call this second circle object circle 2.

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

const circle2 = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    isVisible: true,
    draw: function () {
        console.log('draw');
    }
};

// Now the problem that we have here is that we have duplicated the implementation,
// of the draw method, so right now it's a simple method with only a single line of code, 
// but what if we had 10 lines of code here. 
// You wouldn't want to repeat all these lines here, because if you bug in this method, 
// then we'll have to fix it in multiple places.
// And also take into account that our circle object currently has only a single method. 
// What if we had 10 other methods here?
// We don't want to duplicate or repeat all that logic, alright?

// So, if our objects have logic, we need a different way to create objects. 
// That's when we use FACTORY or CONSTRUCTOR FUNCTIONS.

// In this lecture you're going to learn about factory functions 
// and we'll look at constructor functions next.

// So I'm going to delete this second circle and show you how to create a factory function. 

// So factory function, just like a factory producing products, 
// these FACTORY FUNCTIONS PRODUCE OBJECTS.  

// So we define a function and call it create circle.

function createCircle() {

}

// Now we're going to move this definition of the circle object inside
// our factory function,
// so you have a circle object here, 
// finally we need to return this. 

function createCircle() {
    const circle = {
        radius: 1,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
    return circle;
}


// Now one way is to return it like this, 
// but we don't really need this circle constant defined
// because we are not going to reference it anywhere, 
// we only want to return it.

// So we can make this code shorter by removing the circle constant 
// and simply returning this object. 

// So whenever we call the create circle function we'll get a circle object. 

function createCircle() {
    return {
        radius: 1,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}

// However, we have hard coded these values here, so every circle that is created by this
// function, it's radius will be one. 
// That's not what we want, we want to have a circle with a bigger radius. 

// So we want to pass radius as a parameter here. 
// So radius and then instead of hardcoding 1, 
// we want to set the value to this radius argument that we supply when calling this function.

function createCircle(radius) {
    return {
        radius: radius,
        location: {
            x: 1,
            y: 1
        },
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}


// Similarly we can add another parameter here like location, 
// and instead of hard coding this object here, 
// we simply set location to this location argument.

function createCircle(radius, location) {
    return {
        radius: radius,
        location: location,
        isVisible: true,
        draw: function () {
            console.log('draw');
        }
    };
}

// However, for simplicity, I'm going to remove these two properties.
// Location and is visible, so we can focus on the core of factory functions. 

// So, let's delete these properties, we don't need the location parameter either, 
// now we can make this code a little bit shorter.  

// So in modern JavaScript if our key and value are the same, 
// we can make our code shorter by removing a value and simply adding the key.
// So that is exactly equivalent to this code.


function createCircle(radius) {
    return {
        radius: radius,
        draw: function () {
            console.log('draw');
        }
    };
}

function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

// Alright? So that is better, 

// next we have our draw method, there is also a shorter syntax to define this method,
// so instead of defining it as a key value pair, we can define it like this. 

// So draw parenthesis and a code block. 
// This is similar to how we defined a function outside of an object, right? 

// So if you want to define a function, this is how we define it, right? 

// So we have the function keyword, then the name of the function, parenthesis, and code block.

// Now when we put this inside of an object, basically we're dropping the function keyword 
// and simply adding this inside of the object. 

function draw() // standard function definition OUTSIDE of an OBJECT

{
    draw: function() { } // formal [key:value pair] function INSIDE of an OBJECT (METHOD)
}

{
    draw() { } // abbreviated [key:value pair] function INSIDE of an OBJECT (METHOD)
}

// You can see that this syntax is a little bit shorter than here. 
// So let me delete this. And move this console.log statement in our draw method.

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

// So now we have a factory function, we can simply call this to create a circle object. 
// So I'm going to define this constant circle1, 
// and call the create circle function, and pass 1 as the radius.
// Now let's log this circle object on the console. circle1, save the changes

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

const circle1 = createCircle(1);
console.log(circle1);
// output:
// { radius: 1, draw: [Function: draw] }

// so you can see radius is set to 1, 
// we also have this draw method, 
// so we can call circle1.draw and here's our draw message on the console. 

circle1.draw();
// output:
// undefined

// Now THE BEAUTY OF THIS FACTORY FUNCTION IS THAT WE HAVE DEFINED OUR LOGIC IN ONE PLACE.

// So we can call this function with different values or different arguments, 
// we get different circle objects, but we have defined the draw method only in 1 place.

// So if there is a bug in this method that we need to fix in the future, 
// there is a single place that we need to modify.

// So now I'm going to create another circle object, 
// circle2, createCircle

// I'm going to pass 2 as the radius, let's log this on the console.
// Circle2, save the changes

function createCircle(radius) {
    return {
        radius,
        draw() {
            console.log('draw');
        }
    };
}

const circle1 = createCircle(1);
console.log(circle1);

const circle2 = createCircle(2);
console.log(circle2);
// output:
// { radius: 1, draw: [Function: draw] }
// { radius: 2, draw: [Function: draw] }

// look we have TWO DIFFERENT circle OBJECTS and A SINGLE DEFINITION OF the draw METHOD.

// So this is all about FACTORY FUNCTIONS. 

// But factory functions are not the only way to create objects, 
// we can also use constructor functions, and that's what you're going to learn next.




// --------------------------------------------------
// 5.3 Objects - Constructor Functions

// In this lecture you're going to learn about another pattern for creating objects.

// That is a CONSTRUCTOR FUNCTION,

// so just like the factory function, we're going to create a function, 
// and THE JOB OF THIS FUNCTION IS TO CONSTRUCT OR CREATE AN OBJECT

// However, the naming convention we use for constructor functions is different. 
// So the naming convention we have for factory functions is what we call camel notation,
// so the first letter of the first word is lowercase, but the first letter of every word after is uppercase. 
// This is what we call camel notation. 

// So it looks like this, camel notation, you've got oneTwoThreeFour

// You can see the first letter of the first word is lowercase.
// And these upper case letters, look like camel humps, that's why we call it camel notaton. 

// In contrast, we have another notation that is called PASCAL NOTATION, 
// and in this notation, the FIRST LETTER of EVERY WORD should be UPPER CASE. 

// So OneTwoThreeFour. 

// You can see the pattern right?

// Now, WHEN NAMING CONSTRUCTOR FUNCTIONS, WE SHOULD USE PASCAL NOTATION by convention, 
// because that's something other JavaScript developers expect when they read your code. 

// So we're going to call this function circle with a capital C. 

// Note that I did not call this create circle and you will see that in a second.

function Circle() {

}

// Now, just like our factory function, here we need to add a parameter, radius
// however, instead of returning an object,
// we're going to use a different approach to initialize an object.

// In JavaScript, we have a keyword called "THIS". 
// And "THIS" is a REFERENCE TO THE OBJECT THAT IS EXECUTING THIS PIECE OF CODE.

// You're going to see that in a second. 
// For now, just imagine this references an empty object. 

function Circle() {
    this
}

// Now you know what with dot notation, we can access properties of an object, 
// we can read a property, or we can set a property, 

// So on this new empty object, we want to add a property called radius, 
// and we set that to this radius argument that we receive here.


function Circle(radius) {
    this.radius = radius;
}

// So in JavaScript our objects are dynamic. 
// Once we create them we can always add additional properties or methods to them. 
// So here WE ARE ADDING A NEW PROPERTY TO AN EMPTY OBJECT. 

// Now similarly, we are going to use this approach to add a draw method to this new empty object.

// So this.draw, 
// but we set this to a function 
// and in the body of this function we simply do a console.log of draw.


function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

// Now finally in order to create a circle object using this constructor function, 
// we're going to DEFINE A CONSTANT called circle and here we're going to use another keyword,
// that is "NEW", circle, and pass 1 as the radius. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(1);


// What is happening here? 
// Well, when we use this "NEW" OPERATOR here, 3 things happen. 

// This "NEW" OPERATOR CREATES AN EMPTY JavaScript OBJECT. 

// Something like this. Constant, x, set to an empty object. 
// const x = {};
// That is happening under the hood, but you don't see that. 

// Next, IT WILL SET "THIS" TO POINT TO THIS NEW EMPTY OBJECT "{}"

// So in this code we have access to this new empty object, 
// and we set this "radius" property as well as the "draw" method in this new object.

// Finally, this "NEW" OPERATOR WILL RETURN THIS NEW OBJECT FROM THIS FUNCTION,
// so it looks like this. 

// return this;

// We don't have to explicitly add the statement here in this function, 
// this will happen under the hood. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
    return this;
}

const circle = new Circle(1);

// So let me recap, when we use the "NEW" OPERATOR, 3 THINGS HAPPEN, 

// this operator FIRST CREATES AN EMPTY OBJECT "{}"

// then IT WILL SET "this" TO POINT TO THIS OBJECT "{}"

// and finally IT WILL RETURN THAT OBJECT from this function "return this;".

// So what we get here is that new object "new circle(1);" 
// and we simply set the " const circle" to point to that object. 

const circle = new Circle(1);


// Now let's see THE DIFFERENCE BETWEEN FACTORY AND CONSTRUCTOR FUNCTIONS.

// So with factory functions we create an object like this.
// myCircle here we call createCircle and pass an argument. 

// FACTORY FUNCTION
const myCircle = createCircle(1);

// So WITH FACTORY FUNCTIONS, 
// WE SIMPLY CALL A FUNCTION
// AND IN THIS FUNCTION WE RETURN A NEW OBJECT. 

// In contrast, 

// WITH CONSTRUCTOR FUNCTIONS
// WE USE THE "NEW" OPERATOR, 
// AND INSTEAD OF RETURNING AN OBJECT WE USE THE "this" KEYWORD. 

// CONSTRUCTOR FUNCTION
const circle = new Circle(1);

// Also in terms of naming convention 
// with CONSTRUCTOR FUNCTIONS we use the PASCAL NAMING convention, 
// but in FACTORY FUNCTIONS we use the CAMEL notation. 

// So you might be asking 
// WHICH APPROACH or which pattern YOU SHOULD YOU USE TO CREATE NEW OBJECTS. 

// Both these patterns are EQUALLY GOOD for creating new objects, 

// the CONSTRUCTOR FUNCTION pattern is familiar to developers who have 
// some experience programming in languages like C# and Java. 

// So with this pattern you can see that we're creating a new circle.
// Alright, 

// if you don't have any experience in languages like C# or Java, 
// you might want to go for a FACTORY FUNCTION. 

// There is really no difference between these two patterns, however, 
// there are some discussions online by some strongly opinionated developers 
// comparing these to patterns, 
// my suggestion to you is do not get hung up on these discussions, 
// they're just a waste of time, 

// pick one pattern, and just stick to that.




// --------------------------------------------------
// 5.4 Objects - Dynamic Nature of Objects

// One thing we need to understand about objects in JavaScript is that they are dynamic
// which means once you create them you can always add new properties or methods, 
// or remove existing ones. 

// So here we have a circle object with a single property that is radius, 

const circle = {
    radius: 1
};

console.log(circle);
// output:
// { radius: 1 }


// we can add another property like color set it to yellow
// now when we log the circle on the console you can see we have two properties, 
// color and radius. 

const circle = {
    radius: 1
};

circle.color = "yellow";

console.log(circle);
// output:
// { radius: 1, color: 'yellow' }

// Similarly, we can add a new method here, circle.draw, we set it to new function 
// and now when we log this on the console we can see our circle object 
// has three members, two properties, color and radius, and one method.

const circle = {
    radius: 1
};

circle.color = "yellow";
circle.draw = function () { }

console.log(circle);
// output:
// { radius: 1, color: 'yellow', draw: [Function] }

// We can also delete existing properties or methods, so here before logging the circle, 
// we can use the "delete" operator, to delete a member from a circle object. 

// That member can be a property method. So circle.color 
// we can also delete the draw method, so circle.draw, now save the changes, 
// we can see now our circle object has only the radius property that we added at the
// time of creating this object. 

const circle = {
    radius: 1
};

circle.color = "yellow";
circle.draw = function () { }

delete circle.color;
delete circle.draw;

console.log(circle);
// output:
// { radius: 1 }

// Now something some developers find confusing is that here 
// we have used the const keyword, to define a new constant. 

// However, you can see I have modified the circle object of either the property, 
// and then remove that property.

// So what kind of constant is that? 

// Well, when we use constant here "const circle = " 
// that means we cannot reassign this variable, 
// so this variable is more accurately a constant. 

// So we cannot reset circle to a new object. 
// If we do that, we get this error: "TypeError: Assignment to constant variable". 

const circle = {
    radius: 1
};

circle = {};
// output:
// TypeError: Assignment to constant variable.

// So we cannot REASSIGN this constant, 
// but we can always change the circle object by adding or removing properties.




// --------------------------------------------------
// 5.5 Objects - Constructor Property

// EVERY OBJECT in JavaScript HAS A PROPERTY CALLED CONSTRUCTOR.
// And THAT REFERENCES THE FUNCTION THAT WAS USED TO CONSTRUCT OR CREATE THAT OBJECT. 

// So here we have two objects circle and another. 

function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

const circle = createCircle(1);

// Constructor Function
function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1); // constructor function

// Let's look at their constructor property. 
// So, here, on the console, another.constructor.
// So as you see, this returns our circle function that we used to create this object. 

console.log(another.constructor);
// output:
// [Function: Circle]

// Now let's look at circle.constructor. What is this?
// Well, we can tell that this is a function, because here we have this blue f. 
// And as you can see the first letter of this function is uppercase. 

console.log(circle.constructor);
// output:
// [Function: Object]

// So this is a BUILT IN CONSTRUCTOR FUNCTION in JavaScript, 

// WHEN WE CREATE AN OBJECT USING OBJECT LITERAL SYNTAX, 
// INTERNALLY THE JAVASCRIPT ENGINE USES THIS "Constructor" FUNCTION. 
// Let me show you. So I'm going to temporarily delete all this code, 

// let's define an object like this,

let x = {};

// WHEN WE USE THIS SYNTAX, OBJECT LITERAL, 
// JavaScript will translate that to something like this. 

let x = new Object();

// Okay?
// So, the circle object we created, and returned it, from our factory function, 
// and because we used the object literal syntax, 
// internally it was created using this "Object" constructor function.

// In JavaScript we have a few other built in constructors, for example, 
// we have "String" for creating strings, 

new String();

// but quite often we use string literals. 
// So, single quote, or double quote, or back tick: '', "", ``

// Using these literals is cleaner and simpler than using the "constructor".

// We also have "Boolean", but again we don't use this, we either use true or false. 
// So we refer to these as boolean literals. 

new Boolean();

// We also have "Number", but instead we use number literals, like 1, 2, 3, whatever. 

new Number();

// So this is what I want you to take away, 

// EVERY OBJECT HAS A CONSTRUCTOR PROPERTY,
// AND THAT REFERENCES A FUNCTION THAT WAS USED TO CREATE THAT OBJECT.




// --------------------------------------------------
// 5.6 Objects - Functions are Objects

// ONE OF THE CONFUSING CONCEPTS IN JAVASCRIPT IS THAT HERE FUNCTIONS ARE OBJECTS. 

// So this Circle function we have here, is actually an object. 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1);

// Don't believe me? Let me show you. So 

// Circle.

// Look these are all the members of the circle function or circle object.

// So the purple icons are methods, like call, bind, and apply,
// and the blue icons are properties. 

// So let's take a look at a few of these members in the console. 
// Here in the console

console.log(Circle.name); // that returns the name of this function.
// output:
// Circle 

console.log(Circle.length); // returns the number of arguments, 
// output:
// 1

// now earlier in the last lecture I told you that 
// EVERY OBJECT IN JAVASCRIPT HAS A CONSTRUCTOR PROPERTY, 
// AND THAT REFERENCES THE FUNCTION THAT WAS USED TO CREATE THAT OBJECT. 

// Now here's the interesting part, who do you think, created this object?
// Let's have a look, so 

console.log(Circle.constructor);
// [Function: Function]

// so here we have another built in constructor called "Function", 
// and when we declare a function using this syntax, internally, 
// JavaScript engine will use this Function constructor to create this object.

// Let me show you. 

// So, I'm going to define a constant called Circle1, 
// to separate from our circle.

// Set it to new Function, 
// now here our function requires one parameter, radius, 
// so we add that here as a string.

const Circle1 = new Function('radius')

// Now as a second argument, 
// I'm going to pass the code inside of this function. 

// So to break it up into multiple lines. 
// I'm going to use the back tick character, 
// and then simply copy all this code and put it here, 

// SO WHEN WE DECLARE A FUNCTION, INTERNALLY IT'S REPRESENTED LIKE THIS.

const Circle1 = new Function('radius', `
this.radius = radius;
this.draw = function() {
    console.log('draw');
}
`);

// Now we can call this Circle1, just like calling our circle function. 

// So, we can create a circle object by "newing up" Circle1, "new Circle1()" 
// and pass 1 as the radius, save the changes, 
// now in the console, let's log circle. 

const circle = new Circle1(1);
console.log(circle);
// output:
// anonymous { radius: 1, draw: [Function] }

// Look, it's a real circle object with these two members (draw and radius).


// Now let's take a look at a couple methods that are available in our functions. 
// So I'm going to delete all this code, 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const another = new Circle(1);

// here we have this "call" method, 
// and with this we can call a function. 

Circle.call()

// Look at the arguments. The first argument, is "thisArg"
// Here we need to pass an empty object {} 
// and "this." will reference this object {} that we pass here (inside the .call() brackets).

Circle.call({})

// Okay? Now after that we add our arguments explicitly, 
// so here we have one argument (radius), we pass 1,
// if we had multiple arguments we would pass them explicitly like this, okay?

Circle.call({}, 1)

// So, this expression is EXACTLY LIKE this expression:

const another = new Circle(1);

// when we use the "new" OPERATOR, 
// THIS NEW OPERATOR WILL INTERNALLY CREATE AN EMPTY OBJECT {}
// AND PASS THAT AS THE FIRST ARGUMENT TO THE CALL METHOD.

// And this object will determine the context for "this." 
// so "this." will reference this object the {} inside Circle.call({}, 1)

// Earlier I told you that IF YOU DON'T USE THE NEW OPERATOR
// "THIS."" BY DEFAULT WILL POINT TO THE GLOBAL OBJECT WHICH IS WINDOW. 

// So, if I want to rewrite this expression

const another = new Circle(1);

// in this way:

Circle.call({}, 1)

// instead of passing an empty object, I would pass window.

Circle.call(window, 1)

// Of course we don't want to do this, 
// I'm just explaining to you what happens under the hood. 
// So, let's revert this back,

// so the first argument here ({})

Circle.call({}, 1)

// specifies the target of this. Okay? 

// Now we have another method called "apply".

Circle.apply();

// It's exactly like the call method, with this we can call a function, 
// BUT INSTEAD OF PASSING ALL THE ARGUMENTS EXPLICITLY WE PASS THEM IN AN ARRAY. 

Circle.apply({}, [1, 2, 3]);

// So this is useful if you already have an array somewhere in your application, 
// and you want to pass that array as the second argument to the apply method.

// So this is the takeaway. 
// IN JAVASCRIPT, FUNCTIONS ARE OBJECTS.




// --------------------------------------------------
// 5.7 Objects - Value vs Reference Types

// In JavaScript we have TWO CATEGORIES OF TYPES. 
// On one side we have VALUE TYPES, also called primitives, 
// on the other side we have REFERENCE TYPES. 

// So in the value types category we have 
// number, string, boolean, symbol (which is new in ES6) as well as undefined and null. 
// These are the primitive or value types. 

// On the other side we have objects, functions, and arrays.

//      VALUE TYPES         REFERENCE TYPES
//
//      Number              Object
//      String              Function
//      Boolean             Array
//      Symbol
//      undefined
//      null

// So in the last lecture you learned that FUNCTIONS ARE ALSO OBJECTS.
// THE SAME IS TRUE ABOUT ARRAYS, 
// so in a nutshell in JavaScript we have Primitives and Objects. 

// Now in this lecture, 
// I'm going to SHOW YOU HOW PRIMITIVES AND OBJECTS BEHAVE DIFFERENTLY, 
// because this is absolutely important for you to understand, 
// before we move onto the next section where I talk about Prototypes. 

// So on this empty canvas, I'm going to define two primitives, x and y. 
// I'm going to set y to x, so here y is 10,
// now I'm going to change the value of x to 20, 

// what I want you to note here, is that X AND Y ARE TWO INDEPENDENT VARIABLES,
// so, let's save the changes, go back in the console,
// let's log x and y,

let x = 10;
let y = x;

X = 20;

console.log(x);
console.log(y);
// output:
// 10
// 10

// x is 20, and y is 10
// they are INDEPENDENT. 

// So WHEN WE WORK WITH PRIMITIVES. 
// THIS VALUE (10) THAT WE HAVE HERE IS STORED INSIDE OF THIS VARIABLE (X). 

// WHEN WE COPY THAT VARIABLE THAT VALUE THAT IS STORED IN THE VARIABLE (X)
// IS COPIED INTO THIS NEW VARIABLE (Y). 

// So THEY ARE COMPLETELY INDEPENDENT OF EACH OTHER. 

// NOW LET'S SEE WHAT HAPPENS IF WE USE A REFERENCE TYPE or an object HERE. 

// So I'm going to change this (let x = 10) 
// to an object that has a property called value ( let x = { value: 10 } ). 
// And then instead of saying x to 20, I'm going to set x.value to 20.
// So save the changes, 
// let's log x so you can see value property is 20, 
// now let's log y, you can see the value property of y is also 20. 

let x = { value: 10 };
let y = x;

X.value = 20;

console.log(x);
console.log(y);
// {value: 20}
// {value: 20}

// So this is the takeaway,

// WHEN WE USE AN OBJECT, THAT OBJECT IS NOT STORED IN THIS VARIABLE (x).

// THAT OBJECT IS STORED SOMEWHERE ELSE IN THE MEMORY (12345), 
// AND THE ADDRESS OF THAT MEMORY LOCATION (12345) IS STORED INSIDE THAT VARIABLE. 

// So then when we copy x into y, 

// let y = x;

// IT'S THE ADDRESS OR THE REFERENCE (12345) THAT IS COPIED. 
// In other words, BOTH X AND Y ARE POINTING TO THE SAME OBJECT IN MEMORY (12345). 

// And WHEN WE MODIFY THAT OBJECT USING X, OR Y, 
// THE CHANGES ARE IMMEDIATELY VISIBLE TO OTHER VARIABLE. 

// So here's the conclusion. 

// PRIMITIVES ARE COPIED BY VALUE
// REFERENCE TYPES (OR OBJECTS) ARE COPIED BY BY THEIR (memory) REFERENCE.

// Let's take a look at another example. 

// So I'm going to define a function called increase that takes a number,
// and here we simply increase this number by one.
// Let's declare a number variable and set it to 10. 
// And then call increase and pass this number. 

// Now, if I log this number on the console, what do you think you'll see? 
// Let's have a look. So save the changes, we see 10. 

// Primitive Types VALUE - Example with Function
let number = 10;

function increase(number) {
    number++;   // this variable number here 
}                // is COMPLETELY INDEPENDENT OF THE let "number" VARIABLE above.

increase(number);
console.log(number);
// 10

// But didn't we increase the number?
// WELL WHEN WE CALL INCREASE AND PASS THIS NUMBER VARIABLE 
// IT'S VALUE IS COPIED INTO THIS PARAMETER THAT IS LOCAL IN THIS FUNCTION. 

// SO THIS VARIABLE HERE IS COMPLETELY INDEPENDENT OF THIS OTHER NUMBER VARIABLE. 

// Here in this function, we increment this number by 1, so it will be 11, 
// but after this function this number is going to go out of the scope. 

// So when we log this number on the console, 
// we're essentially dealing with this first number. 

// So I told you that PRIMITIVES ARE COPIED BY THEIR VALUE. 

// SO HERE WE'RE DEALING WITH TWO INDEPENDENT COPIES. 
// That's why you see 10 on the console. 


// Now let's change this to a reference type or an object.
// So, I'm going to change 10 to an object, that has a value property. 
// Okay? Let's rename this variable to object, and similarly, 
// im going to rename the parameter in this function to object, 
// and then increment object.value.

// Now when we log this on the console, what do you think we're going to see? 
// We're going to see 11. See? We got this object with value 11. 

// Reference Types VALUE - Example with Function
let object = { value: 10 };

function increase(object) {
    object.value++;
}

increase(object);
console.log(object);
// 11

// THE REASON FOR THIS IS BECAUSE WHEN WE CALL INCREASE AND PASS THIS OBJECT. 
// THIS OBJECT IS PASSED BY IT'S REFERENCE. 

// So this local parameter that we have here (in the function: increase(object)) 
// WILL POINT TO THE SAME OBJECT that we defined here (in the let statement: let object). 

// SO IN THIS CASE WE ARE NOT DEALING WITH TWO INDEPENDENT COPIES, 
// WE HAVE TWO VARIABLES THAT ARE POINTING TO THE SAME OBJECT. 
// SO ANY CHANGES WE MAKE TO THIS OBJECT WILL BE VISIBLE TO THE OTHER VARIABLE. 

// So remember this, in JavaScript 
// we have value types, also called primitives, 
// as well as reference types which are objects. 

// Our primitives are number, string, boolean, symbol, undefined and null. 

// PRIMITIVES OR VALUE TYPES ARE COPIED BY THEIR VALUE 
// REFERENCE TYPES OR OBJECTS, ARE COPIED BY THEIR REFERENCE.




// --------------------------------------------------
// 5.8 Objects - Enumerating Properties of an Object

// So here we have this circle object with the radius property and the draw method.

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};


// Earlier in the course, you learned how to use 
// the FOR IN and FOR OF loops to iterate over the properties in an object. 

// So in this lecture I'm going to review this one more time to make sure 
// you fully understand how everything works. 

// So first, let's take a look at the FOR IN loop. 
// for let key in circle  
// with this we can iterate over all the properties and methods of an object. 
// Now we can log the key on the console, 

for (let key in circle)
    console.log(key);

// output:
// radius
// draw

// so, we have radius, and draw, 
// and if you want to get the value of a property, 
// we use the bracket notation here. 

// So as the second argument here, we pass circle of key (circle[key]). 
// So we're using the bracket notation to get the value of this key or this property. 
// Save the changes 
// so you can see the value of radius is 1, and the value of draw is a function. 
// And here's the implementation of our draw function or draw method. 

for (let key in circle)
    console.log(key, circle[key])

// output:
// radius 1
// draw [Function: draw]

// Now we also have this new FOR OF LOOP, let's take a look. 
// So for let key of circle simply log it on the console, 
// now when I save the changes, we're going to see an error, circle is not iterable.

for (let key of circle)
    console.log(key);

// output:
// TypeError: circle is not iterable

// So earlier I told you that the FOR OF LOOP CAN ONLY BE USED WITH ITERABLES 
// SUCH AS ARRAYS AND MAPS.

// You have not learned about maps yet, you're going to learn about them later in the course,

// what you need to know is that AN OBJECT IS NOT ITERABLE, 
// SO WE CANNOT ITERATE IT USING A FOR OF LOOP. 

// However, we have this METHOD Object.keys of circle (Object.keys(circle))
// WITH THIS WE CAN GET ALL THE KEYS IN OUR CIRCLE OBJECT, AND THIS WILL RETURN AN ARRAY. 

// AND SINCE ARRAYS ARE ITERABLE. 
// WE CAN USE THE FOR OF LOOP TO ITERATE THEM. 
// Now save the changes, again, we get radius and draw. 

for (let key of Object.keys(circle))
    console.log(key);

// output:
// radius
// draw

// Now let's keep a closer look at this method here.

// Object.keys(circle)

// So earlier YOU LEARNED THAT THIS "Object" IS A BUILT IN CONSTRUCTOR FUNCTION. 

// So somewhere we have this constructor function like this

// function Object() {}

// and whenever we create an object using the object literal syntax, 
// internally that is translated into a call to this constructor function (Object). 

// So when we create an object using the object literal syntax, 
// like this 

const x = { value: 1 }

// internally, that is translated to a call to this Object constructor function. 

// So that looks like this. Right?

const x = new Object();

// Also, you learned that all functions in JavaScript are objects, 
// so they have properties and methods that we can access using the dot notation.

// So when we type Object. 
// we can see all the properties and methods defined in this object, 
// so here we're using the keys method, 

Object.keys

// and THIS METHOD RETURNS A STRING ARRAY WHICH CONTAINS 
// ALL THE PROPERTIES AND METHODS IN THIS OBJECT. 

// We have another similar method to object.keys 
// Let me duplicate this, that other METHOD is called "entries".

Object.entries

// SO INSTEAD OF RETURNING THE KEYS AS A STRING ARRAY 
// IT RETURNS EACH VALUE PAIR AS AN ARRAY. 
// Let me show you. 

// So let's rename key to entry. And to do that we can press f2,
// to rename all the references to this key variable.
// Let's change that to entry, we can see that is updated here as well.
// Save the changes. 

for (let entry of Object.entries(circle))
    console.log(entry);

// output:
// [ 'radius', 1 ]
// [ 'draw', [Function: draw] ]

// SO YOU CAN SEE EACH ENTRY IS AN ARRAY, 
// THE FIRST ELEMENT IN THIS ARRAY IS THE KEY, AND THE SECOND ELEMENT IS THE VALUE. 

// so that is also ANOTHER WAY TO GET ACCESS TO ALL THE PROPERTIES
// AND METHODS IN AN OBJECT. 

// And finally SOMETIMES YOU WANT TO SEE IF A GIVEN OBJECT HAS A GIVEN PROPERTY OR METHOD. 
// To do that, you can use the "in" operator. 
// Here's an example. 
// If radius as a string in circle we display a message like yes. 

if ('radius' in circle) console.log('yes');
// output:
// yes

// WITH THE "in" OPERATOR YOU CAN SEE IF A GIVEN PROPERTY EXISTS IN A GIVEN OBJECT.

// Save the changes, so we get yes here, 
// if I change radius to let's say color, 
// we're not going to see the yes message now. 
// Save the changes, yes disappears.

if ('color' in circle) console.log('yes');
// output:
// 

// So THE SIMPLEST WAY TO ENUMERATE THE PROPERTIES IN AN OBJECT IS USING THE FOR IN LOOP, 
// but WE CAN ALSO USE THE FOR OF LOOP ALONG WITH Object.keys AND Object.entries
// and finally TO SEE IF A GIVEN PROPERTY OR METHOD EXISTS IN AN OBJECT WE USE THE IN OPERATOR.

// ALL CODE
const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

for (let key in circle)
    console.log(key, circle[key]);

for (let key of Object.keys(circle))
    console.log(key);

for (let entry of Object.entries(circle))
    console.log(entry);

if ('radius' in circle) console.log('yes');




// --------------------------------------------------
// 5.9 Objects - Cloning an Object

// In the last lecture you learned how to enumerate the properties of an object.

// Now USING THIS TECHNIQUE WE CAN GET ALL THE PROPERTIES IN AN OBJECT
// AND COPY THEM INTO ANOTHER OBJECT. 

// So let's say you want to create another circle object, 
// which is a copy of this circle object here.  

// I'm going to call that another. So constant another, initially we set it to an empty object, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = {};

// now we can use the for in loop to iterate over all the properties in an object, 
// and copy them into this new object. 

// So for, let key, in circle, now we use the bracket notation 
// to access a property with a given key.

for (let key in circle);

// So we set another of key to circle of key.

for (let key in circle)
    another[key] = circle[key];

// So basically here in the first iteration, key will be radius, 
// so this code will be equivalent to this. 

another['radius'] = circle['radius'];

// another of radius, so we're setting the radius property of another object to circle of radius,

// now here on the right side of the assignment operator 
// we're reading the radius property of the circle, the value of this property is 1, 
// so we get 1 and put it in the radius property of the another object. Okay?

// Now lets log another on the console, save the changes, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = {};

for (let key in circle)
    another[key] = circle[key];

console.log(another);
// output:
// { radius: 1, draw: [Function: draw] }

// so here we have this radius property is set to 1, 
// and here's our draw method
// so if we call another.draw everything works as we expect, beautiful.

another.draw()

// But THIS APPROACH FOR COPYING OR CLONING AN OBJECT IS A LITTLE BIT OLD. 

// In modern JavaScript we have better ways to achieve the same thing. 
// One way is to USE THE Object.assign METHOD. 

// Let me show you. 
// So I'm going to comment out these few lines, 
// we have this "Object." that we have seen before, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = Object.assign({}, circle);

console.log(another);

// THIS Object HAS A METHOD CALLED ASSIGN,

Object.assign();

// now here as the FIRST ARGUMENT we can PASS A TARGET OBJECT 
// which CAN BE AN EMPTY OBJECT, OR AN EXISTING OBJECT, 
// you will see the difference in a second.

Object.assign({});

// And THEN WE CAN PASS 1 OR MORE SOURCE OBJECTS. Let's say circle.

Object.assign({}, circle);

// What THIS METHOD DOES IS IT TAKES ALL THE PROPERTIES OF THIS METHOD 
// IN THE SOURCE OBJECT AND COPIES THEM INTO THIS NEW OBJECT, 
// and finally returns the result here.

const another = Object.assign({}, circle);

// So this line of code is exactly equivalent to these three lines.

const another = {};
for (let key in circle)
    another[key] = circle[key];

// If we save the changes, we get the exact same result.

// Now THIS TARGET OBJECT PASS HERE DOESN'T HAVE TO BE AN EMPTY OBJECT, 
// IT CAN BE AN EXISTING OBJECT, it can have 1 or more properties or methods, 
// so as an example, let's add a color property here, we set that to yellow, 
// now, save the changes, 

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = Object.assign({
    color: 'yellow'
}, circle);

console.log(another);
// output:
// { color: 'yellow', radius: 1, draw: [Function: draw] }

// so, THIS NEW OBJECT HAS THE COLOR PROPERTY THAT WE INITIALLY HAD HERE, 
// AS WELL AS THE MEMBERS OF THE CIRCLE OBJECT. 
// So this is the object.assign method. 


// Now let me revert this back to an empty object,

// I'm going to show you yet ANOTHER SIMPLER AND MORE ELEGANT WAY TO CLONE AN OBJECT.

// We CAN USE THE SPREAD OPERATOR, so, another, here we set this to a new object, 
// and then use the spread operator, which is three dots, to spread the circle object.

const circle = {
    radius: 1,
    draw() {
        console.log('draw');
    }
};

const another = { ...circle };

console.log(another);
// output:
// { radius: 1, draw: [Function: draw] }

// Basically WHAT THIS OPERATOR DOES IS THAT IT TAKES ALL THE PROPERTIES AND METHODS
// IN THIS OBJECT AND PUTS THEM HERE in between these curly braces {}. 

// So this is the simplest way to clone an object. 
// Save the changes, again, we get the exact same object as before.

// So here's what I want you to take away, 

// Object.assign COPIES THE PROPERTIES AND METHODS 
// FROM 1 OR MORE SOURCE OBJECTS INTO A TARGET OBJECT, 
// AND WE CAN USE THAT TO CLONE AN OBJECT, 
// OR COMBINE MULTIPLE OBJECTS INTO A SINGLE OBJECT, 

// and THE SPREAD OPERATOR IS USED TO SPREAD AN OBJECT, 
// WHICH BASICALLY MEANS GETTING ALL IT'S PROPERTIES AND METHODS 
// AND PUTTING THEM INTO ANOTHER OBJECT.




// --------------------------------------------------
// 5.10 Objects - Garbage Colleciton

// In low level languages like C or C++, 
// when creating an object, we need to allocate memory to it, 
// and when we're done we need to reallocate memory. 

// But in JavaScript, we don't have this concept. 
// We can easily create a new object, at the time we initialized this object,

let circle = {};

// the memory is automatically allocated to this object, next we can use that object,

console.log(circle);

// and when we are done using, we don't need to deallocate the memory. 

// So, our JavaScript engine has what we call a GARBAGE COLLECTOR. 

// The job of this garbage collector is to find the variables or constants 
// that are no longer used and then deallocate the memory that was allocated to them earlier. 

// So you as a JavaScript developer do not have to worry about this. 
// MEMORY ALLOCATION AND DEALLOCATION AUTOMATICALLY HAPPENS BEHIND THE SCENES, 
// and you have no control over that. 

// You cannot tell garbage collector when to run and what variables to remove from memory. 

// So based on some complex algorithms, this garbage collector runs in the background, 
// it figures out what variables are not used, 
// and then it will automatically deallocate their memory.




// --------------------------------------------------
// 5.11 Objects - Math

// So you have learned a lot about objects, 
// now LET'S TAKE A LOOK AT A FEW OF THE BUILT IN OBJECTS IN JAVASCRIPT. 

// The first one we're going to look at is the Math object. 

// So here in Google let's search for JavaScript math the first link is on
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math
// this is your first reference for learning about all the objects in JavaScript. 

// So let's take a look at the Math object, 
// you can see THIS IS ONE OF THE BUILT-IN OBJECTS WITH PROPERTIES AND METHODS 
// FOR MATHEMATICAL CONSTANTS AND FUNCTIONS.

// So if you scroll down you can see the properties, 
// for example one of the useful properties is math.PI so this is the pi number. 

// We have a bunch of other Properties here, 

// and below them we've got all the Methods, 
// the first one is 

Math.abs()

// WHICH RETURNS THE ABSOLUTE VALUE OF A NUMBER 
// so if you give it a negative number, it returns it's positive value.

// So there are a lot of methods here, I'm not going to go through each of them, 
// it's really a waste of your time and my time, 

// all I want you to know is that we've got this Math object built into Javascript, 
// so IN YOUR APPLICATIONS IF YOU EVER HAVE TO DEAL WITH MATHEMATICAL CALCULATIONS, 
// JUST COME BACK TO THIS PAGE AND SEE WHAT METHODS WE CAN USE. 

// In this lecture I'm going to give you a quick demo of a couple of these methods, 
// the first one is the .random METHOD

Math.random()

// So, let's take a look, for each of these methods we have a comprehensive 
// documentation along with examples. Really, really easy. 

// So here in the console, lets call the random method.

console.log(Math.random());
console.log(Math.random());
console.log(Math.random());
console.log(Math.random());
// output:
// 0.8590424339715734
// 0.9317896805903911
// 0.46605613928953993
// 0.42930733604937044

// So every time we call this method we get a new random number between 0 to 1. 
// Now if you want to map this to a given range you need a simple mathematical formula. 

// Back to the documentation for the random method, 
// if you scroll down from the list of examples, we can see this example. 
// Getting a random number between two values.

function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}

// So basically you need a function like this, that takes a min and
// max, and generates a random number between these two values.
// Pretty self explanatory, you don't need more explanation. 

// Another useful method is Math.round
// so we can give it 1.9, and it returns 2. 

Math.round(1.9)
// output:
// 2

// We also have Math.max
// We can give it a bunch of arguments, 
// and it will return the largest number in the list. 

Math.max(1, 2, 3, 4, 5)
// output:
// 5

// Now later in the course this is going to be one of your exercises. 
// So you're going to write a function like the Math.max method here, 
// that takes a varying number of arguments and returns the largest value. 

// We also have Math.min
// which returns the smallest number in this list. 

Math.min(1, 2, 3, 4, 5)
// output
// 1

// So I leave it up to you to look at all the methods available in the Math object.




// --------------------------------------------------
// 5.12 Objects - String

// The second built in object we're going to look at is the String object, 
// so I'm going to define a constant message and set it to a string. 

const message = "hi";

// Now look at this. 

// message. [VSCode pops up all the properties and methods]

// what's going on here? It looks like we have a bunch of properties and methods. 
// But earlier in the course, I told you that string is a primitive type. 

// Primitive types don't have properties and methods. Only objects do. 
// So why is it that we see these properties and methods in this string? 

// Well, the reason for this is because IN JAVASCRIPT WE HAVE TWO KINDS OF STRINGS. 

// So THIS IS WHAT WE CALL A STRING PRIMITIVE BUT WE ALSO HAVE A STRING OBJECT.

const message = "hi"; // String Primitive

// So we have this constructor object string and we can use that to create a new string object.

String() // Constructor Function to create a new string object

// So we can pass the same string here, now because this is a constructor function 
// we need to apply the new operator and now we have another string. 

const another = new String('hi'); // String object

// Now let's take a look at the type of each of these constants. 
// So typeof message, that's a string, but type of another is an object. 

const message = "hi"; // String Primitive
const another = new String('hi'); // String object

typeof (message);
typeof (another);
// output:
// string
// object

// SO THE FIRST CONSTANT IS A STRING PRIMITIVE, THE SECOND ONE IS AN OBJECT. 

// However, when we use the dot notation with a string primitive 
// JavaScript engine internally wraps this with a string object, 
// we don't see that, but we can work with this like a string object.

// Now just like the Math object, if you want to learn about all these methods, 
// it's best to look at the documentation so simply search for JavaScript string.

// Once again, on developer.mozilla.org on this page you can see all the 
// properties and methods of the string object.

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String

// In this lecture, I'm going to show you a few of these methods, but I strongly
// recommend you to look at the documentation once, just to have a quick look to see
// what methods are there in case you need them. 

// So back to our code let's change this string to this is my first message. 

const message = 'This is my first message';

// Here we have the length property which returns the number of characters in a string. 

message.length();
// output:
// 24

// This is particularly useful in situations where we want to make sure the user types 
// at least a certain number of characters inside an input field. 
// Or maybe you want to put a limit. You don't want the user to type in more than 100 characters. 

// Now if you want to access a character at a given index, you can use square brackets, 
// so, message of 0 returns T, message of 1 returns h. 

message[0];
message[1];
// output:
// T
// h

// If you want to see if the string has a special word, you can use the includes method. 
// So, does this string have my, yes it does, but it doesn't have not.

message.includes('my');
// output:
// true
message.includes('not');
// output:
// false

// We also have another method, startsWith 
// so this string starts with this but if you swap the capitol t here we get false, 
// so note that these searches are case sensitive.

message.startsWith('This');
// output:
// true
message.startsWith('this');
// output:
// false

// We have a similar method, ends with so message.ends with e, 
// so you can see the last character here is e. 

message.endsWith('e');
// output:
// true

// If you want to find the index of a given character or a given string, inside the string, 
// you can use the indexOf method. So let's see what is the index of my. 
// So my starts at index 8.

message.indexOf('my');
// output:
// 8

// We can also replace a part of a string so replace, 
// we want to replace first, with second. Pretty easy. 

message.replace('first', 'second');
// output:
// "This is my second message"

// NOTE THAT THIS RETURNS A NEW STRING AND DOES NOT MODIFY THE ORIGINAL ONE. 
// SO, IF YOU LOG THE ORIGINAL ONE, WE STILL HAVE THIS IS MY FIRST MESSAGE. 

console.log(message);
// output:
// "This is my first message"

// We also have a couple of useful methods toUpperCase, 
// once again this returns a new string where all characters are uppercase, 
// similar to this method, we have toLowerCase

message.toUpperCase();
message.toLowerCase();

// and another useful method is trim. 

// So let me add a couple of white spaces here, before and after our message. 
// Now, if we call trim method, it gets rid of all the white space before and after our message. 

message.trim();

// And of course this method, has variations, for example we have trimLeft,
// which only removes the white space at the beginning of the string
// of trim right, and so on. 

message.trimLeft();
message.trimRight();

// ANOTHER IMPORTANT CONCEPT YOU NEED TO KNOW IN JAVASCRIPT, IS ESCAPE NOTATIOn. 
// So if you look at the documentation for the string object, 
// you can see in this table under escape notation, you've got these special characters. 
// So if you want to use these you need to encode these using the escape notation.

//      Code 	Output
//      \' 	    single quote
//      \" 	    double quote
//      \\ 	    backslash
//      \n 	    new line
//      \r 	    carriage return
//      \v 	    vertical tab
//      \t 	    tab
//      \b 	    backspace
//      \f 	    form feed

// \XXX (where XXX is 13 octal digits; range of 0377) 	ISO-8859-1 character / Unicode code point between U+0000 and U+00FF
// \uXXXX (where XXXX is 4 hex digits; range of 0x00000xFFFF) 	UTF-16 code unit / Unicode code point between U+0000 and U+FFFF
// \u{X} ... \u{XXXXXX} (where XXXXXXX is 16 hex digits; range of 0x00x10FFFF) 	UTF-32 code unit / Unicode code point between U+0000 and U+10FFFF
// \xXX (where XX is 2 hex digits; range of 0x000xFF) 	ISO-8859-1 character / Unicode code point between U+0000 and U+00FF

// For example, let's say you want to have a single quote in your string. 
// Now in this example, you have defined this string with a single code. 
// SO IF YOU WANT TO HAVE A SINGLE CODE INSIDE OF THIS STRING, 
// LOOK, OUR JAVASCRIPT ENGINE GETS CONFUSED, BECAUSE IT THINKS THIS SECOND SINGLE CODE 
// REPRESENTS THE END OF THE STRING. 

// TO FIX THIS, WE NEED TO PREFIX THIS WITH A BACK SLASH, AND NOW, THIS CHARACTER IS ESCAPED
// it's encoded, so when we log the message you can see the single code is actually part of the string.

const message = 'This is my \'first message';
// output:
// This is my 'first message

// Another useful escape character is /n which represents a new line. 
// So back here if we add a /n after my, this will add a new line. So save the changes, 
// let's look at message on the console, you can see we have a new line here.

const message = 'This is my\n first message';
// output:
// This is my
// first message

// Another very useful method, is the split method. 
// So message.split, WITH THIS WE CAN SPLIT A STRING BASED ON A GIVEN CHARACTER. 
// So here I'm going to pass a white space, and see what we get, we get an array of 5 items. 
// And each item in this array is a word in our message. 

message.split(' ');
// output:
// [ 'This', 'is', 'my', 'first', 'message' ]

// Next, we're going to look at template literals.




// --------------------------------------------------
// 5.13 Objects - Template Literals

// In the last lecture you learned that /n adds a new line to a string.
// Now what I don't like about this approach is that it doesn't allow us
// to visualize what the output looks like

// In other words, if we log message on the console, 
// we can see this is what the outcome looks like, 
// so on the first line we have this is my, and on the second line we have first message. 
// But when writing code, our string looks different. 

// Now if you want to make this string similar to what the output looks like, 
// we have to do something like this. 

// So, we break this string into 2 parts, and concatenate them like this, 
// and then we add the second part on a new line. 
// We can also put the first part on a new line. 
// And now this kind of looks similar to what we have in the output. 

const message =
    'This is my \n' +
    'first message';
// output:
// This is my
// first message

// But we still have this \n getting in the way creating some noise in the code. 
// To make the matter worse, if you want to surround first with single quotes, 
// you'll have to escape the single code character like this.

const message =
    'This is my \n' +
    '\'first\' message';
// output:
// This is my
// 'first' message

// Again, this is very very ugly, let's log this one more time, very very ugly and noisy. 

// That's where Template Literals come in the picture. 

// So far you have learned about different kinds of literals in JavaScript. 
// So we have object literals which are indicated by curly braces, 
// we have boolean literals which are true or false. 
// We have string literals which are indicated by single or double quotes. 
// Now starting from ES6 we have template literals. 
// Which are indicated by the back tick character. 

// Object literals      { }
// Boolean literals     true, false
// String literals      '', ""
// Template literals    ``

// This back tick character is the character before number 1 on your keyboard.
// So let's see how template literals help us write cleaner code.

// I'm going to define another constant, 
// but this time I'm going to use a template literal instead of a string literal.

// So, we add the back tick character, this is my, now to add a new line, 
// we don't need to add \n here, we can simply add a line break and then type first message.
// So we can format our string the way we want it to look like. 
// So now, let's log message, and another. See? 
// What we have in code looks very similar to what we have in the output.

const another = `This is my
first message`;
// output:
// This is my
// first message

// Now we can also put this on a new line, 
// now if you want to surround first with single quotes we can simply add them here, 
// there is no  need to escape them. 
// Because we have used a different character to define our string. 
// So save the changes, one more time, message another, they look identical
// but compare this code with the former code.

const another =
    `This is my
'first' message`;
// output:
// This is my
// 'first' message

// This is particularly useful if you want to send out email
// messages in your application. For example, let's say you want to
// send an email to the user like this. 
// So we can format our string exactly the way we want it to look like. 
// There is no need for any of these plus or /n characters. 

const another =
    `Hi John,

Thank you for joining my mailing list.

Regards,
Mosh`;

// So, let me delete all this stuff.

// Now, another benefit of using template literals is that here we can add placeholders. 
// So let's say we want to add the name dynamically,

// With a regular string we'll have to do something like this.
// So message, we set it to hi, then we have to concatenate this with some variable or constant, 
// that we define name here set it to John, 
// now we'll have to concatenate this message with name,
// then add a comma, then \n

const name = 'John';
const message = 'Hi' + name + ',\n'; // this is really, really ugly.

// Let me show you a better way. 
// With template literals, 
// we can add a place holder using a dollar sign and curly braces ${}.

// Now inside these curly braces we add an expression. 
// We can pass the name of a variable or a constant, now let's save the changes, 
// let's take a look at another, you can see we've got John here DYNAMICALLY. 
// So THIS ${name} IS A PLACEHOLDER FOR OUR NAME CONSTANT.

const name = 'John';
const another =
    `Hi ${name},

Thank you for joining my mailing list.

Regards,
Mosh`;
// output:
// Hi John,
//
// Thank you for joining my mailing list.
//
// Regards,
// Mosh

// Now here we can add any kind of expression. We can also add a simple mathematical expression,
// like this, let's log this one more time, so, Hi John 5.

const name = 'John';
const another =
    `Hi ${name} ${2 + 3},

Thank you for joining my mailing list.

Regards,
Mosh`;
// output:
// Hi John 5,
//
// Thank you for joining my mailing list.
//
// Regards,
// Mosh

// So technically 
// WE CAN ADD ANY EXPRESSION THAT PRODUCES A VALUE IN BETWEEN THE CURLY BRACES. 
// WE CAN ALSO CALL FUNCTION THAT RETURNS A VALUE, AND THAT'S PERFECTLY VALID. 

// So these are the benefits of using template literals.




// --------------------------------------------------
// 5.14 Objects - Date

// And finally, the last built in object we're going to look at in this section 
// is the date object. 

// Now just to clarify, the objects that we're looked at in this section 
// they are not the only built in objects in JavaScript, 
// there is more and you're going to learn about them as we go through the course.

// So let's see different ways to create a Date object. 

// We can create date1 set it to new date, so date is a constructor function. 

// Now when you open parenthesis here, you can see this number here, 2 of 6, 
// that shows different versions of this Date constructor. 

// You can use the up and down arrows to cycle through these,
// so we can use the date constructor without any parameters,
// and this returns the current date time. 
// So let's rename this to now.

const now = new Date()

// Let's create another date object, new date, 
// we have another constructor with 1 parameter called value, 
// which can be a string or a number which is the number of milliseconds 
// from January 1st 1970 or another date object.
// So here I'm going to pass a string let's say May 11 2018, 9 AM. 

const date1 = new Date('May 11 2018 09:00');

// Now this format is not the only format that you can pass here, 
// if you want to find out about all possible formats that are supported, 
// simply search for JavaScript date, on this page, if you scroll down, here under dateString, 
// you can read about various formats that are supported. 

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date

// And finally, another way to create a date object, is by passing numbers. 
// So here we have another constructor, with these parameters, year, which is a number,
// month is also number, and then so on. So I'm going to pass 2018, 

// now the confusing thing about Date objects is that month is 0 based. 
// So, 0 represents January, and 11 represents December.
// So we're going to use 4 for May. 

// The third parameter is the date parameter, 
// and that's the day of the month. So, 11

// next parameter is hour, so 9 am, and minutes is 0. 
// Now we can exclude this argument,
// because all the other the arguments are initialized to 0 by default.

// So this is how we create a date object.

const date2 = new Date(2018, 4, 11, 9, 0);

// Now, all these date objects have a bunch of get and set methods. 
// For example, now.get so getDate returns the day of the month. 
// getFull year. getHours, getMilliseconds, getMinutes, so on. 

now.getDate();
now.getDay();
now.getFullYear();
now.getMilliseconds();
now.getMinutes();

// We also have set methods.
// So, let's call setFullYear and change the year to 2017.

now.setFullYear(2017);

// We also have setDate, setHours, setMilliseconds, setMinutes and so on. 

// Alright, now, let's see how we can display this on the console. 

// To save the changes, 
// all these date objects have a few methods for converting them to a string. 
// You can call toDateString and we get a string like this.
// So Thursday May 11 2017, note that we changed the year on line 6.

now.toDateString();
// output:
// Thu Jan 30 2020

// We also have toTimesString which returns the time component of this date object,

now.toTimeString();
// output:
// 11:34:36 GMT+0000 (Greenwich Mean Time)

// and another useful method is to ISOString which returns a string like this. 

now.toISOString();
// output:
// 2020-01-30T11:36:01.034Z

// So we have date, then T, and time, this is a standard ISO format, 
// and it's commonly used in applications, 
// so if you're building a web or a mobile app that talks to a back end. 
// This is the format you commonly use to transfer date between the client and the server.




// --------------------------------------------------
// 6.1 Arrays - Introduction

// In this section, we're going to take a detailed look
// at arrays. You're going to learn all kinds of operations that you can
// perform on arrays, such as:

// adding new elements, 
// finding elements, 
// removing elements, 
// splitting arrays 
// combining arrays 

// and so on. 

// These operations are extremely important in programming,
// especially if you are starting out, so make sure to watch every lecture
// and do the exercises that I have designed for you at the end of this section.
// So now, let's get started.




// --------------------------------------------------
// 6.2 Arrays - Adding Elements

// Alright let's start by DECLARING A CONSTANT called numbers
// and we set this to an array with two elements, 3 and 4.

const numbers = [3, 4];

// Now note that here I've declared numbers as a constant, 
// that means we cannot reassign numbers to something else, 
// if we do this, we get this error assignment to constant variable, 

numbers = [];
//output:
// TypeError: Assignment to constant variable

// however IT'S PERFECTLY FINE TO MODIFY THE CONTENT OF THIS ARRAY. 
// We can add new elements, or remove existing elements. 
// So CONSTANT DOES NOT STOP US FROM MODIFYING THE CONTENT OF AN ARRAY. 
// Okay? 

// So, earlier you have learned that arrays are objects,
// so using the dot notation, 
// we can look at all the properties and methods defined in arrays.

// numbers.

// In this lecture, we're going to look at 3 of these methods,
// so add new elements to the end beginning or middle of an array.

// The first method we're going to use is the PUSH METHOD.
// So

numbers.push();

// we can pass 1 or more arguments, and 
// THESE ARGUMENTS WILL BE PLACED AT THE END OF THIS ARRAY. 
// So I'm going to pass 5 and 6 now let's do a console.log of numbers, save the changes,
// so we have 3 and 4, now we have 5 and 6 at the end. 

numbers.push(5, 6);

console.log(numbers);
// output:
// (3, 4, 5, 6)


// If you want to ADD ELEMENTS TO THE BEGINNING OF AN ARRAY, you use the UNSHIFT METHOD. 
// Let me show you. So, 

numbers.unshift();

// This basically pushes the elements in this array to the right, 
// and adds new elements in the beginning. 
// So, again here we can pass one or more arguments, I'm going to pass 1 and 2, 
// now let's bring this console.log down, and by the way to do this, 
// we can hold down the alt key, and press the up or down arrow. That's a good tip to know. 
// So save the changes, now we have 1 and 2 at the beginning of this array. 

numbers.unshift(1, 2);

console.log(numbers);
// output:
// (1, 2, 3, 4, 5, 6)

// And finally if you want to ADD ELEMENTS TO THE END OF AN ARRAY, you use the SPLICE METHOD. 
// So let's bring this down, 

numbers.splice();

// with this method we can go to a given position, and add new elements or remove existing elements. 
// Later in this section, we're going to look at removing elements, so for now don't worry about that. 

// Now look at the parameters of this method. 
// The FIRST PARAMETER IS A START, which is a number. So that's our starting position. 
// So let's say in this array, after 1 and 2 here, between 2 and 3, we want to add a new element. 

// So our starting position is here. What is the index of this element? 
// Well you know that arrays are 0 index. 
// So the index of the first element is 0 and 1 and here's 2. 

// So our starting position, or starting index is 2.

// Now look at THE SECOND PARAMETER HERE, THAT'S DELETE COUNT WHICH IS A NUMBER. 
// How many elements do we want to delete? In this lecture, none. 
// So I'm going to pass 0 

// and then look at the THIRD PARAMETER. THAT'S THE ITEMS YOU WANT TO ADD. 
// So, to make this stand out, I'm going to add 2 characters here. a and b. 
// Save the changes. So note that a and b are placed after 1 and 2.

numbers.splice(2, 0, 'a', 'b');
console.log(numbers);
// output:
// (1, 2, 'a', 'b', 3, 4, 5, 6)




// --------------------------------------------------
// 6.3 Arrays - Finding Elements (Primitives)

// Alright now let's see HOW WE CAN FIND ELEMENTS IN AN ARRAY. 
// FINDING ELEMENTS REALLY DEPENDS ON IF YOU'RE STORING 
// PRIMITIVE OR REFERENCE TYPES IN AN ARRAY. 

// So I'm going to START WITH PRIMITIVES because they're easier.

// And then I will show you how to find reference types in an array. 

// So, let's say we have an array of numbers, with 4 elements. 1, 2, 3, 4.

const numbers = [1, 2, 3, 4];

// Here we have a method called INDEXOF, 
// we PASS THE ELEMENT WE ARE LOOKING FOR, 
// and IF THAT ELEMENT EXISTS IN THE ARRAY, 
// THIS METHOD WILL RETURN THE INDEX OF THAT ELEMENT IN THE ARRAY.
// IF IT DOESN'T EXIST, IT WILL RETURN MINUS 1.

numbers.indexOf();

// Let me show you a few different examples. 
// So first I'm going to pass the character a, obviously we don't have this element 
// so the result that we'll see will be -1.

numbers.indexOf('a');
// output:
// -1

// Look, so INDEX OF RETURNS THE INDEX OF THE GIVEN ELEMENT IN THIS ARRAY. 
// However, if I change this to 1, we get 0, because the index of this element is 0, 

numbers.indexOf(1);
// output:
// 0

// NOTE THAT THE TYPE OF THIS ELEMENT MATTERS,
// so if I pass 1, as a string here, again we get -1, 
// because we don't have 1 as a string in this array, we have it as a number. Okay? 

numbers.indexOf('1');
// output:
// -1

// Now similar to indexOf, we have another method called lastIndexOf. 
// And that WILL RETURN THE LAST INDEX OF THE GIVEN ELEMENT OR -1 IF IT DOESN'T EXIST. 
// So to demonstrate this, I'm going to add another 1 here, 
// now, let's do another console.log, numbers.lastIndexOf(1). Save the changes. 

const numbers = [1, 2, 3, 1, 4];

numbers.lastIndexOf(1);
// output:
// 3

// So the last index of is 3, because it's here, and the index of this element is 3.

// Okay? So basically to see if a given element exists in an array we can do something like this. 
// Console.log numbers.indexOf(1) is not -1.
// If this expression returns true that means this element exists in the array. 
// Let's have a look, save the changes, we've got true here.

console.log(numbers.indexOf(1) !== -1)
// output:
// true

// But this is a little bit ugly, we have a new method in JavaScript for achieving the same thing.
// So, console.log numbers.includes(1). 
// This simply returns true if the given element exists in the array. 
// Let's have a look, so save the changes and we get true here.

console.log(numbers.includes(1))
// output:
// true

// Now, ALL THESE METHODS HAVE A SECOND PARAMETER WHICH IS OPTIONAL. And THAT IS THE STARTING INDEX. 
// For example, with index of, let's change this to 1 as a number, so save the changes, 
// you can see the index of 1 is 0. Because it's here, right?

// However, I can pass a second argument here, that SECOND ARGUMENT IS FROMINDEX. 
// And that's THE INDEX FROM WHICH THE SEARCH WILL BEGIN. 
// So I can pass 2 here, so that is 0, 1, 2, 
// our search will begin here, let's see what we get. Save the changes, 
// so we get 3 which is the index of the second 1 in this array.

const numbers = [1, 2, 3, 1, 4];

console.log(numbers.indexOf(1, 2));
// output:
// 3




// --------------------------------------------------
// 6.4 Arrays - Finding Elements (Reference Types)

// In the last lecture I told you that FINDING PRIMITIVES IS DIFFERENT THAN FINDING REFERENCE TYPES. 

// So let's see why. 
// I'm going to start by declaring a new array called courses, 
// and in this array we're going to have a couple of course objects. 
// So here's the first one with two properties, id and name the name doesn't really matter, 
// now we can duplicate this line,by holding down shift, alt, and the down arrow.
// So, let's change these values, id2, and name b, and don't forget the semi colon here.
// so we have two course objects here, 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

// LET'S SEE IF WE HAVE A COURSE WITH THE NAME A IN THIS ARRAY, 
// the INCLUDES METHOD that you learned in the last lecture WILL NOT HELP US HERE. 
// Now, let me show you. 

// So courses.includes here we pass the object that we're looking for. 
// So, course with id 1, and name a. 
// Now, let's log this on the console. Console.log save the changes, WE GET FALSE, 

courses.includes({ id: 1, name: 'a' });

console.log(courses.includes({ id: 1, name: 'a' }));
output:
false

// THE REASON FOR THIS IS BECAUSE THESE TWO OBJECTS, 
// THAT IS THE OBJECT THAT YOU ARE PASSING TO THE INCLUDES METHOD, 
// AND THE OBJECT THAT WE HAVE IN THE COURSES ARRAY, 
// THESE ARE TWO DIFFERENT OBJECTS. 
// THEY HAVE TWO DIFFERENT REFERENCES, 
// THEY'RE IN TWO DIFFERENT LOCATIONS IN MEMORY.

// And in the last section, you learned that objects are reference types 
// so when we check them for their equality their references are checked. 

// In this case, there are two different references, that's why we get false. 

// So IF YOU HAVE AN ARRAY WITH REFERENCE TYPES, 
// you need to USE THE FIND METHOD. 

//Let me show you. So I'm going to delete this line, 

courses.find();

// Now look at the parameter of this method. What we see is way to complicated. 
// So, whenever you want to learn about an object or a function in JavaScript, 
// simply search for that. javascript array find 
// Here the first link is from developer.mozilla.org. So, that's a good reference,
// here we can find a good description of what this method does
//  and a very simple example of using that method.

// So here we have an array with a few numbers. 

var array1 = [5, 12, 8, 130, 44];

// We're calling the find method 

var found = array1.find();

// NOTE THAT AS AN ARGUMENT TO THIS METHOD WE HAVE TO PASS A FUNCTION.
// We call this function a PREDICATE, 

var found = array1.find(function (element) {

});

// AND WE USE THAT TO DETERMINE IF THE GIVEN ELEMENT EXISTS IN AN ARRAY OR NOT. 

// So, this function takes a parameter, 
// that's an element in this array. 
// And in the body of this function, 
// we should return a boolean. 

// So here we have a simple expression 
// if this element is greater than 10, we'll return true, otherwise we'll return false. 

var found = array1.find(function (element) {
    return element > 10;
});

// So this is what happens when we call the find method and pass this function. 

// This function is executed once for the first element in this array. 

// So in this case 5 will be passed here. 
// 5 is not greater than 10 so we'll return false, and the search will continue. 

// Now this function will be called for the second element in this array. 
// So, 12 will be passed as an argument to this function, and because it's greater than 10, 
// we'll return true and the search will stop here.

// So now, what we'll get here as a result of calling the find method 
// is the first element that matches this criteria. 

// So if you log this found variable on the console, we'll get 12. 

var array1 = [5, 12, 8, 130, 44];

var found = array1.find(function (element) {
    return element > 10;
});

console.log(found);
// output:
// 12

// Now in contrast, IF THERE ARE NO ELEMENTS IN THIS ARRAY THAT MATCHES THIS CRITERIA, 
// WE'LL GET UNDEFINED. 

// Let me show you. So, back to our example, let's say we want to 
// see if we have a course with the name a in this array. 

// So we pass a function. here we call this a PREDICATE or a CALLBACK function, 
// BECAUSE THE FUNCTION IS CALLED BACK AS PART OF FINDING AN ELEMENT IN THIS ARRAY. 

course.find(function ())

// So here we should have a parameter, we can call that element, or course, 
// because  each element in this array is a course object, so it's better to be more explicit, 
// that makes our code more readable and understandable. 

course.find(function (course)) {

}

// So, what is our criteria? We're looking for a course with the name equal to a.
// So, we simply return this and let's store the result in a constant called course. 

course.find(function (course)) {
    return course.name === 'a'
}

// And finally let's log this on the console. Here's the course object, save the changes,
// and that's the course with the name a. We get the complete course object that we have in this array. 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.find(function (course) {
    return course.name === 'a';
});

console.log(course);
// output:
// { id: 1, name: 'a' }

// Now if I change the search criteria to something like this. xyz,
// obviously we don't have a course with this name, so when we save the changes,
// we get undefined. 

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.find(function (course) {
    return course.name === 'xyz';
});

console.log(course);
// output:
// undefined

// So here's our find method, it returns the first element that matches this criteria. 

// We have a similar METHOD CALLED findIndex, 
// it works exactly the same but instead of returning the actual object, like the course object, 
// IT WILL RETURN IT'S INDEX. 
// Let me show you. 

// So I want to change this to find index, in this case we don't have a course with this name,
// so, when I save the changes, we should see minus 1 on the console. Here it is.

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.findIndex(function (course) {
    return course.name === 'xyz';
});

console.log(course);
// output:
// -1

// Now if I change this back to a and save the changes, we get 0, 
// because THE INDEX OF THE FIRST ELEMENT THAT MATCHED THIS CRITERIA IS 0.

const courses = [
    { id: 1, name: 'a' },
    { id: 2, name: 'b' },
];

const course = courses.findIndex(function (course) {
    return course.name === 'a';
});

console.log(course);
// output:
// 0




// --------------------------------------------------
// 6.5 Arrays - Arrow Functions

// In the last lecture you learned about this predicate (callback) function 
// that we passed on the find method. 

// In ES6 there is a shorter cleaner way to write the same code using arrow functions.

// So WHENEVER YOU WANT TO PASS A FUNCTION, 
// AS A CALLBACK FUNCTION 
// OR AS AN ARGUMENT FOR A DIFFERENT METHOD, 
// YOU CAN USE THE ARROW FUNCTION SYNTAX.

// Let's see how that works. 

// So, YOU REMOVE THE FUNCTION KEYBOARD, 
// and TO SEPARATE THE PARAMETERS OF THIS FUNCTION FROM IT'S BODY 
// PUT A FAT ARROW IN BETWEEN THEM. 

//This is what we call an ARROW FUNCTION.

const course = courses.find(function (course) {
    return course.name === 'a';
});

const course = courses.find((course) => {
    return course.name === 'a';
});

// Now iF YOUR FUNCTION HAS A SINGLE PARAMETER, WE CAN ALSO GET RID OF THE PARENTHESIS, 
// and this makes your code cleaner, you're removing the noise in the code. 

const course = courses.find(course => {
    return course.name === 'a';
});

// IF YOU DON'T HAVE ANY PARAMETERS, YOU HAVE TO PASS AN EMPTY PARENTHESIS. 

const course = courses.find(() => {
    return course.name === 'a';
});

// In this case we have a single parameter so I'm going to bring that back, 
// and finally 

// IF YOU'RE FUNCTION IS A SINGLE LINE OF CODE AND IS RETURNING A VALUE, 
// we can make this code even shorter. 

// First you GET RID OF THE RETURN KEYWORD, AND THEN YOU REMOVE THE CURLY BRACES, like this. 

const course = courses.find((course) => {
    return course.name === 'a';
});

const course = courses.find((course) => {
    course.name === 'a';
});

const course = courses.find((course) =>
    course.name === 'a'
);

// And finally you can put everything on one line. 

const course = courses.find((course) => course.name === 'a');

// So here's the end result. 

// You read this expression as course goes to course.name equals a. 

// So basically we are finding a course with the name equal to a.




// --------------------------------------------------
// 6.6 Arrays - Removing Elements

// Alright now let's see how we can remove elements from an array. 
// So, start by declaring a new array, numbers, and we set this to 1, 2, 3, 4. 
// Earlier in this section you learned about 3 methods to add new elements to an array. 
// You learned about the push method, which we use to add something at the end of an array.
// You learned about the unshift method that we use for adding elements at the beginning of an array, 
// and the splice method that we use for adding an element somewhere in the middle. 

const numbers = [1, 2, 3, 4];

// Now, when it comes to removing an element, 
// again we can remove an element from
// the end, from the beginning and from the middle. 

// But instead of the push method, we use the pop method. 
// This will REMOVE THE LAST ELEMENT IN THIS ARRAY AND RETURN IT. 

numbers.pop();

// So let's store that in a constant called last. 
// And here I'm going to do a console.log of numbers, so you can see the array 
// after we've popped the last element. And also I'm going to show you this last element. 
// Save the changes. So, here's our array, 1, 2, 3, and you can see the last element is 4. 

const last = numbers.pop();
console.log(numbers);
console.log(last);
// output:
// [1, 2, 3]
// 4

// Now, IF YOU WANT TO REMOVE AN ELEMENT FROM THE BEGINNING YOU USE THE shift METHOD. 
// Similar to the pop method this will return the element that was removed.

// So, we can store that in first, and let's have a look here, save the changes.
// So the first element is 1, now if we log numbers we only have 2 and 3. Pretty easy. 

const first = numbers.shift();
console.log(numbers);
console.log(first);
// output:
// [2, 3, 4]
// 1


// And finally the splice method you learned about earlier, 
// so IF YOU WANT TO REMOVE AN ELEMENT SOMEWHERE IN THE MIDDLE 
// YOU PASS THE INDEX OF THAT ELEMENT. 

// So let's say we want to remove this 3 here. 
// The index of this element is 2, so we pass 2 here,

// and as the SECOND ARGUMENT, WE PASS THE NUMBER OF ELEMENTS WE WANT TO DELETE. 
// We can remove 1 element, 
// and then let's log this on the console, numbers, save the changes,
// let's have a look, so let's note that 3 is removed we have 1, 2 and 4.

numbers.splice(2, 1); // at index 2 remove 1 number
console.log(numbers);
// output:
// [1, 2, 4]

// Now if you want to delete multiple elements, you pass a value greater than 1. 
// So you can delete 2 elements, starting from index 2. 
// Save the changes, so 3 and 4 are removed and we only have 1 and 2. 

numbers.splice(2, 2); // at index 2 remove 2 numbers
console.log(numbers);
// output:
// [1, 2]

// So, to recap, 
// USE THE POP METHOD TO REMOVE THE LAST ELEMENT, 
// USE THE SHIFT METHOD TO REMOVE THE FIRST ELEMENT, 
// AND THE SPLICE ELEMENT TO REMOVE AN ELEMENT SOMEWHERE IN THE MIDDLE OF AN ARRAY.




// --------------------------------------------------
// 6.7 Arrays - Emptying an Array

// So now you know how to remove an element from an array. 
// But what about emptying an array? 
// HOW CAN WE REMOVE ALL THE ELEMENTS IN THIS ARRAY. 
// Well, there are a few different solutions. 

// Here's the first solution.
// WE CAN SIMPLY REASSIGN THIS TO A NEW ARRAY. 

const numbers = [1, 2, 3, 4];
// Solution 1
numbers = [];

// Now in this case, because we have declared this array using 
// const we cannot do this, so we have to change this, to let. 
// Now, let's log numbers on the console, save the changes, so, NOW OUR ARRAY IS EMPTY. 

let numbers = [1, 2, 3, 4];
// Solution 1
numbers = [];
console.log(numbers);
// output:
// []

// However, note that THIS OLD ARRAY IS STILL IN THE MEMORY, 
// so IF THERE ARE NO OTHER REFERENCES TO THIS OBJECT
// EVENTUALLY IT WILL BE REMOVED BY THE GARBAGE COLLECTOR. 

// So this means if we have let's say another variable called another, 
// and THIS IS ALSO POINTING TO THE SAME OBJECT, 
// THIS ORIGINAL ARRAY WILL NOT BE GARBAGE COLLECTED. 

// So, line 6. When we reassign the numbers variable, 
// now NUMBERS IS POINTING TO A NEW OBJECT IN MEMORY, 
// but ANOTHER IS STILL POINTING TO THE OLD OBJECT. 

// Let me show you. 
// So here, instead of logging numbers, let's log another. 
// Save the changes. So we can see another is still pointing to this array, to the original array,
// but if you look at the numbers, numbers is now pointing to a new object. 
// To a new empty array. 

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers = [];

console.log(numbers);
console.log(another);
// output:
// []
// [ 1, 2, 3, 4 ]

// So this solution works if you do not have any other references to the original array. 

// IF YOU DO HAVE MULTIPLE REFERENCES TO THE ORIGINAL ARRAY, 
// THEN YOU NEED TO USE ONE OF THE OTHER SOLUTIONS. 

// So, I'm going to comment this out, let's look at solution 2, 
// WE CAN SIMPLY SET THE LENGTH PROPERTY TO 0, AND THIS WILL TRUNCATE THE ARRAY.
// IT WILL REMOVE ALL ELEMENTS. 
// So, here we're logging another. 
// Let's also log the original array. Save the changes. 
// YOU CAN SEE THE ORIGINAL ARRAY IS TRUNCATED 
// SO IT DOESN'T MATTER HOW MANY REFERENCES YOU HAVE TO THAT ARRAY. 
// So here's solution 2.

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers.length = 0;

console.log(numbers);
console.log(another);
// output:
// []
// []

// THE OTHER SOLUTION IS TO USE THE SPLICE METHOD. 
// So in the last lecture you learned that with the splice method you can go to a 
// given position and remove one or more elements.
// SO WE CAN START FROM THE FIRST ELEMENT, AND REMOVE ALL ELEMENTS IN THIS ARRAY. 
// How many elements do we have in this array? Well that is numbers.length, okay?
// Save the changes, again, BOTH ARRAYS ARE EMPTY.

let numbers = [1, 2, 3, 4];
let another = numbers;

numbers.splice(0, numbers.length);

console.log(numbers);
console.log(another);
// output:
// []
// []

// And finally the last solution is to use the pop method.
// So, solution 4. So you learned that pop method removes the last element in this array. 
// Now we can put this in a loop, and keep calling this method, 
// as long as we have an element in this array. 
// So WHILE NUMBERS.LENGTH IS GREATER THAN 0, YOU CAN KEEP POPPING ELEMENTS. 
// Save the changes, again, both arrays are empty. 

let numbers = [1, 2, 3, 4];
let another = numbers;

while (numbers.length > 0)
    numbers.pop();

console.log(numbers);
console.log(another);
// output:
// []
// []

// Now this last solution is not something that I recommend you to do, 
// because if you're dealing with a large array, 
// let's say if you have a million objects in this array, 
// there's going to be a performance cost. 
// You're essentially calling this pop method a million times.

// Okay, however that's not the situation with most applications out there,
// unless you work for Google, but in terms of clean coding, you can see this approach
// is pretty noisy, compare that to the first solution. 

// This is very simple, elegant, the only issue it has is it doesn't work if you 
// have multiple references to this array. 

// So MY PERSONAL PREFERENCE IS TO SET THE LENGTH OF THE ARRAY TO 0, 
// but the first solution is also perfectly valid if you have a single reference to your array. 

// And finally similar to the last solution you can see solution 3 is a little bit noisy. 
// So overall, I would go for either solution 2 or solution 1.




// --------------------------------------------------
// 6.8 Arrays - Combining Arrays

// all right now let's see HOW WE CAN COMBINE TWO ARRAYS OR SLICE AN ARRAY INTO TWO PARTS 

// so let's start by declaring two arrays here's the first one we put 1 2 & 3 here 
// and here's the second one I'm gonna add 4 5 & 6 to combine these two arrays 

// WE USE THE CONCAT METHOD 
// so first.concat
// THIS WILL BASICALLY CONCATENATE THE FIRST ARRAY WITH THE SECOND 

// now BOTH ARRAYS ARE UNAFFECTED SO THIS WILL RETURN A NEW ARRAY 
// WHICH IS THE COMBINATION OF THE FIRST AND SECOND ARRAYS 

// so let's store the result in combined 
// and log it on the console combined 
// save the changes so we get 1 2 3 4 5 6 
// pretty easy 

const first = [1, 2, 3];
const second = [4, 5, 6];

const combined = first.concat(second);
console.log(combined);
// output:
// [ 1, 2, 3, 4, 5, 6 ]

// now we have another method that is THE OPPOSITE OF CONCAT THAT IS SLICE 
// AND WE USE THAT TO SLICE AN ARRAY INTO TWO PARTS 
// so let's get the combined array and slice it

combined.slice();

// now there are multiple ways to use this method 

// one way is to pass a zero base index for the start and end 
// so we can start at 2 and finish at 4 
// let's see what we get so let's call that slice and log it on the console

const slice = combined.slice(2, 4);
console.log(slice);
// output:
// [ 3, 4 ]

// so this is what we get
// we went to the combine array 
// started after index 2 so here 
// and finish after index 4 
// so we extracted 3 and 4

// now let me show you ANOTHER WAY TO USE THE SLICE METHOD
// WE CAN EXCLUDE THE END INDEX 
// AND WITH THIS WE GET ALL THE ELEMENTS IN THE ORIGINAL ARRAY 
// STARTING FROM THE GIVEN INDEX so that's the second way

const slice = combined.slice(2);
console.log(slice);
// output:
// [ 3, 4, 5, 6 ]

// and finally the THIRD WAY IS TO EXCLUDE THE STARTING INDEX 
// AND WITH THIS WE GET A COPY OF THE ORIGINAL ARRAY 

const slice = combined.slice();
console.log(slice);
// output:
// [ 1, 2, 3, 4, 5, 6 ]

// so to recap 
// IF YOU WANT TO COMBINE TWO ARRAYS USE THE CONCAT METHOD 
// IF YOU WANT TO SLICE AN ARRAY USE THE SLICE METHOD 

// now one thing you need to understand about both these methods 
// is that IF YOU'RE DEALING WITH PRIMITIVE VALUES 
// THESE PRIMITIVES WILL BE COPIED INTO THE TARGET ARRAY 

// BUT IF YOU HAVE OBJECTS IN YOUR ARRAY THE OBJECTS THEMSELVES ARE NOT COPIED 
// THE REFERENCES ARE COPIED 

// AND THAT MEANS THE ELEMENTS IN BOTH THE INPUT AND OUTPUT ARRAYS 
// WILL POINT TO THE SAME OBJECT 

// let me show you what I mean 

// so for simplicity I'm gonna remove these three numbers here 
// and add an object so an object with ID set to 1

const first = [{ id: 1 }]; // reference type
const second = [4, 5, 6];

// so now WE HAVE A REFERENCE TYPE RIGHT WHEN WE CALL THE CONCAT METHOD 
// THIS OBJECT ITSELF IS NOT COPIED TO THE COMBINED ARRAY ONLY ITS REFERENCE IS COPIED 

// and this means if I go to the first array get the first element 
// which is our object and change its ID to let's say 10 

first[0].id = 10;

// now when we save the changes you can see in the combined array 
// here's the first element that's our object NOTE THAT IT'S ID IS CHANGED
// TO 10 AS WELL 


const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = first.concat(second);

first[0].id = 10;

const slice = combined.slice();

console.log(combined);
console.log(slice);
// output:
// [ { id: 10 }, 4, 5, 6 ]
// [ { id: 10 }, 4, 5, 6 ]

// sO BECAUSE WE'RE DEALING WITH A REFERENCE TYPE THIS OBJECT IS COPIED 
// BY ITS REFERENCE 
// THE SAME PRINCIPLE APPLIES TO THE SLICE METHOD 
// SO AS PART OF SLICING THIS ARRAY IF THE ELEMENTS ARE PRIMITIVE THEY'RE COPIED BY VALUE 
// IF THEY'RE REFERENCE TYPES THEY'RE COPIED BY THEIR REFERENCE




// --------------------------------------------------
// 6.9 Arrays - The Spread Operator

// So in the last lecture, 
// you learned how to use the concat method to combine two arrays.

// Now, there is another way to achieve the same thing using the spread operator in ES6. 

// So I'm going to rewrite this code using the spread operator, 
// and you will see why this approach is cleaner and more flexible. 

// So, I'm going to define combined as a new array, 
// now we want to COMBINE ALL THE ELEMENTS OF THE FIRST ARRAY AND SECOND ARRAY.
// So we USE THE SPREAD OPERATOR like this.

const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = [...first, ...second];

// WHEN WE SPREAD AN ARRAY, ALL IT'S ELEMENTS ARE RETURNED INDIVIDUALLY.
// SO BASICALLY WE'RE DECLARING A NEW ARRAY, AND IN THAT ARRAY, 
// WE'RE ADDING THE INDIVIDUAL ELEMENTS OF THE FIRST AND SECOND ARRAYS. 

// So this piece of code here is exactly like this. 
// [1, 2, 3, 4, 5, 6]

// Okay? So, we can see with the spread operator, 
// we have a better visualization of how these arrays are combined. 

// It's very clear that we have an array and in this array 
// we have all the elements of the first array, followed by all the elements of the second array. 

// Now with this spread operator, we have more flexibility, 
// let's say as part of combining these two arrays, 
// we want to add an element in between them, you can do that easily like this. 
// Or we can add something at the end.

const combined = [...first, 'a', ...second, 'b'];

// Again we can clearly see what the combined array looks like.

// In contrast, if you want to do the same thing using the concat method, 
// our code is going to be more complex.

// So this is how we can use the spread operator to combine two arrays.

// Now in the last lecture, you learned that if you call the slice method 
// without any arguments, this will return a copy of the original array, here.

// So let's call that copy, now once again we can use the spread operator 
// to copy all the elements of an array into a new array.
// So we can rewrite this code like this.

const copy = [...combined];

// Constant, copy, we create a new array, and then spread the combined array.
// So this will return all the elements of the combined array, 
// and put them into this new array.

// ALL CODE 
const first = [{ id: 1 }];
const second = [4, 5, 6];

const combined = [...first, 'a', ...second, 'b'];

const copy = [...combined];

console.log(combined);
console.log(copy);
// output:
// [ { id: 1 }, 'a', 4, 5, 6, 'b' ]
// [ { id: 1 }, 'a', 4, 5, 6, 'b' ]




// --------------------------------------------------
// 6.10 Arrays - Iterating an Array

// So earlier in the section about control flow, 
// you learned about various loops in JavaScript. 

// So in that section, you learned that 
// IF YOU WANT TO ITERATE AN ARRAY YOU CAN USE THE FOR OF LOOP. 

// So for, let, number of numbers, 
// now in each iteration this number will be set to one of the elements in this array.
// So, let's log that on the console.
// We get 1, 2, and 3. 

const numbers = [1, 2, 3];

for (let number of numbers)
    console.log(number);
// output:
// 1
// 2
// 3

// There is also ANOTHER WAY TO ITERATE AN ARRAY, 
// and you may see that approach in some tutorials online. 

// That is USING THE FOR EACH METHOD. 

// So all tHESE ARRAYS HAVE THIS FOR EACH METHOD. 
// THAT TAKES A CALL BACK FUNCTION. 
// SO WE PASS A FUNCTION HERE, THIS FUNCTION TAKES A PARAMETER, IN THIS CASE NUMBER, 
// and in this function we can simply log this number on the console.

// SO WHEN WE CALL THE FOR EACH METHOD, 
// THIS FUNCTION WILL BE EXECUTED FOR EACH ELEMENT IN THE ARRAY. 

// EACH ELEMENT WILL BE PASSED AS AN ARGUMENT TO THIS FUNCTION.
// So, save the changes, again we get 1, 2, 3. 

numbers.forEach(function (number) {
    console.log(number);
});
// output:
// 1
// 2
// 3

// Now as I told you before, WE CAN USE THE ARROW FUNCTION SYNTAX TO SIMPLIFY THIS CODE,
// so we get rid of the function keyword,
// put a fat arrow between the parameters and the body of the function,
// and because we have a single parameter, we can remove the parenthesis,
// and finally we need to remove this semi colon here because we don't have this
// statement in a code block. So here's the end result. 

numbers.forEach(number => console.log(number));
// output:
// 1
// 2
// 3

// Now which approach you choose is more of a personal preference, 
// THERE IS REALLY NO SIGNIFICANT DIFFERENCE BETWEEN THESE TWO WAYS OF ITERATING AN ARRAY. 

// The only thing you need to know is that THIS CALL BACK FUNCTION, 
// THAT WE PASS THROUGH THE FOR EACH METHOD, 
// CAN OPTIONALLY TAKE A SEPARATE PARAMETER AND THAT'S THE INDEX. 

// So here, I'm going to put number in parenthesis to add the second parameter, 
// that's index, now when logging each number, or each element, 
// we can also display it's index. Save the changes,
// and you can see the index of each element in front of it. 

numbers.forEach((number, index) => console.log(index, number));
// output
// 0 1
// 1 2
// 2 3

// We don't get the index with the for of loop, 
// but if you need that we can use the for in loop. 

// Again, its really a tiny issue, 
// just be aware that we have different ways to iterate an array.




// --------------------------------------------------
// 6.11 Arrays - Joining an Array

// Another useful method of arrays is join. 

// So here we have this numbers array 
// let's say we want to join the elements in this array. 
// That's when we use the join method. 
// So we call 

numbers.join()

// now look at this parameter here, separator? 
// Note the question mark. 
// WHENEVER YOU SEE A QUESTION MARK, THAT MEANS THIS PARAMETER IS OPTIONAL, 
// and you can see this type of parameter is a string 
// so here WE CAN OPTIONALLY PASS A STRING AND THIS STRING WILL BE USED AS A SEPARATOR. 

// So let's say we want to join these elements using a comma. 
// So we pass comma as a string here, right? 
// And note that THIS JOIN METHOD RETURNS A STRING. 
// So, we get the result and store it in a constant called joined. 
// Now, let's log it on the console, Save the changes, here's the result.

const numbers = [1, 2, 3];
const joined = numbers.join(',');
console.log(joined);
// output:
// 1,2,3

// ANOTHER USEFUL METHOD THAT GOES HAND AND HAND WITH JOIN IS THE
// SPLIT METHOD, BUT THIS METHOD IS NOT PART OF ARRAYS, IT'S PART OF STRINGS, 
// but let me show you how it works. 

// So lets say we have a string called message like this.
// This is my first message.
// Now we can split the sentence like this. So 

message.split()

// again here we need to pass the separator string 
// so let's say we want to separate this using a white space. 

// NOW THIS SPLIT METHOD WILL RETURN AN ARRAY, 
// so let's call that parts now let's take a look at that array on the console,

const message = 'This is my first message';
const parts = message.split(' ');
console.log(parts);
// output:
// [ 'This', 'is', 'my', 'first', 'message' ]

// okay, so, here's the array, we have five elements here, 
// note that each element in this array is a word in our original message. 

// Now that we have an array we can use the join method, 
// to combine these elements using a separator. So, let's say 

parts.join()

// you can combine them using a hyphen, and store the result in combined and finally
// log it on the console. So here's the result. This is my first message. 

const combined = parts.join('-');
console.log(combined);
// output:
// This-is-my-first-message

// This technique is particularly useful when building a URL slug. 
// Let me show you what I mean by that.

// So, here I've got this page open on stack overflow.com. 
// https://stackoverflow.com/questions/9543518/creating-arrays-in-javascript
// Read the title of this question, "Creating arrays in JavaScript". 
// So here is what the user posted as you can see we have white space in between each word, 
// but we cannot have a white space in url's so if you look at this url here,
// note the title of question, converted to a url slug. 
// So all the white spaces are replaced with a hyphen. 
// So as part of converting the title of the question to a url slug, 
// you'll have to split this string perhaps throw out some of the words, 
// replace some of the words with other words, 
// and then eventually combine them using the hyphen as you can see here.




// --------------------------------------------------
// 6.12 Arrays - Sorting Arrays

// Back to our numbers array, 
// in this lecture I'm going to change the order of these number so they are not sorted, 
// and then I will tell you how to sort them. So let's change them to 2, 3, 1, and remove 1
// now how can we sort this array? Very easy. 

// You have this METHOD CALLED SORT 
// and what this method does is that it CONVERTS EACH ELEMENT HERE TO A STRING 
// AND THEN SORTS THE ELEMENTS IN THE ARRAY. 

// So, let's have a look, so console.log of numbers,
// here's our numbers array sorted. 

const numbers = [2, 3, 1];
numbers.sort();
console.log(numbers);
// output:
// [ 1, 2, 3 ]

// Now another method that is often companion to the sort method is THE REVERSE METHOD.
// AND WITH THIS WE CAN REVERSE THE ORDER OR ELEMENTS IN AN ARRAY.
// So numbers.reverse
// let's log it on the console one more time, now we have 3, 2, 1. 

const numbers = [2, 3, 1];
numbers.reverse();
console.log(numbers);
// output:
// [ 3, 2, 1 ]

// So this sort method is pretty useful. 
// It's very easy to use when you have numbers and strings in an array. 

// But when you have objects like course OBJECTS, 
// IT DOESN'T WORK BY DEFAULT, YOU HAVE TO DO SOME EXTRA WORK. 

// So, let me delete this code here, and define another array. 
// Called courses, here I'm going to add two course objects
// with id 1 and name, let's say Node.js. And another course object with id2, and name JavaScript.

// Now let's say you want to sort this array by name of courses. 
// So JavaScript should come before node.js. 
// So look if I call courses.sort, and then log it on the console,
// nothing is going to happen. You can see Node is still coming first. 

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'JavaScript' },
]

courses.sort();
console.log(courses);
// output:
// [ { id: 1, name: 'Node.js' }, { id: 2, name: 'JavaScript' } ]


// So how can we fix this problem? Very easy. 
// THIS SORT METHOD OPTIONALLY TAKES AN ARGUMENT AND THAT'S A FUNCTION THAT IS USED FOR COMPARISON. 
// SO WHAT DO WE CALL THE SORT METHOD, THIS METHOD GETS TWO OBJECTS IN THIS ARRAY,
// LET'S SAY A AND B, AND COMPARES THEM. 

// NOW IF THEY ARE IN THE RIGHT ORDER, IT WILL SKIP TO THE NEXT FEW ELEMENTS, 
// OTHERWISE IT'S GOING TO REARRANGE THEM. 

// So here we need to pass a function, for comparison, 
// this function should take two parameters, we can call them and a and b, or first and second, 
// doesn't really matter, because a and b is pretty self explanatory here.

courses.sort(function (a, b) {
});

// Now, in this function, if a is less than b, we should return minus 1, 
// if a is greater than b, we should return 1, and if they are equal, we should return 0. 

// So to implement this, you can write code like this. 
// If a.name, that's our first course is less than b.name we're going to return -1, okay?
// Now, the second condition. If a.name is greater than b.name, we're going to return 1, 
// otherwise we return 0. 

// Now, note that here I'M NOT USING ELSE IF, BECAUSE IF THE FIRST CONDITION IS TRUE, 
// THIS THIS RETURN STATEMENT WE'RE GOING TO JUMP OUT OF THIS FUNCTION. 

// So the control will never move to this point. 
// So there is really no need to use the else keyword. 
// It's just adding extra noise in the code. 
// So now, lets run this code one more time, save the changes, 
// inspect this array, we can see that JavaScript is coming first. 
// Beautiful.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'JavaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    if (a.name < b.name) return -1;
    if (a.name > b.name) return 1;
    return 0;
});

console.log(courses);
// [ { id: 2, name: 'JavaScript' }, { id: 1, name: 'Node.js' } ]

// However, if I change this j to a lower case j, and save the changes, see what happens.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'javaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    if (a.name < b.name) return -1;
    if (a.name > b.name) return 1;
    return 0;
});

console.log(courses);
// output:
// [ { id: 1, name: 'Node.js' }, { id: 2, name: 'javaScript' } ]

// This time Node is coming first, so what's going on here? 

// Well, each character in a computer is internally represented using a number. 
// Let me show you. So open up Google and search for ascii table. 
// That is asc with double i.
// ascii is short for American standard code for information interchange. 

// Now, take a look at the second link, so on this table, 
// you can see the numeric representation of each character. 

// So, we are looking at lower case j, it's numeric representation is 106, 
// and n which is used for our node course is 78. 
// We can see 78 is less than 106, that's why our Node course starting with capitol N came first. 
// Now to solve. this problem we should exclude case sensitivity when comparing these names.

// So, we can do something like this, you can declare two constants, 
// let's say nameA, and set it to A.name.toUpperCase. 

// So whatever the name of the first course is, we're going to convert it to uppercase, 
// and we're going to do the same with the second course. 
// Is I'm going to call the second constant, nameE, and set it to b.name.toUpperCase. 

const nameA = a.name.toUpperCase();
const nameB = b.name.toUpperCase();

// Now we have toUpperCase keys, we can compare them. 
// Also, take into account that here we could call two lowercase instead of two uppercase. 
// That's perfectly valid, but what is important is that both these names should be either
// lower case or uppercase.

// Now finally we need to replace the instances of a.name, with name a.

// So I'm going to do multi cursor editing. 
// I've selected a.name, and I'm going to press command and d on Mac, or control d on Windows. 
// We have this second cursor here, as you can see, 
// Now we can delete this and replace it with nameA. Escape, Finished. 
// One more time I'm going to replace b.name command and d, with name e, and escape. 
// Now save the changes now our sort algorithm should work properly.

// So JavaScript came first.

const courses = [
    { id: 1, name: 'Node.js' },
    { id: 2, name: 'javaScript' },
]

courses.sort(function (a, b) {
    // a < b => -1
    // a > b => 1
    // a === b => 0
    const nameA = a.name.toLowerCase();
    const nameB = b.name.toLowerCase();

    if (nameA < nameB) return -1;
    if (nameA > nameB) return 1;
    return 0;
});

console.log(courses);
// output:
// [ { id: 2, name: 'javaScript' }, { id: 1, name: 'Node.js' } ]




// --------------------------------------------------
// 6.13 Arrays - Testing the Elements of an Array

// We have two new methods in modern JavaScript called EVERY AND SOME.

// Very useful methods, so here we have our numbers array,
// let's imagine WE WANT TO CHECK AND SEE IF ALL NUMBERS IN THIS ARRAY
// ARE POSITIVE.

// So, we call NUMBERS.EVERY AND here we PASS A CALLBACK FUNCTION. 

// Here in the intellisense, you can see this callback function has THREE PARAMETERS. 
// VALUE, WHICH IS A NUMBER, BECAUSE HERE WE HAVE AN ARRAY OF NUMBERS. 
// INDEX, WHICH IS THE INDEX OF THIS VALUE AND THE ARRAY, AND AGAIN, THAT'S A NUMBER,
// AND FINALLY THE ARRAY ITSELF. 

// Now when writing this function you don't have to add all these parameters, 
// you can only add ones you need, 
// for example, here I'm going to add the function and I'm only going to add one parameter, 
// value, because I don't care about the index, of these elements,

const numbers = [1, 2, 3];

numbers.every(function (value) {

});


// so, we pass this callback function, and in this function we can check to see if this
// value is a positive number. So, we return value, greater than or equal to zero. 
// If this expression evalues to true, we'll return true, otherwise we'll return false.

numbers.every(function (value) {
    return value >= 0;
});

// Now finally, this method will return a boolean, so we can store it in the constant called 
// allPositive. 

// SO WHEN WE CALL THIS METHOD, this is what's going to happen 
// THIS METHOD WILL RUN THIS FUNCTION ON EVERY ELEMENT IN THIS ARRAY, 
// AS SOON AS IT FINDS AN ELEMENT THAT DOESN'T MATCH THIS CRITERIA, 
// IT'S GOING TO STOP SEARCHING.

// Let me show you. So, let's log allPositive on the console. 
// You can see it's true on the console, because every element, 
// or every number in this array is a positive number.

const numbers = [1, 2, 3];

const allPositive = numbers.every(function (value) {
    return value >= 0;
});

console.log(allPositive);
// output:
// true


// However, if I add -1 here, we get false, 
// and basically as soon as we hit this number, the search will terminate

// so if you have a million other numbers in this array, 
// this every method is not going to call this callback function on those numbers.

const numbers = [1, -1, 2, 3];

const allPositive = numbers.every(function (value) {
    return value >= 0;
});

console.log(allPositive);
// output:
// false

// Now we have a similar METHOD CALLED SOME, and that CHECKS TO SEE IF WE HAVE 
// AT LEAST ONE ELEMENT IN THIS ARRAY THAT MATCHES THIS CRITERIA.

numbers.some

// So if I replace every with some, and save the changes, we're going to see true.
// However, I'm going to change the name of this variable, because this is distracting
// so always pay great attention to the name of your variables and functions, 
// make sure they're explaining the right thing. 

// So press F2, and rename this to atLeastOnePositive. 
// Okay? Save the changes, we get true

const numbers = [1, -1, 2, 3];

const atLeastOnePositive = numbers.some(function (value) {
    return value >= 0;
});

console.log(atLeastOnePositive);
// output:
// true

// so this SOME METHOD WILL RUN THIS CALLBACK FUNCTION ON EVERY ELEMENT IN THIS ARRAY. 
// AS SOON AS IT FINDS AN ELEMENT THAT MATCHES THIS CRITERIA, 
// IT'S GOING TO RETURN TRUE AND THE SEARCH WILL TERMINATE. 
// So, in the current example if we have a million numbers in this array, 
// because the first number matches this criteria, 
// this call back function will be executed only on this first element. 
// So it doesn't matter what we have after the first element. 

// So, to recap,
// EVERY CHECKS TO SEE IF EVERY ELEMENT IN A GIVEN ARRAY MATCHES THE GIVEN CRITERIA, 
// and SOME CHECKS TO SEE IF WE HAVE AT LEAST ONE ELEMENT THAT MATCHES THE GIVEN CRITERIA. 

// Just to let you know, these methods are new in JavaScript, 
// so some older browsers do not support this, but later in the course I'm going to explain
// how to bring these methods in older browsers.




// --------------------------------------------------
// 6.14 Arrays - Filtering an Array

// In this lecture,
// I'm going to show you how to FILTER AN ARRAY BASED ON A SEARCH CRITERIA.

// So back to our numbers array, 
// let's say you want to return only the positive numbers.

// So, we can use the filter method, like this.

numbers.filter();

// Once AGAIN WE NEED TO PASS A CALLBACK FUNCTION, 
// this function has three parameters, value index and array.

// So out of these we only care about value, 
// we don't care about the index
// because I just want to see if the number of the value is positive.

numbers.filter(function (value) {

});

// So function value, now here we can write a simple expression like this,
// if value is greater than or equal to 0.

// So WHEN WE CALL THE FILTER METHOD, THIS METHOD WILL LOOP THROUGH THIS ARRAY, 
// AND EXECUTE THIS CALLBACK FUNCTION FOR EACH NUMBER, FOR EACH ELEMENT.

numbers.filter(function (value) {
    return value >= 0;
});

// Now IF THE ELEMENT MATCHES THIS CRITERIA,
// IT WILL ADD THIS ELEMENT TO A NEW ARRAY, 
// and finally we can get the new array here. So filtered. 
// Let's take a look at the result, filtered,
// so in our filtered array, we only have 1, 2, and 3.

const numbers = [1, -1, 2, 3];

const filtered = numbers.filter(function (value) {
    return value >= 0;
});

console.log(filtered);
// output:
// [ 1, 2, 3 ]

// Now earlier you learned about arrow functions, 
// so THIS IS A GOOD CASE WHERE YOU WOULD USE AN ARROW FUNCTION.
// You have a single line of code, in this function, and we're simply returning a value. 
// So, we get rid of the function keyword, put a fat arrow between the parameter and the body of this function.

// We don't need the parenthesis because we have a single parameter, and because we're simply
// returning a value, we can also exclude the return keyword, as well as the curly braces and then
// put everything on the same line like this.

const filtered = numbers.filter(value => value >= 0);

// Now we can make this code a little bit shorter, 
// so in this case we can use an abbreviation like v for value, or n for number. 
// Because it's obvious that we're working with the numbers array.

// So we filter and we get numbers where number is greater than or equal to zero.

const filtered = numbers.filter(n => n >= 0);

// Now here we're dealing with an array of numbers, in a real world application, 
// you will be using an array of objects.

// For example, here on the yelp website, you can click this button to 
// find only the restaurants that are open now.

// So this is one kind of filtering. 

// So if you want to implement something like this, 
// instead of an array of numbers you would have an array of restaurants, 
// and each restaurants has opening hours so you could filter restaurants that are currently open
// and return them.




// --------------------------------------------------
// 6.15 Arrays - Mapping an Array

// Another very useful and powerful method we have in JavaScript is THE MAP METHOD. 
// With this method WE CAN MAP EACH ITEM IN THE ARRAY TO SOMETHING ELSE. 

// So following from the example in the last lecture, we have an array of positive numbers 
// let's say we want to construct some HTML markup, using the elements in this array. 

// So we call 

filtered.map();

// and once again we need to pass a callback function here. 

// This function just like the function that we passed to the filter method 
// CAN HAVE THREE PARAMETERS. VALUE, INDEX, AND ARRAY.

// So in this case, again, we're going to work only with the value 
// so we can pass a function or an arrow function. 
// So we get a number some html markup. 
// So we can add a string, with an opening list item element.
// Then we add the number, then finally the closing list item element. 

filtered.map(n => '<li>' + n + '</li>');

// So with this markup, we can display each number using a bullet point. 
// Of course we need to put these inside of a ul element, 
// and I'm going to show you that in a second. 

// So, let's see the result of the map method. I'm going to store the
// result in a constant called items, and now, let's display this on the console. 

const numbers = [1, -1, 2, 3]
const filtered = numbers.filter(n => n >= 0);

const items = filtered.map(n => '<li>' + n + '</li>');

console.log(items);
// output:
// [ '<li>1</li>', '<li>2</li>', '<li>3</li>' ]

// So, you can see each number is now mapped to a string, that's our list item. 

// So now we have an array of strings, we can use the join method that you 
// learned about earlier to join the elements of this array and create a string. 

// So, constant, html, we set it to items.join and then, display this on the console. 

const html = items.join();
console.log(html);
// output:
// <li>1</li>,<li>2</li>,<li>3</li>

// Now instead of an array we have a string. 
// Notice that by default comma is used as the separator, 
// we don't want to have comma in our html markup, 
// we just want to combine these using an empty character like this. 
// Save the changes, now comma is gone, 

const html = items.join('');
console.log(html);
// output:
// <li>1</li><li>2</li><li>3</li>


// the only bit that is remaining is the ul element. 
// So the very simple implementation would be like this, 
// you add ul then concatenate it with all these items and finally another ul.
// Save the changes, and here's our html markup to display all these numbers using bullet points.

const html = '<ul>' + items.join('') + '</ul>';
console.log(html);
// output:
// <ul><li>1</li><li>2</li><li>3</li></ul>

// Now later in the course I will show you a more elegant way to implement
// the same thing

// all I want you to take away from this lecture is that 
// WE CAN USE THE MAP METHOD TO MAP EACH ELEMENT IN AN ARRAY INTO SOMETHING ELSE. 

// Now in this example, you are mapping these numbers to strings, 
// but YOU CAN ALSO MAP THEM TO OBJECTS, let me show you another example.

// So I'm going to delete this html, let's expand this a little bit more,

// instead of mapping a number to a string, let's say you want to map them
// to an object. 

// So here I'm going to define an object in this object 
// we want to have a value property and set that to this number. 
// And finally you want to return this object. Let's look at the result.

const numbers = [1, -1, 2, 3]
const filtered = numbers.filter(n => n >= 0);

const items = filtered.map(n => {
    const obj = { value: n };
    return obj;
});

console.log(items);
[{ value: 1 }, { value: 2 }, { value: 3 }]


// So, let's display the items constant. 
// Now here's the result of our map. 
// We've MAPPED EACH NUMBER TO AN OBJECT WITH A VALUE PROPERTY. 
// Okay? So VERY USEFUL WHEN BUILDING REAL WORLD APPLICATIONS.

// Now let me show you something tricky here, in our callback function
// we are declaring this constant and then returning it. 

// Technically we don't need to declare this as a separate constant, 
// we can simply put the return keyword here and return this object.

// Because we are not working with that constant, with that object
// constant, okay? So, save the changes, you still get the same result

const items = filtered.map(n => {
    return { value: n };
});

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// Now earlier I told you that in your arrow function if you have a single line 
// of code and you're returning an value you can exclude the return keyword 
// as well as the curly braces. So let's do that and see what happens. 
// So remove the return key word, and the curly braces and put everything 
// on one line like this. 
// Now, if we save the changes, we don't get the same result.

const items = filtered.map(n => { value: n });

console.log(items);
// output:
// [ undefined, undefined, undefined ]

// We get an array of 3 undefined elements. 

// The reason for this is by default these curly braces in an arrow function, 
// represent a code block. 
// So when the JavaScript engine tries to parse this arrow function it
// tHINKS HERE WE ARE DEFINING A CODE BLOCK AS OPPOSED TO AN OBJECT TO RETURN. 

// SO IF YOU'RE RETURNING AN OBJECT YOU NEED TO PUT THAT OBJECT IN PARENTHESIS.
// Like this. So, we put this object in parenthesis. 
// And with this our JavaScript engine will not look at this as a code block. 
// Now save the changes, now once again you get 3 objects.

const items = filtered.map(n => ({ value: n }));

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// And one last thing before we finish this lecture.

// SO YOU HAVE NOTICED THAT BOTH THE FILTER AND THE MAP METHOD RETURN A NEW ARRAY, 
// THEY DON'T MODIFY THE ORIGINAL ARRAY, 
// THESE METHODS ARE CHAINABLE 
// WHICH MEANS WE CAN CALL THEM ONE AFTER ANOTHER IN A CHAIN

// so in this case, this filtered constant is only used here. 
// We haven't used this anywhere else in the code.

// So we don't have to explicitly store the result of this statement inside
// a separate constant. 

// We can get rid of this, we call the filter method, 
// now we don't want to have a semi colon here because we are not going to terminate 
// this statement. Instead we're going to immediately call the map method on the result
// that is returned from this statement. 

// So, I'm going to copy our map method here. 
// This is what we call chaining. 

const numbers = [1, -1, 2, 3]
//const filtered = numbers.filter(n => n >= 0);
numbers.filter(n => n >= 0).map(n => ({ value: n }))
//const items = filtered.map(n => ({ value: n }));

// So we're calling 1 method, that method returns some result, 
// now we're immediately calling the map method on that result.

// Now, WHEN CHAINING MULTIPLE METHODS, BY CONVENTION WE PUT EACH METHOD CALL 
// ON A SEPARATE LINE, AND THIS MAKES OUR CODE CLEANER. 

// Have a look. So, numbers.filter and then.map and so on. 

numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }));

// And finally we store the result in the items. 
// That's a better and cleaner code. Save the changes, we still get the same result.

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }));

console.log(items);
// output:
// [ { value: 1 }, { value: 2 }, { value: 3 } ]

// Great, now note that here BECAUSE THE MAP METHOD IS RETUNING A NEW ARRAY, 
// AGAIN WE CAN CALL THE FILTER OR THE MAP METHOD ON THAT ARRAY. 

// So here we can call the filter one more time, we get an object, 
// and maybe we want to get objects with value greater than 1. 
// See what happens?
// Now in the result we have only 1 of 2 objects in our array, objects with value 2 and 3,

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }))
    .filter(obj => obj.value > 1);

console.log(items);
// output:
// [ { value: 2 }, { value: 3 } ]

// and again we can call the map method and maybe map each object to a number. 
// So to read the value property and return it, save the changes, 
// now we have an array of 2 numbers. 

const numbers = [1, -1, 2, 3]

const items = numbers
    .filter(n => n >= 0)
    .map(n => ({ value: n }))
    .filter(obj => obj.value > 1)
    .map(obj => obj.value);

console.log(items);
// output:
// [ 2, 3 ]

// So THIS IS THE POWER OF CHAINING THESE METHODS.




// --------------------------------------------------
// 6.16 Arrays - Reducing an Array

// Once again with our array of numbers, 
// let's say we want to CALCULATE THE SUM OF ALL THESE NUMBERS IN THIS ARRAY.

// This will be similar to calculating the total cost of all the items in a shopping cart.
// So each numbers here could represent the price of an item in a shopping cart,
// of course we wouldn't have a negative number there, but you get the point.

// So here's a very simple algorithm for calculating the sum of all the
// numbers in this array. 

const numbers = [1, -1, 2, 3];

// You start by declaring a variable called sum and we initialize it to 0. 

let sum = 0;

// Next we loop over the array, get each element for each number and add it to sum.
// Something like this.
// for let n of numbers, now we want to add n to sum.

for (let n of numbers) { }

// So we can write an expression like this.
// Sum = sum + n, 

for (let n of numbers)
    sum = sum + n;

// or a better way is to use the addition assignment operator.
// So we can exclude the second sum, so this is exactly like the statement we had before,

for (let n of numbers)
    sum += n;

// and finally we display sum on the console.

const numbers = [1, -1, 2, 3];

let sum = 0;

for (let n of numbers)
    sum += n;

console.log(sum);
// output:
// 5

// So, we get 5. 

// Now THERE IS A CLEANER AND MORE ELEGANT WAY TO WRITE THE SAME CODE 
// USING THE REDUCE METHOD IN ARRAYS.

// So ALL THESE ARRAYS HAVE THIS REDUCE METHOD, 

numbers.reduce();

// and WITH THIS METHOD WE CAN 
// REDUCE ALL THESE ELEMENTS IN AN ARRAY INTO A SINGLE VALUE.

// That single value can be a number, it can be a string, it can be an object, 
// it can be anything.

// In this example, we want to reduce all these elements into a single
// number, that is the sum of all the numbers in this array.

// So let's see how we can use the reduce method. 

// THIS METHOD TAKES A CALLBACK FUNCTION WITH TWO PARAMETERS,
// ACCUMULATOR AND CURRENT VALUE.

// So here I'm using an arrow function. Like this.

numbers.reduce((accumulator, currentValue) => {

});

// This accumulator parameter here is exactly like this sum we have here (let sum = 0).

// It's something that we initialize and this callback function ((accumulator, currentValue) => ) 
// is executed multiple times,
// each time this currentValue will be set to one element in this array (cost numbers).

// So in each call, we want to get this current value and add it to accumulator.
// So we simply return the sum of accumulator plus currentValue.

numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
});

// Now INTERNALLY, THIS REDUCE METHOD WILL GET THIS RESULT (THE RETURN STATEMENT)
// AND STORE IT IN THE ACCUMULATOR, YOU WILL SEE THAT IN A SECOND. 

// And one last thing here, is to initialize this accumulator to 0. 
// So, as the second argument to the reduce method, we pass 0. 

numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Note that THIS REDUCE METHOD HAS TWO ARGUMENTS, THE FIRST ARGUMENT IS A CALLBACK FUNCTION, 
// AND THE SECOND ARGUMENT IS THE INITIAL VALUE FOR THE ACCUMULATOR.

// Finally we get the result as a single value. In this case, sum. 

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Now we don't need this code anymore and finally let's bring this console.log here. 
// Save the changes, you can see we get the same result 5, 

const numbers = [1, -1, 2, 3];

const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

console.log(sum);
// output:
// 5

// but let's see what exactly is happening here.

// So, initially we set accumulator to 0, so I'm going to set a=0. 
// In the first round, current value will be set to the first number. So, c = 1. 

// a = 0, cV = 1 ==> a = 1
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);

// Now we add these together, so we get 1 and a will be set to 1 
// after this callback function is executed. (return accumulator + currentValue;)
// So, as a result a will be 1. 

// Now in a second round, a is 1, 
// current value will be set to the second number in this array. So, minus 1. 
// Now once again we add them together, 
// now a will be 0 after the second call.

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// Now the third call so a is 0, 
// the current value is going to be set to the third element in this array.
// So 2 and as a result a will be 2, 

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// and finally in the last call, we start with a set to 2,
// and current value will be 3. 
// So, the (a) result will be 5, and that's why we saw 5 on the console.

// a = 0, cV = 1 ==> a = 1
// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
// a = 2, cV = 3 ==> a = 5
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
}, 0);


// SO ESSENTIALLY WITH THIS REDUCE METHOD, 
// WE START WITH AN ACCUMULATOR, 
// THEN WE LOOP THROUGH THIS ARRAY, 
/// AND CONVERT ALL THESE ELEMENTS INTO A SINGLE VALUE, 
// WHICH IS IN THIS CASE ACCUMULATOR, OR THE SUM OF ALL THE NUMBERS IN THIS ARRAY.

// Now we can make this code even shorter.
// We can exclude the initialization of the accumulator, and with this, 
// accumulator will be set to the first element. 

// So let me show you what will happen. 

// A will initially be set to 1. 
// And current value will be set to - 1. 
// That is exactly like our second call here. 
// Right ? So as a result, a will be set to 0,

// now in our second round a will be 0,
// and current value will be 2, because in the previous call, 
// current value was here, so now we are here.
// So current value will be 2, and as a result a will be 2, 
// and finally, in the last call, a will be 2, 
// and current value will be 3. 
// The last element in this array and once again we get 5. 

// a = 1, cV = -1 ==> a = 0
// a = 0, cV = 2 ==> a = 2
// a = 2, cV = 3 ==> a = 5
const sum = numbers.reduce((accumulator, currentValue) => {
    return accumulator + currentValue;
});

// So if we supply an initial value (0) we'll have one more call, 
// if we don't the first element in this array will be used as the initial value.

// So this is how the reduce method works.

// And finally, to make this code a little bit shorter, 
// we can get rid of this return keyword, because we have a single line, 
// but we are simply reducing a value. 
// So, remove the return, the semi colon and the curly braces
// put everything on a single line, like this.

const sum = numbers.reduce(
    (accumulator, currentValue) => accumulator + currentValue
);

// So with this single line of code, 
// we reduce the numbers array 
// and this is how our reduction algorithm works.
// We simply get the current value and add it to our accumulator.

// This is far cleaner and more elegant 
// than declaring a sum and then looping over this array 
// like let n of numbers and then add n to the sum, 
// that's a very old way of writing code.

let sum = 0;
for (let n of numbers) {
    sum += n;
}




// --------------------------------------------------
// 7.1 Functions - Function Declarations vs Expressions 


// So you have learned a little bit about functions in JavaScript, 
// in this section we're going to examine functions in more detail. 

// So I'm going to start defining a function called walk and here we do a console.log of walk. 

function walk() {
    console.log('walk');
}

// What we have here is what we refer to as a FUNCTION DECLARATION.

// But in JavaScript THERE IS ANOTHER WAY TO DEFINE A FUNCTION, 
// AND THAT IS USING A FUNCTION EXPRESSION. 

// So we START BY DECLARING A VARIABLE OR A CONSTANT 
// GIVE IT A NAME like run and THEN WE SET THAT TO A FUNCTION. 

let run = function () { }

// So just like we can set a variable to a number, or a string, or an object, 
// WE CAN ALSO SET IT TO A FUNCTION. 

// And you know that in JavaScript functions are objects. 

// So SETTING THE VARIABLE TO A FUNCTION IS SIMILAR TO SETTING IT TO AN OBJECT, okay? 

// And at the end here we need to add a semi colon, 
// because when ever we declare a variable or a constant, 
// we terminate this statement, with a semi colon. 

// So here's another example. We set x to 1, and terminate it with a semi colon. 

let run = function () { }; // terminate it with a semi colon (because its a variable)
let x = 1;

// In contrast, we don't put the semi colon when we define a function 
// using the function declaration syntax,
// it doesn't really matter, so if you run this code you're not going to get any errors, 
// but by convention, we don't do this. 

function walk() {
    console.log('walk');
} // no semi colon here

// So that's one difference between function declarations and function expressions. 

// Now, let's do a console.log, of run here. 
// So basically HERE WE HAVE DEFINED A FUNCTION, AND THIS FUNCTION DOES NOT HAVE A NAME. 
// Its SYNTAX IS VERY SIMILAR TO WHAT WE HAVE IN A FUNCTION DECLARATION,
// except that here we don't have a name, 

let run = function () {
    console.log('run');
};

// WE CAN GIVE IT A NAME and then we would REFER TO THIS AS A NAMED FUNCTION EXPRESSION.

let run = function walk() {
    console.log('run');
};

// Or we CAN EXCLUDE THE NAME and with this we have AN ANONYMOUS FUNCTION EXPRESSION. 
// So WE HAVE DEFINED AN ANONYMOUS FUNCTION THAT DOESN'T HAVE A NAME, 
// AND SET A VARIABLE (run) (a variable) TO REFERENCE THAT FUNCTION.

// So now WE CAN CALL THAT ANONYMOUS FUNCTION USING THIS REFERENCE.
// Just like how we call a function in JavaScript.
// So, save the changes, and we get the run message on the console. 

let run = function () {
    console.log('run');
};
run(); // this is calling the function BY REFERENCE NOT BY NAME 


// Now we can declare another variable, call it move, and set it to run. 

let run = function () {
    console.log('run');
};
let move = run;
run();

// So now both (move) and (run) ARE REFERENCING THE SAME ANONYMOUS FUNCTION, 
// WHICH IS ONE OBJECT IN MEMORY.

// So WE CAN CALL THAT ANONYMOUS FUNCTION USING THIS OTHER REFERENCE (move). 
// So if we call move, we get the same result. 

let run = function () {
    console.log('run');
};
let move = run;
run();
move();

// So to recap, in JavaScript THERE ARE TWO WAYS TO DEFINE A FUNCTION, 
// we can use THE FUNCTION DECLARATION SYNTAX, 
// or FUNCTION EXPRESSION WHICH BASICALLY INVOLVES DECLARING A VARIABLE OR A CONSTANT
// AND THEN SETTING IT TO A FUNCTION. 

// In the next lecture, we'll look at the key difference 
// between a function declaration and a function expression.




// --------------------------------------------------
// 7.2 Functions - Hoisting

// Function Declaration
function walk() {
    console.log('walk');
}

// Function Expression
const run = function () {
    console.log('run');
};

// In the last lecture you learned about function declaration and expression. 
// Now the KEY DIFFERENCE between these two functions, is WE CAN CALL THIS FUNCTION
// THE ONE THAT IS DEFINED USING THE FUNCTION DECLARATION SYNTAX, BEFORE IT IS DEFINED.

// So here, we can call walk, save the changes, and we get this message on the console. 

walk();
// Function Declaration
function walk() {
    console.log('walk');
}

// Function Expression
const run = function () {
    console.log('run');
};
// output:
// walk

// But WE CANNOT DO THIS WITHOUT A FUNCTION THAT IS DEFINED USING THE FUNCTION EXPRESSION SYNTAX. 

// So here, if I call run before it is initialized I get this error. 
// Uncaught reference error. Run is not defined. 

walk();
// Function Declaration
function walk() {
    console.log('walk');
}

run();
// Function Expression
const run = function () {
    console.log('run');
};

// output:
// walk
// ReferenceError: Cannot access 'run' before initialization

// THIS IS EXACTLY LIKE USING A VARIABLE OR A CONSTANT BEFORE IT IS DEFINED. 

// For example, here I'm going to define x, and set it to 1, 
// but I want to log it on the console, before it's declaration. 
// Look, we get the same error. 
// Reference error, x is not defined.

console.log(x);
let x = 1;
// output:
// ReferenceError: Cannot access 'x' before initialization

// So, WE CAN CALL A FUNCTION THAT IS DEFINED USING THE FUNCTION DECLARATION SYNTAX 
// BEFORE IT'S DEFINITION, but why is that? 

// The reason for this is because WHEN OUR JAVASCRIPT ENGINE EXECUTES THIS CODE, 
// IT MOVES ALL THE FUNCTION DECLARATIONS TO THE TOP, 
// SO OUR CODE WILL LOOK LIKE THIS AT RUN TIME. 

// THIS IS WHAT WE CALL HOISTING. 

// So if you are at a job interview and someone asks you "what is hoisting in JavaScript?"
// HOISTING IS THE PROCESS OF MOVING FUNCTION DECLARATIONS TO THE TOP OF THE FILE. 

// And this is done automatically by the JavaScript engine that is executing this code. 
// SO THAT'S THE REASON WE CAN CALL FUNCTIONS THAT ARE DEFINED USING THE FUNCTION DECLARATION SYNTAX
// BEFORE THEIR DEFINITION.




// --------------------------------------------------
// 7.2 Functions - Arguments

// Earlier in the course, you learned that JavaScript is a dynamic language, 
// so we can declare a variable, set it to a number, 
// and then change it's type and set it to a string, 
// and that's perfectly fine from the perspective of a JavaScript engine. 

let x = 1;
x = 'a';

// This is one of the characteristics of a dynamic language. 

// But WE HAVE THE SAME CONCEPT IN THE ARGUMENTS OF A FUNCTION. 

// So I'm going to define a function here call it sum, that has two parameters,
// a and b. And here we simply return the sum of a and b. 
// Now, let's do a console.log, 
// and call the sum function, pass 1 and 2.
// Save the changes, so we get 3.

function sum(a, b) {
    return a + b;
}

console.log(sum(1, 2))
// output:
// 3

// But in JavaScript, it doesn't matter that this function has 2 parameters, 
// we can pass only 1 argument. 
// So in this case we get Not a Number. 
// Because here a is 1 and b BY DEFAULT IS UNDEFINED. 
// So when we have 1 plus undefined, the result is not a number, 
// this is not a valid arithmetic operation. 

function sum(a, b) {
    return a + b; // 1 + undefined
}

console.log(sum(1)); // only 1 of 2 arguments
// output:
// NaN

// The SAME HAPPENS IF WE DON'T PASS ANY ARGUMENTS. 
// So we don't get an error, we get not a number as a result.

function sum(a, b) {
    return a + b; // undefined + undefined
}

console.log(sum()); // no arguments
// output:
// NaN

// By the same token, WE CAN PASS ADDITIONAL ARGUMENTS. 
// So in this case we can pass let's say 5 arguments. 
// And that's perfectly valid JavaScript code. 
// So when you save this, we still get 3, because ONLY THE FIRST 2 ARGUMENTS ARE USED.

function sum(a, b) {
    return a + b;
}

console.log(sum(1, 2, 3, 4, 5)); // only the first 2 arguments are used
// output:
// 3

// But WHAT IF YOU WANT TO HAVE A VARYING NUMBER OF PARAMETERS IN A FUNCTION? 
// WHAT IF YOU WANT TO HAVE THE FLEXIBILITY TO PASS AS MANY ARGUMENTS AS WE WANT, 
// and get their sum. 

// Well, EVERY FUNCTION IN JAVASCRIPT HAS A SPECIAL OBJECT CALLED ARGUMENTS. 
// Let's log this on the console, 

function sum(a, b) {
    console.log(arguments);
    return a + b;
}

console.log(sum(1, 2, 3, 4, 5));

// output:
// [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4, '4': 5 }
// 3

// so THIS IS THE Arguments OBJECT,
// you can see that it kind of looks like an array, 
// but it's not an array, it's an object. 

// But tHE KEYS WE HAVE IN THIS OBJECT ARE INDEXES OF THE ARGUMENTS PASSED TO THIS FUNCTION. 
// So, the first argument is 1, the second argument is 2, and so on. 

// Here we have a LENGTH PROPERTY that returns THE NUMBER OF ARGUMENTS THAT ARE PASSED, 

// length: 5

// we have this CALLEE PROPERTY which returns THE CURRENTLY EXECUTED FUNCTION, 
// so you see we have a reference to our sum function. 

// callee: f sum(a, b)

// So THIS IS THE Arguments OBJECT. 

// Now IF YOU WANT TO HAVE A FUNCTION WITH A VARYING NUMBER OF PARAMETERS TO WORK
// WITH ALL THE ARGUMENTS THAT ARE PASSED TO THIS FUNCTION. 

// So let's say we want to change this function to return the sum of all these arguments. 

// Here's a very simple algorithm. 

// So, we declare a variable called total, set it to 0, then we can use the for of loop. 
// So let value of arguments we can use this loop to iterate over this arguments object. 

function sum(a, b) {
    let total = 0
    for (let value of arguments);
}

console.log(sum(1, 2, 3, 4, 5));

// Now earlier, I told you that we can use THE FOR OF LOOP, on arrays, 
// but TECHNICALLY THIS LOOP CAN BE USED ON ANY OBJECT THAT HAS AN ITERATOR. 

// So THE PLAIN OBJECTS THAT WE CREATE WITH THE OBJECT LITERAL SYNTAX, 
// THEY DON'T HAVE AN ITERATOR, BUT THIS PARTICULAR OBJECT YOU CAN SEE HERE WE HAVE 
// Symbol.iterator THAT MEANS THIS OBJECT HAS AN ITERATOR 
// SO WE CAN USE THE FOR OF LOOP TO ITERATE THIS OBJECT. 

// Now for every argument we're going to get that and add it to our total variable. 
// And finally we will return total.
// Now save the changes, we get 15, 

function sum(a, b) {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5));
// output:
// 15

// we can add another argument, and we get 25. 

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// 25

// Now here's the interesting thing. 
// WE CAN COMPLETELY REMOVE THESE PARAMETERS here (a, b)
// because TECHNICALLY HERE WE'RE WORKING WITH THE
// Arguments OBJECT TO ACCESS THE ARGUMENTS THAT HAVE PASSED HERE. 
// WE'RE NOT REFERENCING THE PARAMETERS (a or b) ANYWHERE IN THE BODY OF THIS FUNCTION. 
// So we can simplify this code and remove these parameters. 

function sum() {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5, 10));

// In the next lecture, we're going to look at a better way to implement this function.

// Baz Additional Practice
function bazStringAddition() {
    let outputString = '';
    for (let eachInputString of arguments)
        outputString = outputString + eachInputString + ' ';
    return outputString;
}

console.log(bazStringAddition('Hello', 'my', 'name', 'is', 'Baz'));
// output:
// Hello my name is Baz




// --------------------------------------------------
// 7.4 Functions - The Rest Operator

// In modern JavaScript, IF YOU WANT TO HAVE A FUNCTION WITH A VARYING NUMBER OF PARAMETERS
// YOU CAN USE THE REST OPERATOR. 

// Let me show you how that works. 

// So here we modify the declaration of this function. 
// Add a parameter, let's call it args, and then prefix it with ... 

(...args)

// THIS IS WHAT WE CALL THE REST OPERATOR. 

function sum(...args) {
    let total = 0;
    for (let value of arguments)
        total += value;
    return total;
}

console.log(sum(1, 2, 3, 4, 5, 10));

// Now don't confuse this with the spread operator, 
// because spread operator looks exactly the same. 

// Earlier we used the spread operator with arrays. 
// So with the spread operator we can spread an array 
// which basically means taking it's individual elements.

// But WHEN WE USE THIS ALONG WITH THE PARAMETER OF A FUNCTION,
// WE REFER TO THIS AS THE REST OPERATOR. 
// And you will know why this is called rest in a second. 

// So, let's see how the rest operator works. 

// I'm going to delete all this code. 
// And simply do a console.log of args. 

// So here we call in this function with 6 arguments, save the changes,
// now here on the console, you can see args is an array of 6 elements.

function sum(...args) {
    console.log(args);
}

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// [ 1, 2, 3, 4, 5, 10 ]
// undefined

// This is a real array. 
// Note that if I remove these three dots, (args)
// that basically means this function has a single parameter called args. 
// So when I save the changes, instead of this array you're going to see one, 
// because the first argument passing through this function is 1. 
// Save the changes, you get 1.

// So here's the lesson. 

// WHEN WE APPLY THE REST OPERATOR TO A PARAMETER OF A FUNCTION, 
// WE CAN PASS A VARYING NUMBER OF ARGUMENTS AND THE REST OPERATOR WILL TAKE ALL OF THEM 
// AND PUT THEM IN AN ARRAY. 

// Now IF YOU WANT TO GET THE SUM OF ALL THE NUMBERS IN AN ARRAY, 
// WE CAN USE THE REDUCE METHOD. 
// YOU LEARNT ABOUT THAT IN THE SECTION ABOUT ARRAYS. 

// So args is an array, 
// we can call the reduce method and pass an arrow function here.
// a and b, => a + b. 
// You've done this before, right? 
// So, you'd simply return the result. 
// Save the changes, and we get 25. 

function sum(...args) {
    return args.reduce((a, b) => a + b);
}

console.log(sum(1, 2, 3, 4, 5, 10));
// output:
// 25


// So you see in modern JavaScript we can achieve the same functionality with less code. 
// INSTEAD OF DEFINING A TOTAL VARIABLE, SETTING IT TO 0, 
// AND THEN LOOPING OVER THE ARGUMENTS OBJECT,
// WE CAN HAVE 1 LINE OF CODE THAT GIVES US THE SAME THING. 
// This is more elegant and more professional. 

// Now let's take this example to the next level. 

// Imagine we're going to use this function to calculate the total costs of items in a shopping cart.

// Here, let's say we want to have a discount factor, 
// so I'm going to add a parameter here, discount, and then rename args to let's say prices. 

function sum(discount, ...prices) {

}

// So we're passing the price of all the items, in a shopping cart, 
// now let's change line 8 where we call the sum function, 

// let's say we're going to pass 0.1 or 10% for the discount, 
// and we have two products in our shopping cart, we have prices 20 and 30 dollars. 

console.log(sum(0.1, 20, 30));

// So here, instead of returning the sum of all the items in the prices array,
// we're going to store the sum here, in total we don't need this anymore. 
// And then we want to return total times 1 - discount.

// So if discount is 0.1 we subtract it from 1, we get 0.9. 
// Then we multiply it by the total and this will return the final price after the discount is applied. 
// Save the changes, so we get 45.

function sum(discount, ...prices) {
    const total = prices.reduce((a, b) => a + b);
    return total * (1 - discount);
}

console.log(sum(0.1, 20, 30));
// output:
// 45

// Now let me show you something, I'm going to add 1 parameter after prices. 
// Let's call that someValue. 
// Now on line 7 where we call this function, 
// let's pass a new value like 1, save the changes, we get this error. 
// Rest parameter must be last formal parameter. 

function sum(discount, ...prices, someValue) {
    const total = prices.reduce((a, b) => a + b);
    return total * (1 - discount);
}

console.log(sum(0.1, 20, 30, 1));
// output:
// SyntaxError: Rest parameter must be last formal parameter

// So WE CANNOT HAVE A PARAMETER AFTER USING THE REST OPERATOR 
// so here prices is the rest parameter, 
// so IT SHOULD BE THE LAST PARAMETER IN THE FUNCTION.

// Let's remove this AND THIS IS THE REASON WE CALL THIS REST. 

// Because WE CAN HAVE 0 OR MORE PARAMETERS BEFORE THIS, 
// in this case we have discount, 
// so we have discount AND THE REST OF THE PARAMETERS, 
// or the rest of the arguments that have passed to this function. 

// That's the reason this operator is called the rest operator.




// --------------------------------------------------
// 7.5 Functions - Default Parameters

// There are times that WE WANT TO SUPPLY DEFAULT VALUES TO THE PARAMETERS OF A FUNCTION.

// For example, let's imagine we want to write a function for calculating the total interest. 

// So here we have there parameters, principle, interest rate and years.

function interest(principal, rate, years) {

}

// And here's the formula, to calculate the total interest. 
// Principle times rate divided by 100 times years. 

function interest(principal, rate, years) {
    return principal * rate / 100 * years;
}

// Now, let's call this function, 
// let's imagine the principle is 10,000 dollars, 
// rate is 3.5 percent,
// and we want to pay this back over 5 years. 
// So let's log this on the console, 
// so the total interest we have to pay is just over 1700. 

function interest(principal, rate, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, 3.5, 5));
// output:
// 1750

// Now, WHAT IF WE WANT TO HAVE DEFAULT VALUES for an interest rate and the number of years. 
// Well, earlier in the section about operators, I showed you a technique like this. 
// So rate equals rate or 3.5.

// So IF RATE HAS A VALUE, IF IT'S TRUTHY, WE'RE GOING TO USE THAT, OTHERWISE WE'RE GOING TO USE 3.5.
// So WE CAN USE THE LOGICAL OR OPERATOR TO GIVE A VARIABLE A DEFAULT VALUE, 
// similarly we can set years, years or 5.

// With this, IF WE EXCLUDE THESE ARGUMENTS (WHEN CALLLING THE FUNCTION)
// THOSE DEFAULT VALUES WILL BE USED. 
// So I'm going to delete these arguments, save the changes, and see we still get the same result. 

function interest(principal, rate, years) {
    rate = rate || 3.5; // if rate has a value it is truthy, (OR) otherwise use 3.5
    years = years || 5; // if years has a value it is truthy, (OR) otherwise use 5

    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// 1750

// But starting from ES6, WE HAVE A CLEANER WAY TO ACTUALLY HAVE THE SAME THING. 
// So INSTEAD OF HAVING THESE LOGICAL EXPRESSIONS

// rate = rate || 3.5;
// years = years || 5;

// WE CAN SET THE DEFAULT VALUES RIGHT HERE (IN THE PARAMETERS). 

// So, we set to rate to 3.5, and years to 5. 
// And now we can delete these two lines, save the changes, you still get the same result,

function interest(principal, rate = 3.5, years = 5) {
    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// 1750

// So we can see that setting the default value for function parameters is really easy. 

// There is just ONE CAVEAT HERE, ONCE YOU GIVE A PARAMETER A DEFAULT VALUE, 
// YOU SHOULD ALSO GIVE ALL THE OTHER PARAMETERS AFTER THAT A DEFAULT VALUE. 

// For example, let's see what happens if we set the default value for rate, but not years.
// When we save the changes, we get Not a Number, 

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000));
// output:
// NaN

// because we passed 10,000, so principle is 10,000, 
// rate is by default 3.5 
// But years doesn't have a value, so it's undefined. 
// That's why the result of this expression is Not a Number. 

// Now what if we passed 5 for the years?

// Well this is confusing for the JavaScript engine because 
// it doesn't know if 5 should be used for rate or the years. 
// So if I save the changes, you still get the same result, not a number.

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, 5));
// output:
// NaN

// Because in this case 5 is used for the rate, but years is still undefined. 

// Now THERE IS A TRICK AROUND THIS, SO, WE CAN PASS UNDEFINED FOR THE SECOND PARAMETER, 
// and with this, rate will be set to 3.5 and years will be set to 5, 
// now we get the same result as before. 

function interest(principal, rate = 3.5, years) {
    return principal * rate / 100 * years;
}

console.log(interest(10000, undefined, 5));
// output:
// 1750

// But code like this is really ugly.
// Somebody looking at this code, they wonder, what is this undefined? 
// They have to look at the function to figure out what parameter is associated with undefined? 

// So as a best practice, WHENEVER YOU WANT TO GIVE A FUNCTION PARAMETER A DEFAULT VALUE, 
// MAKE SURE THAT THAT PARAMETER IS THE LAST PARAMETER IN THE LIST, 
// OR GIVE ALL THE PARAMETERS AFTER THAT A DEFAULT VALUE.



// --------------------------------------------------
// 7.6 Functions - Getters and Setters

// In this lecture, we're going to look at A SPECIAL KIND OF METHODS IN OBJECTS 
// CALLED GETTERS AND SETTERS. 

// So let's imagine we have the person object with two properties.
// First name, set this to Mosh, and last name, set this to Hamedani. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani'
};

// Now somewhere in our application we want to display a person's full name. 
// So, we have to do something like this. 
// Console.log we can either get the person.firstName, 
// concatenate it with space and the last name, 

console.log(person.firstName + ' ' + person.lastName);

// or a better way, as I told you before,is to use a template literal. 
// So we use the back tick and then we add a couple arguments here, 
// so, here's the first one, the argument is person.firstname, 
// now we have a space, and here's the second argument, person.lastname

console.log(`${person.firstName} ${person.lastName}`);

// however, the problem with this approach is maybe there 
// are multiple places in our application where we want to display someone's full name. 

// With the current implementation, we'll have to repeat this template literal in multiple places. 

// A BETTER APPROACH IS TO DEFINE A METHOD IN THIS OBJECT, 
// CALL IT FULLNAME, AND MOVE THIS EXPRESSION RIGHT THERE (inside the console.log()).

// AND THEN WHENEVER WE WANT TO DISPLAY A PERSON'S FULL NAME 
// WE SIMPLY CALL THAT METHOD.

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName: function () { }
};

// So, we can add another key value pair, full name, but we set the value to a function, 
// or as I told you before, IN ES6 WE HAVE A SHORTER SYNTAX, 
// TO ADD A METHOD TO AN OBJECT (SO INSTEAD OF ADDING IT AS A KEY VALUE PAIR), 
// WE CAN ADD IT AS A FUNCTION WITHOUT THE FUNCTION KEYWORD.

// So, (normally) if you want to define a function outside of an object, what do we do?
// We add function, the name of the function, parenthesis, and curly braces.

function fullName() { }

// However, WHEN WE NEED TO ADD THIS INSIDE OF AN OBJECT, WE JUST DROP THE FUNCTION KEYWORD.

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName() { }
};

// So you can see, this new syntax is shorter and cleaner than the older syntax
// fullName: function() {}

// So here's our fullName method, we simply return this expression here. 

// Now with this new implementation, every time we need to display someone's full name, 
// we simply call person.fullname. Save the changes, we get Mosh Hamedani. Beautiful. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    fullName() {
        return `${person.firstName} ${person.lastName}`
    }
};

console.log(person.fullName());
// output:
// Mosh Hamedani

// However, there are a couple problems with this approach.

// The FIRST PROBLEM, IS THAT THIS IS READ ONLY.
// In other words, we cannot set a person's full name from the outside. 

// It would be nice if we could do this, and then the first name and last name properties 
// would be automatically set based on what we passed here.

// The OTHER ISSUE IS THAT I DON'T LIKE TO CALL THIS LIKE A METHOD.
// IT WOULD BE NICER, IF WE COULD TREAT THIS AS A PROPERTY.
// So, we could drop the parenthesis. Like this. 

// So how do we do this? 

// Well, THAT'S WHERE GETTERS AND SETTERS COME IN the picture. 

// We USE GETTERS TO ACCESS PROPERTIES IN AN OBJECT 
// and SETTERS TO CHANGE OR MUTATE THEM. 

// So in this object we should add a getter, 
// and WITH THAT GETTER WE CAN READ THIS person's full name, like a property, 
// and WITH A SETTER WE CAN SET IT from the outside. 

// So here is how it works. 

// WE PREFIX THIS METHOD WITH THE GET KEYWORD, AND NOW THIS METHOD IS A GETTER. 

get fullName() {

}

// So we can access the full name like a property on line 15. 
// Let me temporarily comment out this line, save the changes, 
// you can see our program is still working, beautiful, so THIS IS OUR GETTER, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    }
};

console.log(person.fullName);
// output:
// Mosh Hamedani

// now to be able to set this from the outside we need to add a setter. 
// A setter is very similar. 
// So WE ADD THE SET KEYWORD, THE NAME OF THE PROPERTY OR METHOD, AND THEN CODE BLOCK. 

set fullName(value) {

}

// HOWEVER, THIS METHOD NEEDS A PARAMETER, YOU CAN CALL IT VALUE OR ANYTHING. 
// AND THE VALUE OF THIS PARAMETER WILL BE WHAT WE HAVE IN THE RIGHT SIDE OF THE ASSIGNMENT OPERATOR.

set fullName(value) {

}

person.fullName = 'John Smith'; // this 'John Smith' is value of the "value" PARAMETER of set fullName

// So here let's assume that value is a valid string, 
// we need to split that string by a space, 
// take the parts and set the first name and last name properties. 

// So, value call the split method of string, we want to split it by a space, 
// this will return array, we can call that parts.

// Now we can set the first name to parts of 0, and last name to parts of 1. 
// And finally, instead of logging the person's full name, let's just log the person object. 

// So, initially, we set the first and last name to Mosh Hamedani, 
// now with this new property which is actually a setter, 
// we are changing the name to John Smith. 

// Save the changes, here's our person object, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = 'John Smith';

console.log(person);
// output:
// { firstName: 'John', lastName: 'Smith', fullName: [Getter/Setter] }

// you can see first name and last name properties are updated, also note that full name, 
// it's value is ... 
// Sometimes when you're logging objects in the console, 
// you may see properties with this kind of value. 
// As you can see from the tool tip, this is a getter. 

// In order to read the value you need to click here, 
// and now this method is executed and the result is returned in the console. 
// So this is the benefit of getters and setters. 

// In the next lecture we're going to look at error handling.

// Baz Extra Practice
const phoneNumber = {
    firstPart: '020',
    secondPart: '81234567',
    get fullNumber() {
        return `${this.firstPart} ${this.secondPart}`;
    },
    set fullNumber(value) {
        const arrayFromParts = Array.from(value);
        this.firstPart = arrayFromParts.slice(0, 3).join('');
        this.secondPart = arrayFromParts.slice(3, 13).join('');
    }
};
console.log(phoneNumber.fullNumber); // before with harcoded value
phoneNumber.fullNumber = '02089876543' // use the SETTER on fullNumber
console.log(phoneNumber.fullNumber); // after using Setter
// output:
// 020 81234567
// 020 89876543




// --------------------------------------------------
// 7.7 Functions - Try and Catch

// In the last lecture we assume that the value that we receive here is a
// valid string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = 'John Smith';

console.log(person);

// But what would happen if we pass a boolean here? 
// That doesn't make sense, right? 

// So let's run this code we get this error. 
// Uncaught type error, value.split is not a function. 

// Because split is a method that belongs to strings. 
// Booleans don't have a split method, right? 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = true; // changed to a Boolean

console.log(person);
// output:
// TypeError: value.split is not a function

// What would happen if we pass null or undefined? 
// Save the changes, we get a different error.
// Cannot read property split of null. 

// Again, for the same reason we cannot call the split method on a null, 
// it's only available on a string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// TypeError: Cannot read property 'split' of null

// So here WE NEED TO ADD ERROR HANDLING.

// TYPICALLY, IN SITUATIONS LIKE THIS, WE SHOULD DO ERROR HANDLING
// AT THE BEGINNING OF A FUNCTION OR A METHOD, 
// THIS IS WHAT WE CALL DEFENSIVE PROGRAMMING. 

// So WE WANT TO MAKE SURE THAT THE VALUES COMING IN ARE VALID, 
// THEY'RE IN THE RIGHT SHAPE, SO WE CAN EXECUTE OUR LOGIC. 

// So, the first line of this method should be something like this. 

// You want to make sure that this value is a string.

// So, WE CAN USE THE TYPEOF OPERATOR, 
// if typeof value is not String, then, one simple approach is to return 
// and with this we'll no longer see this error message here. 
// Save the changes, 

// so we can see the person object with the ORIGINAL first name and last name. 
// So what we passed here (person.fullName = null) did not take effect. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string') return;

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// { firstName: 'Mosh', lastName: 'Hamedani', fullName: [Getter/Setter] }


// But SOMETIMES WE WANT TO REPORT AN ERROR IN OUR APPLICATION. 

// THAT'S WHERE WE NEED TO THROW AN EXCEPTION. 

// THROWING AN EXCEPTION IS A TECHNICAL JARGON THAT YOU MIGHT HERE IN A LOT OF
// PROGRAMMING LANGUAGES. 

// So let's see how that works in JavaScript.

// So instead of returning from this method, 
// USE THE THROW KEYWORD AND THEN CREATE A NEW ERROR OBJECT. 

// So new Error, 
// that looks familiar right, 
// so Error IS A CONSTRUCTOR FUNCTION, because here we have the Pascal case.

// And WE'RE CALLING THIS FUNCTION USING THE NEW OPERATOR TO CREATE A NEW Error OBJECT. 
// Right? 

// Now, as an argument we can pass an error message. So value is not a string.
// SO THIS IS HOW WE THROW AN EXCEPTION, 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

person.fullName = null; // changed to null

console.log(person);
// output:
// Error: Value is not a string.


// Now some people confuse errors with exceptions, 
// but there is a slight difference between the two, 

// here WE CAN CREATE AN ERROR OBJECT, let's call it const e = new Error. 
// This is JUST A PLAIN JAVASCRIPT OBJECT, there's NOTHING SPECIAL about this. 

// BUT THE MOMENT YOU THROW THIS ERROR, WE REFER TO THAT AS AN EXCEPTION. 
// So this is an exceptional situation that should not have happened. Okay?

const e = new Error(); // PLAIN JAVASCRIPT OBJECT
throw e; // THE MOMENT WE THROW THIS ERROR, WE REFER TO THAT AS AN EXCEPTION.

// Now, in this method, WE HAVE SOME BASIC ERROR HANDLING,
// SO THIS METHOD IS THROWING AN EXCEPTION, 

// NOW SOMEWHERE ELSE WE NEED TO CATCH THAT EXCEPTION, 

// we need to catch that, and QUITE OFTEN WHEN WE CATCH AN EXCEPTION, 
// WE DISPLAY AN ERROR TO THE USER

// so this is how we accomplish this. 

// Line 15 is where we receive this exception, 

// so WE NEED TO WRAP THIS LINE, IN A TRY BLOCK
// so, try, we move this line (person.fullName = null;) here

// so TRY BLOCK CAN HAVE 1 OR MORE STATEMENTS, 
// ONE OF THESE STATEMENTS AT LEAST CAN THROW AN EXCEPTION, 

// now, WE ADD THE CATCH BLOCK AFTER, IN PARENTHESIS, WE GIVE AN IDENTIFIER, 
// THIS IS THE ERROR OBJECT THAT WE ARE THROWING HERE. 

// SO IN THE CATCH BLOCK WE CAN GET THAT ERROR OBJECT AND
// DO SOMETHING WITH IT. 

// So here, we can display it on the console, 
// but as you know this is only visible to developers, 
// so an end user will not see this error, so temporarily we can use the alert function, 

// this is not something I'd recommend you to do, 
// because that's a very old and poor way of reporting errors to users.

// The proper way is to display a label, perhaps a red label on the user interface, 
// but that's a topic for a future video, so for now let's just use the built in alert function. 

// Now, save the changes, and here's our alert. 
// Value is not a string. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = null; // changed to null
}
catch (e) {
    console.log(e);
}

console.log(person);
// output:
// Error: Value is not a string.


// Now, let's take this to the next level. 
// Instead of passing null, I'm going to pass an empty string. Save the changes,
// we don't get any errors, but first name is an empty string and last name is undefined. 
// Hm, again that's not desirable. 

const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = ''; // changed to empty string
}
catch (e) {
    console.log(e);
}

console.log(person);
// output:
// { firstName: '', lastName: undefined, fullName: [Getter/Setter] }


// So, ideally we want to make sure that our user is typing a first name and last name. 
// So, when splitting that string, we can check the length of this array, 
// so, if parts.length is not 2, that means something is missing. 

// So HERE WE CAN THROW ANOTHER EXCEPTION. 
// throw new Error, with a different message. 
// Enter a first and last name. Okay, now, save the changes, 
// and here's our new exception. Enter a first and last name.


const person = {
    firstName: 'Mosh',
    lastName: 'Hamedani',
    get fullName() {
        return `${person.firstName} ${person.lastName}`
    },
    set fullName(value) {
        if (typeof value !== 'string')
            throw new Error('Value is not a string.');

        const parts = value.split(' ');
        if (parts.length !== 2) // check the length of the array
            throw new Error('Enter a first and last name.') // throw an error

        this.firstName = parts[0];
        this.lastName = parts[1];
    }
};

try {
    person.fullName = '';
}
catch (e) {
    console.log(e);
}

console.log(person);
// Error: Enter a first and last name.

// So, BASICALLY WHEN WE THROW AN EXCEPTION, THE LINES AFTER THE THROW STATEMENT ARE NOT EXECUTED. 
// WE WILL JUMP OUT OF THIS METHOD AND THE CONTROL WILL MOVE TO THE CATCH BLOCK. 
// HERE WE CATCH THE EXCEPTION, AND DO SOMETHING WITH IT. 

// So this is the basics of error handling in JavaScript.




// --------------------------------------------------
// 7.8 Functions - Local vs Global Scope

// In this lecture we're going to talk about A VERY IMPORTANT CONCEPT CALLED SCOPE.

// So I'm going to define a constant called message and set it to hi. 
// Now let's log this in the console so obviously we get hi on the console.

const message = "hi";
console.log(message);
// output:
// hi

// But what would happen if I add this message in a code block? 
// Let's save the changes and see what happens. 
// We get this error. 
// Uncaught reference error, message is not defined. 

{
    const message = "hi";
}
console.log(message); // message is not accesible outside of its scope
// output:
// ReferenceError: message is not defined


// This is all about SCOPING. 

// So A SCOPE OF A VARIABLE OR A CONSTANT, 
// DETERMINES WHERE THAT VARIABLE OR CONSTANT IS ACCESSIBLE.

// And WHEN WE DECLARE VARIABLES OR CONSTANTS WITH LET OR CONST,
// THEIR SCOPE IS LIMITED TO THE BLOCK IN WHICH THEY ARE DEFINED. 

// So message IS ACCESSIBLE IN THIS BLOCK, 
// BUT IT'S NOT ACCESSIBLE OUTSIDE OF THIS BLOCK. 

// Now you might be wondering why do we need this code block here? 

// Well, this code block can be part of a function. 
// So here we can have a function called start. 
// And now WE HAVE A CONSTANT IN THIS FUNCTION. 
// So BECAUSE THE SCOPE OF THIS CONSTANT IS LIMITED TO THE BLOCK IN WHICH IT'S DEFINED, 
// WE CANNOT ACCESS THIS CONSTANT OUTSIDE OF THE start FUNCTION.

function start() {
    const message = 'hi';
}
console.log(message); // message is not accesible outside of its scope
// output:
// ReferenceError: message is not defined

// THE SAME IS TRUE WHEN WE DECLARE A VARIABLE OR A CONSTANT IN AN IF BLOCK.

// So, let's add an if block here, 
// some condition, we don't care, 
// let's declare another constant, and set it to bye.

// Now, THIS CONSTANT IS ONLY ACCESSIBLE IN THIS BLOCK, 
// if I go out of this block, and try to log it on the console, we're going to get an error.

// So, I'm going to remove the last line, let's just call the start function. 
// Save the changes, we get the same error. Reference error. Another is not defined. 

function start() {
    const message = 'hi';

    if (true) {
        const another = 'bye';
    }

    console.log(another); // another is not accesible outside of its scope
}

start();
// output:
// ReferenceError: another is not defined

// We have the same concept in our loops. 
// So let's define a for loop, let i = 0, we're gonna run it 5 times, 
// now i is a variable that is only accessible in this block. 
// So here, we can log i, let's save the changes, we get numbers 0-4. 
// But if we go outside of this for block, and log i, we're going to get the same error. 
// Reference error, i is not defined.

function start() {

    for (let i = 0; i < 5; i++) {
        console.log(i);
    }

    console.log(i); // i is not accesible outside of its scope
}

start();
// output:
// ReferenceError: i is not defined

// Now, let me simplify this code. 
// So we're going to have a function with a constant called message. 
// We can have another function, let's call that stop. 
// And in this function we can have a constant called message, 
// with a different value. 

function start() {
    const message = 'hi';
}

function stop() {
    const message = 'bye';
}

// That's perfectly valid JavaScript code. 

// Because THE SCOPE OF THIS CONSTANT IS LIMITED, TO THE BLOCK IN WHICH IT'S DEFINED.

// So WE CAN HAVE TWO VARIABLES OR CONSTANTS WITH THE SAME NAME 
// BUT IN DIFFERENT FUNCTIONS. That's perfectly valid. 

// Now, WHAT IF WE DEFINE A VARIABLE OR A CONSTANT OUTSIDE OF A FUNCTION? 

// So here I'm going to define a constant, color, and set it to red. 

// Now here we don't have any code blocks, 
// so what do you think is the scope of this constant? 

// THIS CONSTANT HAS GLOBAL SCOPE. 

const color = 'red';

function start() {
    const message = 'hi';
}

function stop() {
    const message = 'bye';
}

// GLOBAL MEANS THIS CONSTANT IS ACCESSIBLE EVERYWHERE, GLOBALLY.

// So we can go to the start function and log color, save the changes 
// you can see we have access to this constant, color, 

// so THIS CONSTANT IS ACCESSIBLE IN ALL THE FUNCTIONS WE HAVE IN OUR PROGRAM.

const color = 'red';

function start() {
    const message = 'hi';
    console.log(color);
}

function stop() {
    const message = 'bye';
}

start();
// output:
// red

// Now WHAT IF WE HAVE A CONSTANT WITH THE EXACT SAME NAME, IN OUR FUNCTION?

// So let's take a look, I'm going to define this color constant, we'll set it to blue.
// What do you think we're going to see when I save the changes, let's take a look.
// We get blue. 

const color = 'red';

function start() {
    const message = 'hi';
    const color = 'blue';
    console.log(color);
}

function stop() {
    const message = 'bye';
}

start();
// output:
// blue

// So, LOCAL VARIABLES, or local constants IN A FUNCTION TAKE PRECEDENCE 
// OVER GLOBAL VARIABLES or global constants. 

// Now in general you should avoid defining global variables or constants, 
// that is considered bad practice. 

// Let me give you a metaphor. 

// Imagine this is a tooth brush, and each function is a person. 
// You don't want to have a tooth brush that is shared between multiple people. 
// Each person should have their own tooth brush. 

// So YOU SHOULD AVOID DEFINING GLOBAL VARIABLES OR CONSTANTS 
// BECAUSE THEY'RE ACCESSIBLE EVERYWHERE, GLOBALLY, 
// AND EACH FUNCTION CAN ACCIDENTALLY CHANGE THEIR VALUE, 
// AND THIS WILL LEAD TO ALL KINDS OF BUGS AND ISSUES IN OUR PROGRAMS.




// --------------------------------------------------
// 7.9 Functions - Let vs Var

// So far we have been declaring variables using the let keyword. 

let x = 0;

// But at the beginning of course, 
// I briefly mentioned that there is another way to declare variables,
// using the var keyword. 

var y = 0;

// And we see this in a lot of JavaScript code online. 

// In this lecture  we're going to look at the var keyword, 
// you're going to LEARN ABOUT THE PROBLEMS WITH THE VAR,
// and why you should avoid it. 

// So let's start by defining a function, start, 
// here we're going to have a loop, let i = 0.
// We're going to run this loop 5 times, and in each iteration 
// we're going to display i on the console. 
// Now, let's call the start function, save the changes, so we get numbers 0-4. 

function start() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
    }
}

start();
// output:
// 0
// 1
// 2
// 3
// 4

// Now in the last lecture you learned that i is only accessible inside this block.
// So if you try to log i outside this block, we're going to get an error, 
// i is not defined. 

function start() {
    for (let i = 0; i < 5; i++) {
        console.log(i);
    }

    console.log(i); // i is not accesible outside of its scope
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// ReferenceError: i is not defined

// Now I just want to clarify something. 

// We still have the same concept if I remove these curly braces, 
// because here WE HAVE A SINGLE STATEMENT, 
// SO THE SCOPE OF I IS STILL THIS BLOCK HERE. 
// Okay? So save the changes, we still get the same error. 

function start() {
    for (let i = 0; i < 5; i++) // start curly brace removed
        console.log(i);
    // end curly brace removed
    console.log(i); // i still not not accesible outside of its scope
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// ReferenceError: i is not defined

// However, LET'S SEE WHAT HAPPENS WHEN WE REPLACE LET WITH VAR.
// Save the changes. What happened to our error?

function start() {
    for (var i = 0; i < 5; i++) // let changed to var
        console.log(i);

    console.log(i);
}

start();
// output:
// 0
// 1
// 2
// 3
// 4
// 5

// So, IT TURNS OUT THAT i IS ACCESSIBLE OUTSIDE OF THIS FOR BLOCK. 

// So in the last iteration, i becomes 5. 
// Because 5 is not less than 5 so the loop terminates, 
// and here on line 6, we're displaying the current value of i. 

// So THIS IS THE ISSUE WITH THE VAR KEYWORD. 

// WHEN YOU DECLARE A VARIABLE WITH VAR. 
// IT'S SCOPE, IS NOT LIMITED TO THE BLOCK IN WHICH IT'S DEFINED. 

// IT'S LIMITED TO THE FUNCTION IN WHICH IT'S DEFINED, 
// AND THIS IS NOT HOW MOST OR ALL PROGRAMMING LANGUAGES OUT THERE WORK.

// It's one of those weird things in JavaScript that we have had for a long time.
// So BEFORE ES6, VAR WAS THE ONLY WAY TO DECLARE VARIABLES AND CONSTANTS. 

// Starting from ES6, also called ES2015, 
// NOW WE HAVE TWO NEW KEYWORDS LET AND CONST, 
// TO DEFINE DIFFERENT VARIABLES AND CONSTANTS. 

// THESE TWO (LET, CONST) KEYWORDS CREATE BLOCK SCOPED VARIABLES,
// BUT VAR CREATES FUNCTION SCOPED VARIABLES.

var x = 1; // FUNCTION SCOPED VARIABLES

let x = 1; // BLOCK SCOPED VARIABLES
const x = 1; // BLOCK SCOPED VARIABLES 

// Let's take a look at another example. 

// So in this for loop, let's add a code block here, 
// now I'm going to add an if statement, 
// now in the if block I'm going to declare a variable using var, 
// color set it to red.

// Now TECHNICALLY IN ALMOST ALL PROGRAMMING LANGUAGES OUT THERE, 
// THIS VARIABLES SHOULD ONLY BE ACCESSIBLE IN THIS IF BLOCK. 

// But because we have used var, color is accessible anywhere in this WHOLE function. 

// So, at the end of this function, you can log color, save the changes, 
// look we get red here.

function start() {
    for (let i = 0; i < 5; i++) {
        if (true) {
            var color = 'red';
        }
    }

    console.log(color);
}

start();
// output:
// red


// But IF WE REPLACE VAR WITH LET, YOU GET AN ERROR, 
// BECAUSE COLOR IS NOT ACCESSIBLE HERE. AND THAT'S HOW MOST LANGUAGES WORK.

function start() {
    for (let i = 0; i < 5; i++) {
        if (true) {
            let color = 'red';
        }
    }

    console.log(color);
}

start();
// output:
// ReferenceError: color is not defined


// So this is the first problem, with the var keyword. 

// THE SECOND ISSUE IS WITH GLOBAL VARIABLES. 

// So let's delete all the code, 
// I'm going to declare two variables,
// one with var color we set it to red, 
// and one with let, Let's say age and set it to 30. 

var color = 'red';
let age = 30;

// NOW WHEN WE USE VAR, OUTSIDE OF A FUNCTION, 
// THIS CREATES A GLOBAL VARIABLE 
// AND ATTACHES THAT GLOBAL VARIABLE TO THE WINDOW OBJECT IN THE BROWSER. 

// So IN BROWSERS WE HAVE THIS WINDOW OBJECT,

// WHICH IS A COMPLEX OBJECT WITH LOTS OF PROPRTIES AND METHODS. 

// WHEN YOU WANT TO BUILD FRONTEND APPLICATIONS YOU'RE GOING TO WORK 
// WITH THIS WINDOW OBJECT A LOT. 

// Now what matters here is THIS VAR KEYWORD ATTACHES THIS COLOR VARIABLE 
// TO THE WINDOW OBJECT. 

// So if you type window. 
// look our color variable is here. 

window.color // does exist (declared with var)

// IN CONTRAST WHEN WE USE THE LET KEYWORD TO DEFINE A GLOBAL VARIABLE, 
// THAT GLOBAL VARIABLE IS NOT ATTACHED TO THE WINDOW OBJECT.

// So, if we type window.age 
// you can see it's undefined.

window.age // doesnt exist (declared with let)

// So WHY IS IT BAD TO ATTACH A WINDOW TO A VARIABLE OBJECT?

// Well, BECAUSE WINDOW OBJECT IS SOMETHING CENTRAL, 
// THERE IS ONLY ONE INSTANCE OF THE WINDOW OBJECT, 
// AND LET'S SAY YOU'RE USING A THIRD PARTY LIBRARY. 

// IF THAT THIRD PARTY LIBRARY ALSO HAS A VARIABLE WITH THE SAME NAME, 
// THAT VARIABLE CAN OVERRIDE YOUR VARIABLE. 

// So you should avoid adding stuff to the window object. 
// Otherwise you're going to create all sorts of issues in your program. 

// Now, for a curious developer, 
// I need to mention that WHEN WE DEFINE A FUNCTION lets say sayHi, 
// THIS FUNCTION IS TECHNICALLY A GLOBAL FUNCTION 
// AND IS ADDED TO THE WINDOW OBJECT. 
// So let me save the changes.
// If you type window.sayHi, see our function is here so we can call it.

function sayHi() {
    console.log('hi');
}

window.sayHi

// So TECHNICALLY THIS IS A GLOBAL FUNCTION, IT'S ATTACHED TO THE WINDOW OBJECT, 
// AND THAT IS BAD PRACTICE. 

// But how can we prevent this? 

// Well, later in the course where I talk about modules, 
// YOU WILL LEARN HOW TO ENCAPSULATE THESE FUNCTIONS IN SEPARATE MODULES 
// SO THEY ARE NOT ADDED TO THE WINDOW OBJECT.

// So here's what I want you to take away from this lecture. 

// AVOID USING THE VAR KEYWORD, 
// BECAUSE IT CREATES VARIABLES THAT ARE FUNCTION SCOPED, NOT BLOCK SCOPED.



// --------------------------------------------------
// 7.10 Functions - the "this" Keyword

// In this lecture, we're going to have a closer look at 
// the "this" keyword in JavaScript, 

// this is one of those features that confuses a lot of developers, 
// but honestly, I think it's because of the poor teaching materials out there, 

// because I personally was confused about the "this" keyword for a long time. 

// So in this lecture I'm going to make it super simple for you, 
// so you can explain it to your 7 year old brother. 

// So what is "this"? 

// "This" REFERENCES THE ***OBJECT*** THAT IS EXECUTING THE CURRENT FUNCTION. 

// Here I'm going to give you a very simple rule of thumb. 

// IF THE FUNCTION IS PART OF AN OBJECT, WE CALL THAT FUNCTION A METHOD, right? 

// So IF THAT FUNCTION IS A METHOD IN AN OBJECT, 
// "this" REFERENCES THAT OBJECT ITSELF. 

// [1] (if the function is part of an object) : 
// METHOD (in an Object) "this" references that object ITSELF

// Othewise,
// IF THAT FUNCTION IS A REGULAR FUNCTION, WHICH MEANS IT'S NOT PART OF AN OBJECT, 
// "this" MEANS THE GLOBAL OBJECT, 
// which is the window object in browsers and global in Node.

// [2] (if it is a regular function (not part of an object) :
// FUNCTION (not part of an Object) "this" references the GLOBAL object 
// (which is the window object in browsers, and global in node)

// Let's take a look at a few examples.

// So, I'm going to start by creating a video object, 
// in this object we're going to have a title property and a play method. 
// Let's log this here, and finally call video.play.
// Save the changes

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

video.play();
// output:
// { title: 'a', play: [Function: play] }

// so we get our video object on the console.
// So in this example, 
// because play is a METHOD IN the video OBJECT, 
// "this" REFERENCES THIS (video) OBJECT ITSELF. 

// By the same token, we can add method later in this object, 
// and we'll get the same result.

// For example, we can add a stop method here, set it to a function, 
// and here we can do console.log of this,
// if we call the stop method, once again we're going to see the video object 
// on the console. So save the changes

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

video.stop = function () {
    console.log(this);
};

video.stop();
// output:
// { title: 'a', play: [Function: play], stop: [Function] }

// and here is our video object.
// Because again, stop IS A METHOD IN THE video OBJECT. 

// SO THAT'S AN EXAMPLE OF THE FIRST RULE.


// Now let's take a LOOK AT AN EXAMPLE OF THE SECOND RULE. 

// A REGULAR FUNCTION. 
// So let's delete this, and instead add a function called playVideo. 
// If we log this on the console, we're going to see the global object 
// which is window in browsers and global in Node.
// So let's call this function playVideo and save the changes 

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

function playVideo() {
    console.log(this);
}

playVideo();
// output:
// Window (in browser)

// so we get the window object here. 

// NOW WHAT IF THIS IS A CONSTRUCTOR FUNCTION?
// WE CALL THE CONSTRUCTOR FUNCTIONS USING THE new OPERATOR.

// So, let's rename play video to video with a capital V, 
// that's the convention for constructor functions, 
// now here we're going to pass a title property, and set this.title = title.

// Now we can use this constructor function to create a new video object.
// So we use the new operator, pass a title, save the changes,

const video = {
    title: 'a',
    play() {
        console.log(this);
    }
};

function Video(title) {
    this.title = title;
    console.log(this);
}

const v = new Video('b');
// output:
// Video { title: 'b' }

// so, what do we get here, 
// instead of a window object, we get a new object, we get this Video object,

// because earlier in the course I told you that when you use the "new" operator
// this "new" operator creates a new empty object like this {}
// and sets "this" in this constructor function to point to this empty object {}. 

// So, here on line 12, we add the title property to this new object.
// this.title = title;

// So let's recap. 
// WHEN DEALING WITH A REGULAR FUNCTION, 
// "this" BY DEFAULT REFERENCES THE GLOBAL OBJECT, 

// bUT IF YOU CALL A FUNCTION, USING THE new OPERATOR, 
// WHICH IS THE CASE FOR CONSTRUCTOR FUNCTIONS, 
// "this" WILL REFERENCE A NEW EMPTY OBJECT. 


// Now THE LAST EXAMPLE. 
// I'm going to clean up this code. 

// Let's add another property in this object, 
// tags, we set it to an array of 3 strings.

// Now let's rename the play method to showTags 

// so here you can use "this" TO GET THE CURRENT OBJECT,
// AND THEN GET THE TAGS PROPERTY, 
// because this is an array we can call the forEach method, 
// and here we need to pass a callback function.

// So function, in each iteration this function will get a tag, 
// and then we can display the tag on the console. 
// So console.log of tag. 

// Finally, let's call video.showTags. 
// Save the changes, so we get a, b, c. Beautiful.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(tag);
        });
    }
};

video.showTags();
// output:
// a
// b
// c

// But what if we want to display the title of the video next to each tag? 
// Well, you can add this.title here, save the changes,

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        });
    }
};

video.showTags();
// output:
// undefined a
// undefined b
// undefined c

// We've got undefined. What's going on here? 
// Well, let's remove the title property and see what "this" is referencing. 
// Save the changes, 

// IT'S REFERENCING THE WINDOW OBJECT, 
// BUT AREN'T WE INSIDE A VIDEO OBJECT HERE? 
// SHOULDN'T THIS REFERENCE THE VIDEO OBJECT? 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        });
    }
};

video.showTags();
// output:
// Window a
// Window b
// Window c


// NO, BECAUSE HERE WE ARE INSIDE THIS CALLBACK FUNCTION (function(tag) {}) 
// THIS FUNCTION IS JUST A REGULAR FUNCTION. 
// IT'S NOT A METHOD IN THE video OBJECT. 
// THE ONLY METHOD WE HAVE HERE IS showTags() {}.

// SO BECAUSE THIS IS A REGULAR FUNCTION (function(tag) {})
// "this" REFERENCES THE GLOBAL OBJECT. 

// SO IT'S THE GLOBAL OBJECT THAT IS EXECUTING THIS ANONYMOUS CALLBACK FUNCTION. 

// But how can we solve this problem 
// and display the title of the video next to each tag?

// Well, we have A FEW DIFFERENT SOLUTIONS FOR THIS, 

// in this particular case, the forEach method has two parameters, 
// THE FIRST PARAMETER IS OUR CALLBACK FUNCTION, 
// THE SECOND PARAMETER IS thisArg? 

// So WE CAN PASS AN OBJECT HERE (as the second parameter) AND THIS WILL REFERENCE THAT OBJECT.

// For example, here I can pass a new object, the firstName, set to Mosh,
// now when we save the changes.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        }, { firstName: 'Mosh' });
    }
};

video.showTags();
// output:
// { firstName: 'Mosh' } a
// { firstName: 'Mosh' } b
// { firstName: 'Mosh' } c

// WE CAN SEE "this" IS REFERENCING THIS NEW OBJECT. 

// Now in this example, we don't really want this object, we want our video object. 
// So we can pass "this" here (where {firsName: 'Mosh'} is). 

// Because at this point, we are in the showTags method, 
// so "this" references the current object. 

// So here (after the {} of the anonymous function(tag)) 
// WE ARE NOT INSIDE OF A CALLBACK FUNCTION. 
// WE ARE STILL IN THE EXECUTION CONTEXT OF THE showTags METHOD. 

// So now if you save the changes

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this, tag);
        }, this);
    }
};

video.showTags();
// output:
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } a
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } b
// { title: 'a', tags: [ 'a', 'b', 'c' ], showTags: [Function: showTags] } c

// next to each tag we can see our video object 
// with this title property, so we can add the title property here, 
// and with this, we see the title of the video next to each tag, beautiful.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        }, this);
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// BUT NOT ALL METHODS IN JAVASCRIPT GIVE YOU THE ABILITY TO PASS THE THIS ARGUMENT.

// So we have a few different solutions for that, 
// and that's the topic for the next lecture.




// --------------------------------------------------
// 7.11 Functions - Changing "this"

// So in the last lecture you learned that 
// "this" REFERENCES THE OBJECT THAT IS EXECUTING THE CURRENT FUNCTION. 

// Alright, now let me show you A FEW DIFFERENT SOLUTIONS
// TO CHANGE THE VALUE OF "this" IN A FUNCTION.

// So, let's imagine our forEach method doesn't have the second parameter. 

// How can we change the value of "this"?

// Well, here's one simple solution. 

// BEFORE WE CALL THE FOREACH METHOD, WE CAN DEFINE A CONSTANT, 
// CALL IT "self" AND SET IT TO "this".  
// const self = this;

// Some people also call this that. 
// It's one of a personal preference there is no right or wrong. 

// So lets call "this" self,
// now at this point, self is referencing the video object here (const video = {}) 

// SO IN OUR CALLBACK FUNCTION WE CAN USE SELF INSTEAD OF THIS.
// BECAUSE THE VALUE OF THIS CHANGES WHEN A NEW FUNCTION IS CALLED.

// SO AT THIS POINT (in the showTags method) "this" REFERENCES THE video OBJECT, 
// BUT WHEN WE GET TO THIS ANONYMOUS CALLBACK FUNCTION (function (tag) { this.title }), 
// "this" REFERENCES THE GLOBAL OBJECT. 

// SO HERE WE CAN USE self.title INSTEAD OF this.title 
// WHICH IS THE ORIGINAL VALUE OF THIS, save the changes, 
// and we get the title of the video here. Beautiful. 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        const self = this;
        this.tags.forEach(function (tag) {
            console.log(self.title, tag);
        });
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// Now this is not the preferred approach, but it's something that you see 
// in a lot of JavaScript applications out there.

// So I JUST WANT YOU TO UNDERSTAND IT BUT DON'T USE THIS APPROACH. 

// Now let's take a LOOK AT ANOTHER APPROACH. 

// Earlier in the course, you learned that functions are objects in JavaScript. 

// So let's define a function call it playVideo, 
// here we do a console.log of "this". 

function playVideo() {
    console.log(this);
}
// output:
// Object [global] {
//  [a lot of text]
// }

// SO THIS FUNCTION IS TECHNICALLY, AN Object. 
// SO IT HAS PROPERTIES AND METHODS THAT WE CAN ACCESS USING THE DOT NOTATION. 

// Here we have 3 METHODS:

// APPLY
// BIND 
// CALL

// AND WITH THESE WE CAN CHANGE THE VALUE OF "this" FOR THIS FUNCTION. 

// THE SIMPLEST IS THE "call" METHOD. 

// THE FIRST PARAMETER OF THIS METHOD IS thisArg, 
// SO HERE WE CAN PASS AN OBJECT AND "this" WILL REFERENCE THAT OBJECT. 

// For example, I can pass a new object with the name property set to Mosh,
// now when we save the changes, we're going to see this object on the console. 

// But before we get there let me temporarily comment out this previous code, 
// so save the changes, you see this new object. 

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' });
// output:
// { name: 'Mosh' }


// IN CONTRAST IF WE CALL THIS FUNCTION USING THE STANDARD FUNCTION CALL SYNTAX,
// "this" REFERENCES THE WINDOW OBJECT. 

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }); // this references this Object
playVideo(); // this references the Window Object
// output:
// { name: 'Mosh' }
// Window

// So THIS IS A BENEFIT OF USING THE "call" METHOD. 


// We have ANOTHER METHOD THAT IS SIMILAR TO CALL AND THAT IS CALLED "apply". 

// So let me duplicate this line, change this to "apply", save the changes, 
// again, we get the same result.

function playVideo() {
    console.log(this);
}

playVideo.call({ name: 'Mosh' });
playVideo.apply({ name: 'Mosh' });
playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window

// SO WHAT WE PASS AS THE FIRST ARGUMENT HERE WILL BE USED AS THE VALUE OF "this", 
// THE DIFFERENCE BETWEEN CALL AND APPLY IS ONLY ABOUT PASSING ARGUMENTS.

// So IF THIS FUNCTION HAS MULTIPLE PARAMETERS, let's say a and b, 
// we can supply multiple arguments here (as the call method's parameters), 1 and 2, 

// BUT WITH THE APPLY METHOD WE HAVE TO PASS THEM AS AN ARRAY. So, [1, 2].
// That's the only difference. 

function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2); // multiple parameters
playVideo.apply({ name: 'Mosh' }, [1, 2]); // mutiple parameters must be passed as an array
playVideo();


// WE HAVE ANOTHER METHOD THAT IS "BIND".

// So playVideo.bind
// once again the first argument is thisArg 
// so we can pass this object { name: Mosh } 

// bUT THIS BIND METHOD DOES NOT CALL OUR playVideo FUNCTION.

// IT RETURNS A NEW FUNCTION, 
// AND SETS "this" TO POINT TO THIS OBJECT { name: Mosh } PERMANENTLY. 

// SO NO MATTER HOW WE CALL THAT FUNCTION, "this" WILL ALWAYS, ALWAYS 
// POINT TO THIS OBJECT THAT WE PASS HERE { name: Mosh }. 

// So this returns the new function
// we can store the result in a constant, 
// and now call this function just like a regular function. 
// Save the changes,


function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2); // multiple parameters
playVideo.apply({ name: 'Mosh' }, [1, 2]); // mutiple parameters must be passed as an array
const fn = playVideo.bind({ name: 'Mosh' });
fn();

playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window

// once again we get this new object here. 

// Now in this particular case we don't really need the separate constant, 
// we can delete const fn and fn(); 
// and immediately call the function that is returned from the bind method. 
// Save the changes, we get the same result. 

function playVideo(a, b) {
    console.log(this);
}

playVideo.call({ name: 'Mosh' }, 1, 2);
playVideo.apply({ name: 'Mosh' }, [1, 2]);
playVideo.bind({ name: 'Mosh' })(); // added () here to call it immediately

playVideo();
// output:
// { name: 'Mosh' }
// { name: 'Mosh' }
// { name: 'Mosh' }
// Window


// SO WITH CALL, APPLY, AND BIND 
// WE CAN SET THE "this" ARGUMENT FOR A GIVEN FUNCTION. 

// Now, let's go back to our previous example. 
// So, let's delete all this code here.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        const self = this; // remove this self constant
        this.tags.forEach(function (tag) {
            console.log(self.title, tag); // change self.title to this.title
        }); // add .bind(this) method to the function (function(tag){}.bind(this));
    }
};

video.showTags();

// Back in the showTags method,
// so here we're passing this callback function, 
// and in this function we're going to use "this". 

// So we no longer need this self constant. 

// However as you know, by default, here "this" references the global object, 
// but we want to change this.

// So here we have a function, WE CAN CALL THE BIND METHOD IMMEDIATELY HERE 
// (AFTER THE {} OF THE ANONYMOUS CALLBACK FUNCTION), 
// AND THEN, PASS AN OBJECT TO BE USED AS THE VALUE OF "this".

// What should we pass here? "this".
// BECAUSE AS I TOLD YOU BEFORE, AT THIS POINT WE ARE IN THE showTags METHOD, 
// SO "this" REFERENCES OUR video OBJECT.

// So, save the changes, and once again you can see the title of the
// video next to each tag.

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(function (tag) {
            console.log(this.title, tag);
        }.bind(this));
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// SO USING THE BIND METHOD IS THE SECOND SOLUTION TO SOLVE THIS PROBLEM, 
// but THERE IS A NEWER AND BETTER SOLUTION.

// Starting from ECMA script 6, WE HAVE ARROW FUNCTIONS.
// THE GOOD THING ABOUT THE ARROW FUNCTIONS IS THAT THEY INHERIT
// THE "this" VALUE. 

// Let me show you what I mean by that. 

// So, let's remove the call to the bind method, 
// and change this function to an arrow function. 

// So we remove the function keyword 
// put a fat arrow between the parameter and the body,
// and because we have a single parameter we remove parenthesis.

// Clear syntax, now if you save the changes, we still get the same result,
// without doing anything extra. 

const video = {
    title: 'a',
    tags: ['a', 'b', 'c'],
    showTags() {
        this.tags.forEach(tag => { // remove function keyword, add fat arrow, single parameter so remove parenthesis
            console.log(this.title, tag);
        });
    }
};

video.showTags();
// output:
// a a
// a b
// a c

// THE REASON FOR THIS IS BECAUSE ARROW FUNCTIONS INHERIT "this" 
// FROM THE CONTAINING FUNCTION. 

// SO IN THIS FUNCTION "this" REFERENCES THE video OBJECT, 
// SO WHEN WE PASS AN ARROW FUNCTION HERE, THE SAME "this" VALUE, 
// IS USED IN THIS ARROW FUNCTION. 

// IN OTHER WORDS "this" IS NOT REBOUND TO A NEW OBJECT. 

// So let's quickly recap.

// In this lecture, you learned about 3 WAYS TO CHANGE THE VALUE OF "this".

// THE FIRST SOLUTION was using the "self" APPROACH

const self = this;

// THE SECOND SOLUTION WAS USING THE "bind" METHOD, 
// so right after defining this function, call bind, and pass this as the argument

(function (tag) { }.bind(this));

// but again this is the old way of doing things, 
// it's a little bit noisy but you may still see it in a lot of JavaScript applications 
// out there. 

// So GOING FORWARD THE MODERN APPROACH TO SOLVE THIS PARTICULAR PROBLEM 
// WHEN DEALING WITH CALLBACKS IS TO USE AN ARROW FUNCTION.

((tag) => { this });




// --------------------------------------------------

// Object Oriented Programming In Javascript

// --------------------------------------------------
// 1.1 Getting Started - What is OOP

// So what is object oriented programming 

// object oriented programming is a programming paradigm or style of programming 
// that is centered around objects rather than function 

// it's nothing new it's been around since the seventies 
// but unlike tools and frameworks that come and go 
// object oriented programming is still very relevant today 

// that's because it's not a programming language or a tool 

// it's a style of programming or a programming paradigm 

// there are several programming languages out there the support object oriented programming 
// such as C# Java Ruby Python Javascript and more 
// now Java script is a little bit controversial but I'll get to that later 

// it may interest you to know that many of the popular frameworks out there 
// that you might be using are actually designed what object oriented programming concepts in mind 
// Angular is an example of these frameworks 

// so object oriented programming is a very popular style of programming 
// and it comes up in many technical interviews 

// so if you really want to be a serious developer 
// you need to understand object oriented programming 

// as a technical interviewer myself if I see a candidate with object oriented programming 
// on the resume that candidate stands out to me 

// and that's where this crash course comes in 

// in this course you're going to learn and understand object oriented principles 
// and how to implement them in Javascript 

// my name is Mosh Hamedani and I'm going to be instructor in this course 
// if you enjoyed this video please like and share it with others 
// and be sure to subscribe to my channel for new videos every week 
// you can also follow me on Twitter as March. So now let's get started. 




// --------------------------------------------------
// 1.2 Getting Started - Four Pillars of OOP

// A popular interview question concerns the 4 core concept in object oriented programming 
// this concepts are encapsulation abstraction inheritance and polymorphism 
// let's look at each of these concepts 

// before object oriented programming we had procedural programming 
// that divided the program into a sort of functions so we have data stored 
// in a bunch of variables and functions that operate on the data 
// this style of programming is very simple and straightforward 
// often it's what you learn as part of your first programming subject at a university 
// but as your programs grow you'll end up with a bunch of functions that are all over the place 
// you would find yourself copying and pasting lines of code over and over 
// you make a change to one function and then several other functions break 
// that's what we call the spaghetti code
// there's so much interdependency between all these functions it becomes problematic

// object oriented programming came to solve this problem 
// in object oriented programming we combined group of related variables and functions into a unit 

// we call that unit an object 
// we refer to this variables as properties 
// and the functions as methods

// here's an example 
// think of a car 
// a car is an object with properties such as make model and color 
// and methods like start stop and move 

// now you might say but Mosh we don't have cars in our programs give me a real programming example
// okay think of the local storage object your browser's 
// every browser as a local storage object that allows you to store data locally 
// this local storage object has a property like length 
// which returns the number of objects in the storage 
// and methods like set item and remove item. 

// So an object oriented programming 
// we group related variables and functions that operate on them into objects 
// and this is what we called ENCAPSULATION 

// let me show you an example of this in action 

let baseSalary = 30000;
let overtime = 10;
let rate = 20;

function getWage(baseSalary, overtime, rate) {
    return baseSalary + (overTime * rate);
}

// so here we have 3 variables base salary over time and rates 
// below these we have a function to calculate the wage for an employee 
// we refer to this kind of implementation as PROCEDURAL 

// so we have variables on one side and functions on the other side they are DECOUPLED. 

// Now let's take a look at the object oriented way to solve this problem 

let employee = {
    baseSalary: 30000,
    overtime: 10,
    rate: 20,
    getWage: function () {
        return this.baseSalary + (this.overtime * this.rate);
    }
};

// we can have an employee object with 3 properties 
// base salary, overTime and rate 
// and the method called getWage 
// now why is this better? 
// well first of all look at the getWage function 
// this function has no parameters 

// in contrast in a procedural example 
// our getWage function has 3 parameters 

// the reason in this implementation we don't have any parameters 
// is because all these parameters are actually modeled as properties of this object 

// all these properties and the getWage function they are highly related 
// so they're part of one unit 

// so one of the symptoms of procedurual code is functions with so many parameters 
// when you write code in object oriented way 
// your functions end up having fewer and fewer parameters 
// as uncle Bob (Robert C Martin) says "the best functions are those with no parameters"
// the fewer the number of parameters the easier it is to use and maintain that function 
// so that's ENCAPSULATION 


// now let's look at ABSTRACTION 
// think of a DVD player as an object 
// this DVD player has a complex logic board on the inside 
// and a few buttons on the outside that you interact with 

// you simply press the play button and you don't care what happens on the inside 
// all the complexity is hidden from you this is ABSTRACTION in practice 

// we can use the same technique in our objects 
// so we can hide some of the properties and methods from the outside 
// and this gives us a couple of benefits 

// first is that we'll make the interface of those objects simpler 
// using an understanding an object with a few properties and methods 
// is easier than an object with several properties and methods 

// the second benefit is that it helps us reduce the impact of change 
// let's imagine that tomorrow we change these inner or private methods 
// none of these changes will lead to the outside. 

// Because we don't have any code that touches these methods outside of their containing object 
// you may delete a method or change its parameters 
// but none of these changes will impact the rest of the applications code 
// so with ABSTRACTION we reduce the impact of change 


// now the third core concept in object oriented programming INHERITANCE
// inheritcance is a mechanism that allows you to eliminate redundant code

// here's an example 
// think of HTML elements like text boxes, drop down lists, checkboxes, and so on 
// all these elements have a few things in common 
// they should have properties like hidden and innerHTML 
// and methods like click and focus 

// instead of redefining all these properties and methods for every type of HTML element 

// we can define them once in a generic object call it HTMLElements 
// and help other objects inherit these properties and methods 

// so INHERITANCE HELPS US ELIMINATE REDUNDANT CODE.

// And finally POLYMORPHISM. 
// Poly means many 
// Morph means form 
// So polymorphism means many forms 
// IN OBJECT ORIENTED PROGRAMMING POLYMORPHISM IS A TECHNIQUE THAT ALLOWS YOU 
// TO GET RID OF LONG if and else or switch and case STATEMENTS 

// so back to our HTML elements example 
// all these objects should have the ability to be rendered on the page 
// but the way each element is rendered is different from the others 

// if you want to render multiple HTML elements in a procedural way 
// our code would probably look like this 

// switch (...) {
//     case 'select': renderSelect();
//     case 'text': renderTextBox();
//     case 'checkbox': renderCheckBox();
//     case ...
//     case ...
//     case ...
// }

// but with object orientation you can implement a render method in each of these objects 
// and the render method will behave differently depending on the type of the object we are referencing. 

// So we can get rid of this nasty switch and case 
// and use one line of code like this 

element.render();

// you'll see that later in the course 

// so here are the benefits of object oriented programming 

// using ENCAPSULATION we group related variables and functions together 
// and this way we can reduce complexity. 
// Now we can reuse these objects in different parts of the program or in different programs 

// with ABSTRACTION we hide the details and the complexity and show only the essentials 
// this technique reduces complexity and also isolates the impact of changes in the code. 

// With INHERITANCE  we can eliminate redundant code 

// and with POLYMORPHISM we can refactor ugly switch case statements.




// --------------------------------------------------
// 1.3 Getting Started - Setting Up The Developement Environment

// To go through this course all you need is a code editor 
// and a simple web server
// the editor that I'm gonna use here is Visual Studio code or VScode 
// that you can download from code that visualstudio.com
// but feel free to use any editors

// now with VSCode we have this extensions panel here
// search for live server
// this is a very simple and lightweight server
// that we're going to use to serve our application 
// so install is and then here in the files panel 

// let's add a new file index.html n
// ow to generate some basic HTML template we can simply type
// an exclamation mark and press tab 
// so a  very basic HTML template 
// now let's add a script element so script with source set
// to index.JavaScript
// we're going to write all our JavaScript code inside of this file 
// so let's add a new file and save it as index.js
// and finally to make sure that we have setup everything properly
// let's do a console that log of hello world 

// now when you install live server you should get this menu here 
// in the status bar 
// if you don't see that you'll probably have to restart vs code 
// and if you still don't see it simply right click on index.html 
// and select open with live server

// so this will fire up Chrome pointing to this address 
// now let's open up Chrome developer tools 
// here in the console tab we've got hello world 

// so before going any further I want to emphasize that
// this course is not for beginners is for intermediate level 
// developers so you should have at least three months of experience 
// programming in JavaScript 

// you should know the basics 
// you should know how to use Chrome developer tools 

// 'm not gonna cover these in this course our focus 
// is purely on object oriented programming with JavaScript




// --------------------------------------------------
// 1.4 Getting Started - Course Structure

// alright before we start our journey 
// let me explain how I've structured this course 
// so you get the most out of it 
// in the next section we're going to look at 
// Objects in JavaScript 

// now chances are you're familiar with some of the concepts 
// that I'm going to explain but please be patient 
// make sure to watch every lecture 

// because we're gonna get really deep 
// to make sure you have an in-depth understanding of objects
// because OBJECTS ARE THE FOUNDATION OF OBJECT ORIENTED PROGRAMMING

// over the next two sections we'll look at PROTOTYPES and PROTOTYPICAL INHERITANCE 

// these are some of the complex parts of JavaScript that a lot of developers 
// find confusing so over these two sections I'm gonna make it super simple for you

// next we will look at CLASSES in ES6 which stands for ECMAScript6 
// now if you don't know what is ECMAScript
// ECMAScript is a specification developed by ECMA which is an organization 
// that defines standards for technologies 

// so EMCA as an organization has developed ECMAScript which is a specification 
// now Javascript is a programming language that conforms to the ECMAScript specification 
// now starting from year 2015 ECMA started to enhance JavaScript 
// so this specification that came out in year 2015 is referred to as EMCAScript 2015 
// or ECMA Script Version 6

// now in this specification we have some new features
// in JavaScript one of them is CLASSES 
// but classes that we have in JavaScript are not like classes we have in languages
// like C sharp or Java because javascript is a dynamically typed language 

// so classes are essentially syntactic sugar over prototypes and prototypical inheritance 

// so that's why we have two sections on these topics in the course

// once you master these, then we'll look at ES6 classes in section 5 

// and finally we'll finish this course by looking at MODULES

// so this is the outline now I want to clarify something here in this
// course unlike my other courses we're not going to build a real application
// because building a real application requires me to talk various topics 
// such as building the user interface or the client app 
// then building apis, working with the database, deployment and so on 

// all these are distraction from the core of this course that is object-oriented programming 

// so I wanted to create a short and sweet course for you 
// to teach you object-oriented programming in JavaScript 

// that's why we're not going to build a real application 
// but to help you master the concepts that you're going to learn 
// in each section I have designed one or two exercises 
// so make sure to spend some time doing these exercises
// and you can also see my solution 

// with all that let's get started




// --------------------------------------------------
// 2.1 Objects - Introduction

// Javascript is all about objects 

// so in order to learn object oriented programming 
// first you need to have a good understanding of objects 

// so in this section I'm gonna cover some fundamental concepts around objects 
// such as creating objects 
// factories and constructors 
// primitives and reference types and how they behave differently 

// working with the properties of an object 
// such as adding removing properties as well as enumerating them 

// we're also going to learn how to define private properties 

// as well as getters and setters

// if you know all these topics well 
// feel free to skip this section and move to the next section 
// where I talk about prototypes 
// otherwise continue watching 

// so now let's get started. 

// CREATING OBJECTS
// FACTORIES AND CONSTRUCTORS
// PRIMITIVES AND REFERENCE TYPES
// WORKING WITH PROPERTIES
// PRIVATE PROPERTIES
// GETTERS / SETTERS




// --------------------------------------------------
// 2.2 Objects - Object Literals

// let's start this section by creating an object

// so I'm gonna use the let keyword in ES6 
// which is the replacement for var 
// so in ES5 and before we had var for declaring variables 
// but var has a number of issues when it comes to scoping
// that's beyond the scope of this course 

// I just want to let you know that as a best practice stop using var 
// use either let or const 

// with const you're basically defining a constant 
// so you won't be able to reassign it 
// if you want to reassign a variable use let

// now in this demo I'm gonna use const to define a constant 
// so let's call this circle and set it to an object 

// here I'm using OBJECT LITERAL SYNTAX

const circle = {};

// so these curly braces we refer to them as object literal syntax 
// AN OBJECT IN JAVASCRIPT IS ESSENTIALLY A COLLECTION OF KEY VALUE PAIRS 

// so inside these curly braces I'm gonna add a few key value pairs 

// let's add radius and set it to 1 let's add another key like location 

const circle = {
    radius: 1,
};

// now this time the value can be an object so again I'm using object
// literal syntax 

// in this object we can have a couple key value pairs like x and y

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
};

// let's add another key value pair 
// so the keys draw 
// the value is a function that is for drawing the circle 
// so for now let's just do a simple console.log 

const circle = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    draw: function () {
        console.log('draw');
    }
};


// now I want to define a few terms here 
// this circle object has three members 
// radius location and draw 
// IF A MEMBER IS A FUNCTION WE REFER TO THAT AS A METHOD
// so here we say draw is a method 
// THESE OTHER MEMBERS ARE WHAT WE CALL PROPERTIES 

// now in some JavaScript tutorials that refer to all these members as properties 
// whether there are functions or not

// but technically in object-oriented programming 
// PROPERTIES AND METHODS ARE FUNDAMENTALLY DIFFERENT 
// because A PROPERTY IS USED TO HOLD VALUES 
// A FUNCTION OR A METHOD IS USED TO DEFINE SOME LOGIC

// so now that we have this circle object 
// we can access its members using the dot notation 
// so circle. 
// look here are the members we can call the draw method

// now note here on the right side 
// I've got Chrome open this is Chrome developer tools 
// as soon as I save my changes here you will see that chrome is gonna refresh 
// because here with live server
// we have hot reloading 
// so save and here's the result
// so as soon as we change our code the new code is loaded inside Chrome 

// so OBJECT LITERAL IS A SIMPLE WAY TO DEFINE AN OBJECT 
// but we can also define objects using factories and constructors 
// and that's the topic for the next lecture




// --------------------------------------------------
// 2.3 Objects - Factories

// all right now let's imagine we want to create another circle 
// with the current implementation we have to duplicate all this code like this 

const circle1 = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    draw: function () {
        console.log('draw');
    }
};

const circle2 = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
    draw: function () {
        console.log('draw');
    }
};

// now this can be a problem if we have one or more methods in our object 

// in this case we have this draw method here 
// and as you can see we have duplicated that in two different places 
// so if there is a bug in this method 
// we have to come back and fix it in multiple places 

// now this is a very simple object 
// imagine if the circle object had ten methods 

// SO OBJECT LITERAL SYNTAX IS NOT A GOOD WAY TO CREATE AN OBJECT 
// AND DUPLICATE IT IF THIS OBJECT HAS AT LEAST ONE METHOD 
// IF AN OBJECT HAS ONE OR MORE METHODS WE SAY THAT OBJECT HAS BEHAVIOR 
// like a person that can do different things so it has behavior now 

// let's imagine here we didn't have this draw method 
// duplicating this object wouldn't be a big deal 

// so basically we would end up with two objects 
// and then here we could use different values 

const circle1 = {
    radius: 1,
    location: {
        x: 1,
        y: 1
    },
};

const circle2 = {
    radius: 2,
    location: {
        x: 2,
        y: 2
    },
};

// so CREATING OBJECTS WITH THE OBJECT LITERAL SYNTAX 
// IS AN ISSUE ONLY IF THAT OBJECT HAS BEHAVIOR 

// so what's the solution?
// THE SOLUTION IS TO USE A FACTORY OR A CONSTRUCTOR FUNCTION 

// so let me show you how that works 

// I'm going to delete this second circle 
// and define a function called create circle 

// now I'm gonna move all this code inside this new function like this 
// now we don't need to declare a constant we can simply return this object 

function createCircle() {
    return {
        radius: 1,
        location: {
            x: 1,
            y: 1
        },
    };
}

// now this circle requires a radius so instead of hard-coding one here 
// I'm gonna add a parameter here radius and then set that here 

function createCircle() {
    return {
        radius: radius,
        location: {
            x: 1,
            y: 1
        },
    };
}

// now in es6 we have this new feature 
// so if the key and the value are the same 
// we can remove the noise in the code by removing the value 
// so we can only add radius

function createCircle() {
    return {
        radius,
        location: {
            x: 1,
            y: 1
        },
    };
}


// now to simplify the code 
// so you can focus on what I'm gonna teach you 
// I'm gonna drop this location property we don't really need it 
// instead I'm gonna add our draw method 
// so key value 
// and let's do a simple console.log draw

function createCircle() {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

// okay so THIS IS WHAT WE CALL A FACTORY FUNCTION 

// now we can simply call this function to create a new circle 
// so constant circle we call create circle and pass one as the radius

function createCircle() {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}

const circle = createCircle(1);
circle.draw();




// --------------------------------------------------
// 2.4 Objects - Constructors

// now there is ANOTHER WAY TO CREATE AN OBJECT 
// USING A CONSTRUCTOR FUNCTION 

// so let's delete circle draw and define a constructor function 

// I want you to see them side by side 
// so once again we define a function 
// but the naming convention we use for a constructor function is different 
// the first letter should be uppercase so we call it circle with an uppercase C 

// the developers with background in languages like C sharp and Java 
// this kind of looks like a class however as you can see we're defining a function 
// in JavaScript we don't have the concept of classes 

function Circle();

// so our circle function is gonna take a radius parameter 

function Circle(radius) {

}

// but in the body instead of returning an object 
// we're gonna use that "this" keyword to set the properties of this object

// what is "this"
// "this" is basically a reference to the object that is executing this piece of code

// you're gonna see that in a second 

// so imagine we have a new empty object in memory
// now we're gonna use this to reference that object 
// and then use dot notation to set various properties on that object

// so we can set the radius property to this radius argument 

function Circle(radius) {
    this.radius = radius;
}

// similarly we can define another property draw 
// but this is more accurately a method 
// so we set it to a function 
// and here we do a console.log of draw 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}

// okay now we can create a new circle like this 

// we use the "new" operator to call the circle function and pass 1 as the argument 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}

const another = new Circle(1);

// when me use the "new" operator 
// a few things happen under the hood 
// this "new" operator will create an empty object so like this {}
// an empty object 

// then it will set "this" to point to that object {}

// because by default this point to the global object 
// if you're running this code inside of a browser the global object is the window
// object if you're running it inside a node environment the global object is global 

// let me show you so I'm gonna do a console.log of "this" 
// let's see what happens so save the changes 

function Circle(radius) {
    console.log('this', this)
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}

const another = new Circle(1);
// output:
// this Circle {}

// now look this is this circle object here and here
// we have two members draw and radius this is because we use the new operator here

// if I remove that let's see what happens 
// so save the changes 

function Circle(radius) {
    console.log('this', this)
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}

const another = Circle(1);
// output:
// this <ref *1> Object [global] {
// ...
//   }

// now "this" references the window object 
// so this is the global object in a browser 

// we don't want to use this 
// we don't want to mess up with this 
// we don't want to define global variables because they're bad practice 
// because they're available everywhere in our application 
// so it is possible that one function or another 
// will modify the value of these variables accidentally
// and create bug in our application 

// so WHEN WE USE THE "new" OPERATOR TO CALL A FUNCTION THREE THINGS HAPPEN 

// FIRST THIS "new" OPERATOR WILL CREATE AN EMPTY OBJECT 
// THEN IT WILL SET "this" TO POINT TO THAT OBJECT 
// AND FINALLY IT WILL RETURN THAT OBJECT FROM THIS FUNCTIOn (Circle)

// so note that here we don't have an explicit return statement 
// (at the end of the function code block)
// you're not returning this 
// this will happen automatically when we use the "new" operator 

// so let me delete this 
// also we don't need console.log here

// so basically WE HAVE TWO WAYS TO CREATE AN OBJECT 
// WE CAN USE A FACTORY FUNCTION OR A CONSTRUCTOR FUNCTION

// FACTORY FUNCTION
function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}
const circle = createCircle(1);

// CONSTRUCTOR FUNCTION
function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}
const another = new Circle(1);

// there is nothing special about this 
// they're both regular functions in JavaScript 

// IF WE RETURN AN OBJECT IN THIS FUNCTION 
// WE REFER TO THAT FUNCTION AS A FACTORY FUNCTION 

// in contrast 

// IF WE USE THAT THIS KEYWORD ALONG WITH THE "new" OPERATOR 
// WE REFER TO THAT FUNCTION AS A CONSTRUCTOR FUNCTION 

// now you might ask what is the difference between these two patterns for creating an object 

// which approach should you use?
// well it really depends who you ask 
// developers coming from languages like C sharp and Java prefer the constructor function syntax 
// because this looks like creating an instance of a class 
// but once again in JavaScript we don't really have classes

// other developers don't like this approach 
// they prefer to use Factory functions 
// and one of their arguments is what if a developer forgets to use the new operator here 
// then we are defining these property methods on the global object 
// which is in this case the window object 

// but this discussion, this argument is really outdated with the modern JavaScript 
// and the tools that are available to us, we get an error if we forget to use the new operator here 
// so my suggestion to you is not to get hung up on these religious arguments about 
// factories versus constructors 

// as a developer you should be familiar with both these patterns 
// because as you work on different projects and different teams 
// you will see both of these patterns for creating an object 
// so you should understand how they work 
// choose the pattern that you prefer




// --------------------------------------------------
// 2.5 Objects - Constructor Property

// Every object in JavaScript has a property called constructor 
// and that references the function that was used to construct or create that object 

// so here we have two objects circle and another 

// FACTORY FUNCTION
function createCircle(radius) {
    return {
        radius,
        draw: function () {
            console.log('draw');
        }
    };
}
const circle = createCircle(1);

// CONSTRUCTOR FUNCTION
function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}
const another = new Circle(1);

// let's look at the constructor property 
// so here on the console 

another.constructor;

console.log(another.constructor);
// output:
// [Function: Circle]

// so as you see this returns our circle function 
// that we use to create this object 

// now let's look at 

circle.constructor;

console.log(circle.constructor);
// output:
// [Function: Object]

// what is this well you can tell that this is a function 
// because here we have this blue f
// and as you can see the first letter of this function is uppercase 
// so this is a built-in constructor function in JavaScript 

// when we create an object using the object literal syntax 
// internally the JavaScript engine uses this constructor function

// let me show you 
// so I'm going to temporarily delete all this code 

// let's define an object like this

let x = {};

// when we use this syntax object literal 
// JavaScript engine will translate that to something like this 

// let x = new Object();

// so this circle object we created and returned it from our factory function 

// and because we use the object literal syntax 
// internally it was created using this object constructor function 

// in JavaScript we have a few other built-in constructors 
// for example 
// we have 

new String();

// for creating strings 
// but quite often we use string literals so single quote '' or double quote "" or backtick ``
// using these literals is cleaner and simpler than using the constructor 

new Boolean();

// you also have Boolean 
// but again we don't use this we either use true or false 
// so we refer to these as boolean literals 

new Number();

// we also have Number 
// but instead we use number literals like 1 2 3 whatever

// so this is what I want you to take away 

// EVERY OBJECT HAS A CONSTRUCTOR PROPERTY
// AND THAT REFERENCES THE FUNCTION THAT WAS USED TO CREATE AN OBJECT




// --------------------------------------------------
// 2.6 Objects - Functions are Objects

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    };
}
const another = new Circle(1);

// One of the confusing concepts in JavaScript is that here functions are objects 

// so this circle function we have here is actually an object 

// don't believe me let me show you, so 

// circle.

// look these are all the members of this circle function or circle object 

// so the purple icons are methods like call bind and apply 
// and the blue icons are properties 

// so let's take a look at a few of these members in the console 

// here in the console 

circle.name

console.log(circle.name);
// output:
// Circle

// that returns the name of this function 

circle.length

console.log(circle.length);
// output:
// 1

// returns the number of arguments 

// now earlier in the last lecture I told you that every object in JavaScript 
// has a constructor property 

// and that references the function that was used to create an object 

// but here's the interesting part, 
// who do you think created this object
// let's have a look so

circle.constructor

console.log(circle.constructor);
// output:
// [Function: Function]

// so here we have another built-in constructor called Function 
// and when we declare a function using this syntax 
// internally JavaScript engine will use this function constructor 
// to create this object

// let me show you
// so I'm gonna define a constant called Circle1
// to separate from our circle 

// set it to "new" "Function"

const Circle1 = new Function();

// now here our function requires one parameter radius 
// so we add that here as a string 

const Circle1 = new Function('radius');

// now as the second argument
// I'm gonna pass the code inside of this function 
// so to break it up into multiple lines
// I'm going to use the backtick character 
// and then simply copy all this code and put it here

const Circle1 = new Function('radius', `
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
`);

// so when we declare a function internally it's represented like this

// now we can call this circle one just like calling our circle function
// so we can create a circle object by newing up circle one and pass one as the radius

const Circle1 = new Function('radius', `
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
`);

const circle = new Circle1(1);

// save the changes, now in the console let's log circle 

const Circle1 = new Function('radius', `
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
`);

const circle = new Circle1(1);

console.log(circle);
// output:
// anonymous { radius: 1, draw: [Function (anonymous)] }

// look it's a real circle object with these two members

// now let's take a look at a couple of methods that are available in our functions

// so I'm gonna delete all this code

// here we have this call method 
// and with this we can call a function

Circle.call();

// here we have this call method 
// and with this we can call a function

// look at the arguments the first argument is thisArg
// here we need to pass an empty object 

Circle.call({});

// and "this" (inside the Circle1 function {code block}) 
// will reference this object that we pass here

// okay after that we add our arguments explicitly
// so here we have one argument we pass 1 
// if you had multiple arguments we would pass them explicitly like this

Circle.call({}, 1);

// okay so this expression is exactly like expression on line 11

new Circle(1);

// when we use the "new" operator this "new" operator will internally 
// create an empty object and pass them as the first argument to the call method 
// and this object will determine the context for this 

// so "this" will reference this object ({})

// earlier I told you that if you don't use the "new" operator 
// "this" by default will point to the global object which is window

// so if I want to rewrite this expression 
// in this way 
// instead of passing an empty object 
// I would pass window 

Circle.call(window, 1);

// of course we don't want to do this 
// I'm just explaining to you what happens under the hood 

// so let's rewrite this back 
// so the first argument here specifies the target of this
// okay 

// now we have another METHOD CALLED APPLY 

Circle.apply();

// it's exactly like the call method 
// with this we can call a function 

Circle.apply({}, [1, 2, 3]);

// but INSTEAD OF PASSING ALL THE ARGUMENTS EXPLICITLY 
// WE PASS THEM IN AN ARRAY so this is useful if you already have an array 
// somewhere else in your application 
// and you want to pass an array as the second argument to the apply method

// so this is the takeaway IN JAVASCRIPT FUNCTIONS ARE OBJECTS




// --------------------------------------------------
// 2.7 Objects - Value vs Reference Types

// In JavaScript we have TWO CATEGORIES OF TYPES. 
// On one side we have VALUE TYPES, also called primitives, 
// on the other side we have REFERENCE TYPES. 

// So in the value types category we have 
// number, string, boolean, symbol (which is new in ES6) as well as undefined and null. 
// These are the primitive or value types. 

// On the other side we have objects, functions, and arrays.

//      VALUE TYPES         REFERENCE TYPES
//
//      Number              Object
//      String              Function
//      Boolean             Array
//      Symbol
//      undefined
//      null

// So in the last lecture you learned that FUNCTIONS ARE ALSO OBJECTS.
// THE SAME IS TRUE ABOUT ARRAYS, 
// so in a nutshell in JavaScript we have Primitives and Objects. 

// Now in this lecture, 
// I'm going to SHOW YOU HOW PRIMITIVES AND OBJECTS BEHAVE DIFFERENTLY, 
// because this is absolutely important for you to understand, 
// before we move onto the next section where I talk about Prototypes. 

// So on this empty canvas, I'm going to define two primitives, x and y. 
// I'm going to set y to x, so here y is 10,
// now I'm going to change the value of x to 20, 

// what I want you to note here, is that X AND Y ARE TWO INDEPENDENT VARIABLES,
// so, let's save the changes, go back in the console,
// let's log x and y,

let x = 10;
let y = x;

X = 20;

console.log(x);
console.log(y);
// output:
// 10
// 10

// x is 20, and y is 10
// they are INDEPENDENT. 

// So WHEN WE WORK WITH PRIMITIVES. 
// THIS VALUE (10) THAT WE HAVE HERE IS STORED INSIDE OF THIS VARIABLE (x). 

// WHEN WE COPY THAT VARIABLE THAT VALUE THAT IS STORED IN THE VARIABLE (x)
// IS COPIED INTO THIS NEW VARIABLE (y). 

// So THEY ARE COMPLETELY INDEPENDENT OF EACH OTHER. 

// NOW LET'S SEE WHAT HAPPENS IF WE USE A REFERENCE TYPE or an object HERE. 

// So I'm going to change this (let x = 10) 
// to an object that has a property called value ( let x = { value: 10 } ). 
// And then instead of saying x to 20, I'm going to set x.value to 20.
// So save the changes, 
// let's log x so you can see value property is 20, 
// now let's log y, you can see the value property of y is also 20. 

let x = { value: 10 };
let y = x;

x.value = 20;

console.log(x);
console.log(y);
// {value: 20}
// {value: 20}

// So this is the takeaway,

// WHEN WE USE AN OBJECT, THAT OBJECT IS NOT STORED IN THIS VARIABLE (x).

// THAT OBJECT IS STORED SOMEWHERE ELSE IN THE MEMORY (12345), 
// AND THE ADDRESS OF THAT MEMORY LOCATION (12345) IS STORED INSIDE THAT VARIABLE. 

// So then when we copy x into y, 

// let y = x;

// IT'S THE ADDRESS OR THE REFERENCE (12345) THAT IS COPIED. 
// In other words, BOTH X AND Y ARE POINTING TO THE SAME OBJECT IN MEMORY (12345). 

// And WHEN WE MODIFY THAT OBJECT USING X, OR Y, 
// THE CHANGES ARE IMMEDIATELY VISIBLE TO OTHER VARIABLE. 

// So here's the conclusion. 

// PRIMITIVES ARE COPIED BY VALUE
// REFERENCE TYPES (OR OBJECTS) ARE COPIED BY BY THEIR (memory) REFERENCE.

// Let's take a look at another example. 

// So I'm going to define a function called increase that takes a number,
// and here we simply increase this number by one.
// Let's declare a number variable and set it to 10. 
// And then call increase and pass this number. 

// Now, if I log this number on the console, what do you think you'll see? 
// Let's have a look. So save the changes, we see 10. 

// Primitive Types VALUE - Example with Function
let number = 10;

function increase(number) {
    number++;   // this variable number here 
}                // is COMPLETELY INDEPENDENT OF THE let "number" VARIABLE above.

increase(number);
console.log(number);
// 10

// But didn't we increase the number?
// WELL WHEN WE CALL INCREASE AND PASS THIS NUMBER VARIABLE 
// IT'S VALUE IS COPIED INTO THIS PARAMETER THAT IS LOCAL IN THIS FUNCTION. 

// SO THIS VARIABLE HERE IS COMPLETELY INDEPENDENT OF THIS OTHER NUMBER VARIABLE. 

// Here in this function, we increment this number by 1, so it will be 11, 
// but after this function this number is going to go out of the scope. 

// So when we log this number on the console, 
// we're essentially dealing with this first number. 

// So I told you that PRIMITIVES ARE COPIED BY THEIR VALUE. 

// SO HERE WE'RE DEALING WITH TWO INDEPENDENT COPIES. 
// That's why you see 10 on the console. 


// Now let's change this to a reference type or an object.
// So, I'm going to change 10 to an object, that has a value property. 
// Okay? Let's rename this variable to object, and similarly, 
// im going to rename the parameter in this function to object, 
// and then increment object.value. 

// Now when we log this on the console, what do you think we're going to see? 
// We're going to see 11. See? We got this object with value 11. 

// Reference Types VALUE - Example with Function
let object = { value: 10 };

function increase(object) {
    object.value++;
}

increase(object);
console.log(object);
// 11

// THE REASON FOR THIS IS BECAUSE WHEN WE CALL INCREASE AND PASS THIS OBJECT. 
// THIS OBJECT IS PASSED BY IT'S REFERENCE. 

// So this local parameter that we have here (in the function: increase(object)) 
// WILL POINT TO THE SAME OBJECT that we defined here (in the let statement: let object). 

// SO IN THIS CASE WE ARE NOT DEALING WITH TWO INDEPENDENT COPIES, 
// WE HAVE TWO VARIABLES THAT ARE POINTING TO THE SAME OBJECT. 
// SO ANY CHANGES WE MAKE TO THIS OBJECT WILL BE VISIBLE TO THE OTHER VARIABLE. 

// So remember this, in JavaScript 
// we have value types, also called primitives, 
// as well as reference types which are objects. 

// Our primitives are number, string, boolean, symbol, undefined and null. 

// PRIMITIVES OR VALUE TYPES ARE COPIED BY THEIR VALUE 
// REFERENCE TYPES OR OBJECTS, ARE COPIED BY THEIR REFERENCE.




// --------------------------------------------------
// 2.8 Objects - Adding/Removing Properties

// all right so here we have our circle constructor function 
// and using that we create a circle object 

// now THESE OBJECTS IN JAVASCRIPT ARE DYNAMIC 
// THAT MEANS AFTER YOU CREATE THEM YOU CAN ADD EXTRA PROPERTIES IN THEM 
// OR DELETE SOME PROPERTIES 

// you might be wondering why this is useful in the real world 

// imagine you're working with a user object 
// the client that can be a web or a mobile application 
// is going to send a user object to the server 
// on the server we get this user object and then we add additional stuff to it 
// for example we can add a token property 
// that we generate on the fly on the server 

// so we can always add something extra to an existing object 

// because we don't have classes we don't need to define these properties ahead of time 

// we can add them whenever we need them 
// and this makes JavaScript extremely powerful and easy to work with 

// in languages like C# or Java every time you want to implement scenarios 
// like this we have to go back and change our classes 

// so here let me add a new property to our circle object

// we can set the location here 
// like this, save the changes 
// now here on the console let's log circle

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

circle.location = { x: 1 }; // adding a property

console.log(circle);
// output:
// Circle { radius: 10, draw: [Function (anonymous)], location: { x: 1 } }

// all right you can see here we have two properties location and radius 

// we also have another notation for accessing properties 
// that is BRACKET NOTATION 
// so another way to rewrite this code is like this 
// WE USE BRACKETS AND USE A STRING TO REFERENCE A PROPERTY SO LOCATION

circle['location'] = { x: 1 };

// it's exactly the same 
// as you can see the dot notation is simpler and less verbose than bracket notation 
// but this notation is also useful in certain scenarios 
// for example when you want to dynamically access a property name 

// for example let's imagine we have this constant called 

// propertyName = 'location'; 

// you have that somewhere in our application 
// now we want to access the location property of a circle

// if you're dealing with this dynamically 
// at the time of writing the code 
// we don't know what is the name of that property 
// that is calculated at runtime 

// so we can't type something like this 

circle.location;

// but what we can do is use the bracket notation 
// so we use circle brackets property name

const propertyName = 'location';
circle[propertyName] = { x: 1 };

// another use case for using the bracket notation 
// is WHEN YOU'RE USING THE PROPERTY NAMES THAT ARE NOT VALID IDENTIFIERS 
// for example let's imagine the name of this property is center-location 

// WE CAN'T ACCESS THIS PROPERTY LIKE THIS

// circle.center-location

// THAT DOESN'T WORK 

// SO IF YOU HAVE SPECIAL CHARACTERS OR A SPACE 
// THAT'S WHEN YOU USE THE BRACKET NOTATION

// okay now WE CAN ALSO DELETE A PROPERTY FROM AN EXISTING OBJECT 

// a real word use case for this is when you get a user object from a database 
// and you want to return it to the client 
// but maybe that user object has certain properties you don't want to send to the client 
// you don't want to send the password 
// you don't want to send the credit card info 

// in that case you will dynamically delete one or more properties from an object 

// so we use the delete operator and then reference the property name 
// so delete circle dot location

delete circle.location;

// again here we can use the dot notation or bracket notation.




// --------------------------------------------------
// 2.9 Objects - Enumerating Properties

// sometimes you need to iterate over or enumerate the properties in an object 

// we can do that using the for in loop so 

// for let key in circle 
// so in every iteration key will hold the value of one key in this object
// let's log that on the console 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

for (let key in circle) {
    console.log(key);
}
// output:
// radius
// draw

// okay so look we have radius and draw 
// so it's returning both properties and methods 

// now if you want to get the value of these properties 
// you can use the bracket notation 
// so here on console.log I'm gonna log circle of key 

// you learnt in the last lecture that we can use the bracket notation 
// to access a member, okay 
// so save, now you can see radius is 10 and draw as a function 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

for (let key in circle) {
    console.log(key, circle[key]);
}

// output:
// radius 10
// draw [Function (anonymous)]

// what if we want to get only the properties and not the methods 

// well we can use the type of operator 
// to check the type of this value 
// so if typeof circle of key it is not equal to function 
// then we will display it on the console 
// save the changes, now we get only the radius 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

for (let key in circle) {
    if (typeof circle[key] !== 'function')
        console.log(key, circle[key]);
}
// output:
// radius 10


// there is another approach to get all the keys in an object 

// so this Object that we have has a method called keys 
// we can pass our circle object here 
// and this will return all the keys in the circle as an array
// so let's store them here and log them on the console 

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

const keys = Object.keys(circle);
console.log(keys);
// output:
// [ 'radius', 'draw' ]

// so here we have an array with two members radius and draw 

// with this approach we cannot separate properties from methods 

// now finally sometimes you want to know if an object has a given property 

// for that we use the in operator 

// so if here we add the name of the property as a string 
// if radius is in circle 
// we do a console.log of 'circle has a radius' 
// okay save the changes and here's our message

function Circle(radius) {
    this.radius = radius;
    this.draw = function () {
        console.log('draw');
    }
}

const circle = new Circle(10);

if ('radius' in circle)
    console.log('Circle has a radius');
// output:
// Circle has a radius

// so remember 

// TO ENUMERATE ALL THE MEMBERS IN AN OBJECT YOU CAN USE A FOR IN LOOP 
// TO GET ALL THE KEYS IN AN OBJECT USE Object.keys 
// AND TO CHECK FOR THE EXISTENCE OF A PROPERTY OR A METHOD IN AN OBJECT USE THE IN OPERATOR




// --------------------------------------------------
// 2.10 Objects - Abstraction

// all right now let's introduce some complexity in this example

// so I'm going to define another property 
// called defaultLocation 
// set it to an object like this

// also let's define another method computeOptimumLocation 
// we set this to a function and here we're going to do some magic 
// it doesn't really matter 
// what matters is that we're going to call this method inside of the draw method 
// so we call this.computeOptimumLocation 

function Circle(radius) {
    this.radius = radius;

    this.defaultLocation = { x: 0, y: 0 };

    this.computeOptimumLocation = function () {
        // ...
    }

    this.draw = function () {
        this.computeOptimumLocation();

        console.log('draw');
    };
}

const circle = new Circle(10);


// now there is a problem with this implementation 
// let me show you 

// so here when we create the circle object 

// circle.

// (you can see defaultLocation and computeOptimumLocation etc)

// these are the members of our circle object 
// not all these members should be accessible to me 
// as the consumer or the client of this object 

// for example what would happen if I set default location to false 
// that's gonna completely mess up with this object 

// or as another example maybe this compute method 
// should only be called inside of the draw method

// so if I accidentally call it here 
// circle.computeOptimumLocation(); 
// maybe this will put this object in a bad state 
// and then if I call 
// circle.draw 
// we're gonna get a weird error at runtime 

// so IN OBJECT-ORIENTED PROGRAMMING WE HAVE THIS CORE CONCEPT CALLED ABSTRACTION

// ABSTRACTION MEANS WE SHOULD HIDE THE DETAILS AND COMPLEXITY 
// AND SHOW OR EXPOSE ONLY THE ESSENTIALS

// in this particular example we should hide this property defaultLocation 
// as well as the computeOptimumLocation method 
// THESE ARE IMPLEMENTATION DETAILS 
// THESE ARE PART OF THE COMPLEXITY OF THIS OBJECT 
// WE WANT TO HIDE THESE FROM THE CONSUMERS OF THIS OBJECT

// INSTEAD WE WANT TO EXPOSE ONLY THE ESSENTIALS 

// that is the radius and the draw method 

// let me give you a metaphor think of a DVD player 
// a DVD player has a complex logic board on the inside 
// but only a few buttons on the outside that you interact with 

// so what we have on the inside is the implementation detail 
// and what we have on the outside is the public interface of a DVD player

// we want our objects to look like this DVD player
// we want to hide all the details all the unnecessary complexity on the inside 
// and expose only a few members or a few buttons on the outside

// a lot of developers who have not been able to apply object-oriented programming effectively 
// have failed to comply with this principle 

// everything in their objects is public and accessible from the outside 
// and this will bring a number of issues 

// one issue is that every time you change the implementation of that object 
// you have to go and modify many different places in your code 

// for example let's imagine now this computeOptimumLocation method requires an argument 
// let's add a factor argument here

function Circle(radius) {
    this.radius = radius;

    this.defaultLocation = { x: 0, y: 0 };

    this.computeOptimumLocation = function (factor) { // added factor argument here
        // ...
    }

    this.draw = function () {
        this.computeOptimumLocation();

        console.log('draw');
    };
}

const circle = new Circle(10);
circle.computeOptimumLocation(0.1); // now you have to pass an argument, everywhere this method is used

// with the current implementation because we can access this from the outside 
// everywhere we have used this method 
// you have to come back and pass an argument 

// so one simple change in the implementation of an object results 
// in a number of changes in your source code 

// in contrast imagine if this method was not accessible from the outside 
// then we wouldn't have to modify this line 
// it would only modify line 12

// this.computeOptimumLocation();

// where we have called this function, right 

// so REMEMBER THE ABSTRACTION PRINCIPLE OF OBJECT-ORIENTED PROGRAMMING 
// HIDE THE DETAILS AND EXPOSE ONLY THE ESSENTIALS 

// in the next lecture I'm going to show you how to implement this in JavaScript




// --------------------------------------------------
// 2.11 Objects - Private Properties and Methods

// so HOW DO WE IMPLEMENT ABSTRACTION HERE
// YOU WANT TO HIDE CERTAIN MEMBERS FROM THE OUTSIDE 

function Circle(radius) {
    this.radius = radius;

    this.defaultLocation = { x: 0, y: 0 };

    this.computeOptimumLocation = function (factor) {
        // ...
    }

    this.draw = function () {
        this.computeOptimumLocation(0.1);

        console.log('draw');
    };
}

const circle = new Circle(10);
circle.draw();

// so earlier you learned that "this" references that new circle object

// now what happens if I declare a local variable in this function 
// let's say color we set that to red 

function Circle(radius) {
    let color = 'red';
}

// is this going to be part of that object of course not 
// because we have not set that as a property on that object 

// we didn't set this.color to color, okay 

function Circle(radius) {
    let color = 'red';
    this.color = color;
}

// so this (let color = 'red') is only a local variable inside of this function 

// when we get out of this function this variable goes out of scope and dies

// now with this technique 
// we can easily hide certain members from the outside 

// so defaultLocation is implementation detail
// we don't want this to be accessible from the outside
// instead of setting in as a property on our new object 

// we define it as a local variable here, okay 


function Circle(radius) {
    this.defaultLocation = { x: 0, y: 0 }; // old - property of Object
    let defaultLocation = { x: 0, y: 0 }; // new - local variable
}

// now we don't need this color anymore 

// by the same token we can convert this method to a private method 
// so let compute be a function

function Circle(radius) {
    this.computeOptimumLocation = function (factor) { // old
        // ...
    }
    let computeOptimumLocation = function (factor) { // new
        // ...
    }
}

// now here in the draw method we are calling computeOptimumLocation 
// this function will no longer be a method on this new object 
// so we cannot access it using this
// you have to access it directly here 

function Circle(radius) {
    let computeOptimumLocation = function (factor) {
        // ...
    }

    this.draw = function () {
        // this.computeOptimumLocation(0.1); // need to remove the "this." because no longer property
        computeOptimumLocation(0.1);

        console.log('draw');
    };
}


// THIS WILL WORK BECAUSE IN JAVASCRIPT WE HAVE THIS CONCEPT OF CLOSURE

// if you don't know closure let me simplify it for you 

// so here WE HAVE ONE FUNCTION ("function Circle()") 
// AND ANOTHER FUNCTION ("draw = function()") **INSIDE** OF THAT FUNCTION

// IN THIS FUNCTION ("draw = function()") WE CAN DECLARE CERTAIN VARIABLES like X and Y 
// AND THESE ARE LOCAL VARIABLES THAT ARE ONLY AVAILABLE IN THIS FUNCTION ("draw = function()") 
// THEIR SCOPE IS LIMITED TO THIS FUNCTION ("draw = function()")
// SO WHEN WE FINISH EXECUTING THIS FUNCTION x and y WILL GO OUT OF SCOPE 

function Circle(radius) {
    this.draw = function () {
        let x, y;

        computeOptimumLocation(0.1);

        console.log('draw');
    };
}

// IN CONTRAST TO SCOPE WE HAVE **CLOSURE**

// A CLOSURE DETERMINES WHAT VARIABLES WILL BE ACCESSIBLE TO AN INNER FUNCTION

// so THIS (INNER) FUNCTION WILL BE ABLE TO ACCESS ALL THE LOCAL VARIABLES DEFINED HERE 
// AS WELL AS THE VARIABLES DEFINED IN HIS PARENT FUNCTION 

// so here we declared two variables computeOptimumLocation which is a function 
// as well as defaultLocation 

// these are THE VARIABLES THAT ARE DEFINED IN THIS PARENT FUNCTION 

// THEY ARE WITHIN THE SCOPE OF THIS FUNCTION 

// BUT WITHIN THE **CLOSURE** OF THIS INNER FUNCTION 

// now DON'T CONFUSE CLOSURE WITH A SCOPE 
// because the SCOPE IS TEMPORARY AND IT DIES 

// so EVERY TIME WE CALL THE DRAW METHOD THESE VARIABLES WILL BE RECREATED AND REINITIALIZED

// AND THEN AFTER THIS FUNCTION THEY WILL DIE

// so SCOPE IS TEMPORARY BUT CLOSURE STAYS THERE 

// so WHEN WE CALL THE DRAW FUNCTION AFTER WE FINISHED EXECUTING THIS FUNCTION 
// THESE VARIABLES:

// let defaultLocation = { x: 0, y: 0 };
// let computeOptimumLocation = function (factor) {}

// WILL CONTINUE TO STAY IN MEMORY, THEY WILL PRESERVE THEIR STATE 
// BECAUSE THEY ARE PART OF THE CLOSURE OF THIS DRAW FUNCTION 

// okay, so back here, 
// so in this method IF YOU WANT TO ACCESS THOSE PRIVATE MEMBERS 
// YOU SIMPLY USE THEM HERE (in the codeblock of the draw function)
// you can also use defaultLocation

// BUT IF YOU WANT TO ACCESS MEMBERS OF THIS NEW CIRCLE OBJECT 
// YOU NEED TO USE "this." 
// so this dot radius as an example, okay

function Circle(radius) {
    this.radius = radius;

    let defaultLocation = { x: 0, y: 0 };

    let computeOptimumLocation = function (factor) {
        // ...
    }

    this.draw = function () {
        computeOptimumLocation(0.1);

        defaultLocation; // private member of the circle object

        this.radius; // member of this circle object

        console.log('draw');
    };
}

const circle = new Circle(10);
// circle.

// NOW WITH THIS SIMPLE CHANGE, WE BASICALLY REPLACE "this" WITH "let"
// let's see what happens 

// if I access the members of the circular object

// circle.

// we only see draw and radius

// so the public interface of this object is simpler 
// it's easier to work with 
// and this will also prevent issues later down the road




// --------------------------------------------------
// 2.12 Objects - Getters and Setters

// so in the last lecture we converted these two members to private members 
// now MORE ACCURATELY THESE ARE NOT PRIVATE MEMBERS OF THE CIRCLE OBJECT 
// BECAUSE TECHNICALLY THEY ARE NOT INSIDE OF A CIRCLE OBJECT 
// THEY ARE LOCAL VARIABLES THAT WE HAVE DEFINED INSIDE OF THIS CIRCLE FUNCTION

// BUT FROM AN OBJECT-ORIENTED POINT OF VIEW 
// WE CAN REFER TO THEM AS PRIVATE MEMBERS OF THE CIRCLE OBJECT 

// now I want to simplify the code here so we can focus on a small issue 

// I'm gonna delete this compute function right 

function Circle(radius) {
    this.radius = radius;

    let defaultLocation = { x: 0, y: 0 };

    this.draw = function () {
        defaultLocation; // private member of the circle object

        this.radius; // member of this circle object

        console.log('draw');
    };
}

const circle = new Circle(10);

// so we have this private property "let defaultLocation"

// we cannot access this from the outside 

// but what if we want to display that default location 
// somewhere in our application 
// so we don't want to modify we just want to be able to read it 

// so one solution is to define a method here
// we set it to a function and in this function 
// we simply return default location

// once again we're dealing with an inner function 
// here the closure of this function includes all the variables defined here (in the function code block)
// as well as all the variables defined and its parent functions (code blocks)

// so here we have access to default location 
// and with this we can call:

function Circle(radius) {
    this.radius = radius;

    let defaultLocation = { x: 0, y: 0 };

    this.getDefaultLocation = function () { // added this method
        return defaultLocation;
    }

    this.draw = function () {
        defaultLocation;

        this.radius;

        console.log('draw');
    };
}

const circle = new Circle(10);

circle.getDefaultLocation(); // calling the method

// however I don't like this syntax I don't like the fact 
// that we're calling this as a method 
// it would be nicer if we could access this property like this:

circle.getDefaultLocation;

// but we shouldn't be able to set this from the outside 

circle.getDefaultLocation = 0;

// we can only read it 

// so let me show you how to define a property like that 

// so this Object that you have seen so far 
// has a method called define property 

Object.defineProperty

// we have another method called defined properties 
// if you want to define multiple properties in one go

Object.defineProperties

// now the first argument of this method is the object that we want to add a new property to 

// that object is the one that is referenced by "this" the new circle object 
// right,

// so we pass it here 

Object.defineProperty(this)

// the second argument is the name of our property we want to call that default location

Object.defineProperty(this, 'defaultLocation')

// and the third argument is an object in this object we add a key value pair 
// the key is get this is a special keyword for JavaScript 
// and the value is a function 

// so when we access circle.defaultlocation this function (get: function()) will be called 

// okay now here we can simply return defaultLocation 

Object.defineProperty(this, 'defaultLocation', {
    get: function () {
        return defaultLocation;
    }
});

// again this variable is part of the closure of this inner function 
// so here we can access it 

// right now in VSCode you don't see that in intellisense so we don't have default
// location as a property 

// however if you save the changes
// all right so now look at the circle object (in Chrome)

// so here's our new property defaultLocation 
// you can see (...) dot dot dot in front of it because this is a computed property 
// when we click this that get function will be executed 
// and here's the result our default location, okay 

function Circle(radius) {
    this.radius = radius;

    let defaultLocation = { x: 0, y: 0 };

    this.getDefaultLocation = function () {
        return defaultLocation;
    }

    this.draw = function () {
        console.log('draw');
    };

    Object.defineProperty(this, 'defaultLocation', {
        get: function () {
            return defaultLocation;
        }
    });

}

const circle = new Circle(10);
console.log(circle);
console.log(circle.defaultLocation);
// output:
// Circle {
//     radius: 10,
//     getDefaultLocation: [Function (anonymous)],
//     draw: [Function (anonymous)]
// }
// { x: 0, y: 0 }


// also we can see that function is stored here as a getter (in Chrome)
// get defaultLocation: f ()

// so A GETTER IS A FUNCTION THAT IS USED TO READ A PROPERTY 

// so this property we have here 
// defaultlocation
// WE REFER TO THIS AS A READ-ONLY PROPERTY

// now IF YOU WANT TO SET THE VALUE OF THIS PROPERTY FROM THE OUTSIDE 
// WE DEFINE A SETTER 

// so in this object we add another key value pair 

// the key is set which is a special keyword 
// and the value is a function 

Object.defineProperty(this, 'defaultLocation', {
    get: function () {
        return defaultLocation;
    },
    set: function () {

    }
});

// now this function takes an argument called value 
// we can set this default location to this value 

Object.defineProperty(this, 'defaultLocation', {
    get: function () {
        return defaultLocation;
    },
    set: function (value) {
        defaultLocation = value;
    }
});

// but what is interesting is that because we are using a function
// in this function we can perform some validation 
// for this value before setting the default location

// for example we can write a simple logic like this 
// if value.x is falsey or value.y is falsy 
// we can throw a new error 
// again error as a built-in constructor that we use to create error objects
// we pass a string "invalid location" 

function Circle(radius) {
    this.radius = radius;

    let defaultLocation = { x: 0, y: 0 };

    this.getDefaultLocation = function () {
        return defaultLocation;
    }

    this.draw = function () {
        console.log('draw');
    };

    Object.defineProperty(this, 'defaultLocation', {
        get: function () {
            return defaultLocation;
        },
        set: function (value) { // setter
            if (!value.x || !value.y) // validation
                throw new Error('Invalid location.');

            defaultLocation = value;
        }
    });

}

const circle = new Circle(10);

console.log(circle.defaultLocation);
circle.defaultLocation = { x: 1, y: 1 };
console.log(circle.defaultLocation);
// output:
// { x: 0, y: 0 }
// { x: 1, y: 1 }

circle.defaultLocation = 1;
// output:
// Error: Invalid location.


// so THIS IS THE BENEFIT OF A SETTER 

// now we can come here and set circle.defaultLocation 

// let's see what happens if we set this to one save the changes 
// and here's our error invalid location

// so to recap 
// USE Object.defineProperty TO DEFINE GETTERS AND/OR SETTERS




// --------------------------------------------------
// 2.13 Objects - Cheat Sheet

// The simplest way to create an object is using an object literal 
const circle = {
    radius: 1,
    draw: function () { }
};

// To create multiple objects with the same structure and behaviuor (methods), 
// use a factory or a constructor. 

// Factory function 
function createCircle(radius) {
    return {
        radius,
        draw: function () { }
    }
};

// Constructor function 
function Circle(radius) {
    this.radius = radius;
    this.draw = function () { }
}

// Every object has a "constructor" property which returns the function 
// that was used to construct or create that object. 
const x = {};
x.constructor; // returns Object() 

// In JavaScript, functions are objects. They have properties and methods. 
Circle.name;
Circle.length;
Circle.constructor; // returns Function()
Circle.call({}, 1); // to call the Circle function 
Circle.apply({}, [1]);

// Value types are copied by their value, reference types are copied by their reference. 
// Value types in JavaScript are: String, Number, Boolean, Symbol, undefined and null
// Reference types are: Object, Function and Array 

// JavaScript objects are dynamic. You can add/remove properties: 
circle.location = {};
circle['location'] = {};

delete circle.location;

// To enumerate the members in an object: 
for (let key in circle)
    console.log(key, circle[key]);

Object.keys(circle);

// To see if an object has a given property
if ('location' in circle) { }

// Abstraction means hiding the complexity/details and showing only the essentials. 
// We can hide the details by using private members. Replace "this" with "let". 

function Circle(radius) {
    // Public member 
    this.radius = radius;

    // Private member                       
    let defaultLocation = {};
}

// To define a getter/setter, use Object.defineProperty():

Object.defineProperty(this, 'defaultLocation', {
    get: function () { return defaultLocation; },
    set: function (value) { defaultLocation = value; }
});




// --------------------------------------------------
// 2.14 Objects - Exercise/Solution - Stopwatch

function Stopwatch() {

    let startTime = 0;
    let endTime = 0;
    let running = false; // flag
    let duration = 0;

    this.start = function () {
        if (running)
            throw new Error('Stopwatch already started.');

        running = true; // flag control

        startTime = new Date(); // new Date Object
    };

    this.stop = function () {
        if (!running)
            throw new Error('Stopwatch is not started');

        running = false; // flag control

        endTime = new Date(); // new Date Object

        const seconds = (endTime.getTime() - startTime.getTime()) / 1000;

        duration += seconds;
    };

    this.reset = function () {
        startTime = 0;
        endTime = 0;
        running = false;
        duration = 0;
    };

    Object.defineProperty(this, 'duration', {
        get: function () { return duration; }
    });

}

const sw = new Stopwatch();

sw.start();
console.log('starting...')
console.log(sw.startTime);

sw.stop();
console.log('stopping...')
console.log(sw.endTime);

console.log('duration:', sw.duration)

sw.start();
console.log('starting...')
console.log(sw.startTime);

sw.stop();
console.log('stopping...')
console.log(sw.endTime);


console.log(sw.duration);

sw.reset();
console.log(sw.duration);




// --------------------------------------------------
// 3.1 Prototypes - Inheritance

// inheritance is one of the core concepts of object-oriented programming 
// that enables an object to take on the properties and methods of another object
// and this makes it easy to reuse code in different parts of an application 

// here is a real example 
// in the last section we define this circle object with this method computeOptimumLocation 

//                 [ Circle ]
//          computeOptimumLocation()

// now for this discussion let's imagine here we're working with a class 

// so let's imagine circle is a class and not an object 

// I want to explain inheritance in its classical terms 

// so we have the circle class with one method computeOptimumLocation

// let's imagine tomorrow we're going to add another class to our application 
// called square and square also needs this method computeOptimumLocation 

//                 [ Circle ]                      [ Square ]
//          computeOptimumLocation()        computeOptimumLocation()

// for now let's imagine the implementation of this method is exactly the same 
// across these two different classes

// you don't want to repeat this implementation 

// because if there is a bug in this implementation we have to fix it
// in multiple places 

// or if we decide to change the implementation 
// and make it better 
// again we have to repeat this in different places 

// so THAT'S WHEN INHERITANCE COMES TO THE RESCUE 

// we can define a new class called shape put this method there 
// and have circle and square INHERIT THIS METHOD FROM THE Shape CLASS

//               ..>       [ Shape ]          <..
//              |    computeOptimumLocation()   |
//              |                               |
//          [ Circle ]                      [ Square ]

// now in inheritance we have a few terms that you should be familiar with 
// because I'm gonna use these terms throughout this course 

// in this diagram we refer to the shape class as 
// THE BASE CLASS OR SUPERCLASS OR PARENT CLASS 

// all these terms are exactly the same different tutorials and different books 
// use different terms 

// in contrast we refer to the circle as 
// THE DERIVED CLASS OR SUBCLASS OR CHILD CLASS 

// and finally we refer to the inheritance relationship as a relationship 

// so we say circle "IS-A" shape 

//                     *Base/Super/Parent*
//               ..>       [ Shape ]          <..
//      *IS-A*  |    computeOptimumLocation()   |
//              |                               |
//          [ Circle ]                      [ Square ]
//      *Derived/Sub/Child*             *Derived/Sub/Child*

// now THIS IS THE CLASSICAL DEFINITION OF INHERITANCE 

// but as you know IN JAVASCRIPT WE DON'T HAVE CLASSES WE ONLY HAVE OBJECTS 

// SO THAT'S WHEN PROTOTYPICAL INHERITANCE COMES IN

// so essentially WE HAVE TWO TYPES OF INHERITANCE CLASSICAL AND PROTOTYPICAL

// and that's one of the topics for interview questions 

// so what is prototypical inheritance 

// that's the topic for the next lecture




// --------------------------------------------------
// 3.2 Prototypes - Prototypical Inheritance

// so in the last lecture we talked about the circle and shape classes 

// but in JavaScript we don't have classes we only have objects 
// so how can we implement inheritance only using objects 

// well here we have a circle object we can define another object 
// let's call it shape and add all the common behavior 
// or all the common methods in this object 

// like computeOptimumLocation 

// and then somehow we can link a circle object to the shape object 

// now we refer to the shape object as the Prototype of the circle 

// so A PROTOTYPE IS ESSENTIALLY A PARENT OF ANOTHER OBJECT 

// a lot of courses and tutorials make prototypes sounds so confusing and complicated 
// it's not 
// WHENEVER YOU HEAR THE WORD PROTOTYPE JUST THINK PARENT 

// so EVERY OBJECT IN JAVASCRIPT 
// (except only a single object that I'm gonna show you in a second) 
// HAS A PROTOTYPE OR PARENT AND IT INHERITS ALL THE MEMBERS DEFINED IN ITS PROTOTYPE 

// let me show you this in action 
// so here in chrome developer tools 
// on the console I'm gonna define a new object 
// just an empty object 

// let x = {};
// x 
// .{}
// ..__proto__: Object

// now let's inspect this so look here we have a property called __proto__

// note that this property is faded because it's deprecated and you shouldn't directly access it 
// it's only available here to help you troubleshoot problems 

// so let's expand this 
// alright look this is the prototype or parent for this x object that we created here 

// we have these properties and methods like constructor you saw that in the last section 

// let x = {};
// x 
// .{}
// ..__proto__: Object:
// ...constructor: f Object()
// ...hasOwnProperty: f hasOwnProperty()
// etc etc
// ...toString: f toString()
// etc etc

// so every object has a constructor property which references 
// the function that was used to construct or create that object 

// we also have this method here toString 
// so let's use that method we can type x.toString and 
// this is the default implementation of toString method 

// so we have this x object in the memory 
// and x has a link to another object which is its prototype 

// for our discussion let's call this object objectBase 
// it's not an official term you're not gonna find it anywhere 
// it's just a name I'm gonna give it for our discussion 

//             Protoype
//     ..>  [ objectBase ]
//    |
//    |
// [  x  ]

// so EVERY OBJECT THAT WE CREATE IN JAVASCRIPT DIRECTLY OR INDIRECTLY INHERITS FROM OBJECTBASE

// objectBase IS THE ROOT OF ALL OBJECTS IN JAVASCRIPT AND IT DOESN'T HAVE A PROTOTYPE OR PARENT 

// let me show you so one more time let's inspect X 
// okay here is its prototype which is our object base 

// look THIS OBJECT DOESN'T HAVE A PROTO PROPERTY 
// so IT DOESN'T HAVE A PROTOTYPE OR A PARENT 

// now we can create another object 
// here let's call this Y again another empty object let's inspect it 

// let y = {};
// y 
// .{}
// ..__proto__: Object:
// ...constructor: f Object()
// etc etc

// so Y also has a prototype property which is the same object base that you saw a few seconds ago 

// so here's what we have in memory 
// we have x and y and both these objects reference objectBase 

// so we have a single instance of objectBase in memory 

//             Protoype
//     ..>  [ objectBase ]  <..
//    |                        |
//    |                        |
// [  x  ]                  [  y  ]


// I can prove that to you 
// so back in the console 
// to get the prototype of an object we call

Object.getPrototypeOf(x);
// {}
// .constructor: f Object()
// .hasOwnProperty: f hasOwnProperty()
// etc etc

// so this is our object base with these members 

// okay now we can write an expression like this 
// we can check if it's equal to object that get prototype of Y 
// look BOTH x AND y HAVE THE EXACT SAME PROTOTYPE 

let x = {};
let y = {};

console.log(Object.getPrototypeOf(x) === Object.getPrototypeOf(y));
// output:
// true

// now you might be wondering why I didn't write this expression like this 

x.__proto__ === y.__proto__

// the reason for this is because this property is deprecated 
// so you shouldn't use it in the code 
// but you can use it here on the console when debugging your applications 

// so now that you understand what a prototype is 

// let's define prototypical inheritance 

// so earlier I accessed the toString method on the x object 

x.toString(x);

// we didn't define this method in our X object because X was an empty object right 

// so how does this work?
// how can we access this method 

// well WHEN WE ACCESS A PROPERTY OR A METHOD ON AN OBJECT 
// JAVASCRIPT ENGINE FIRST LOOKS FOR THAT PROPERTY OR METHOD ON THE OBJECT ITSELF 

// IF IT CAN'T FIND IT THEN IT LOOKS AT THE PROTOTYPE FOR THAT OBJECT 
// again if IT CANT FIND THAT MEMBER IT WILL LOOK AT THE PROTOTYPE OF THAT OBJECT 
// ALL THE WAY UP TO THE ROOT OBJECT WHICH WE CALLED objectBase 

// so THIS IS PROTOTYPICAL INHERITANCE IN ACTION 

// WHEN ACCESSING A PROPERTY OR A METHOD ON AN OBJECT JAVASCRIPT ENGINE 
// WALKS UP THE PROTOTYPE CHAIN TO FIND A TARGET MEMBER 

// so once again I want to emphasize that

// A PROTOTYPE IS JUST A REGULAR OBJECT IN MEMORY THERE IS NOTHING SPECIAL ABOUT IT

// EVERY OBJECT HAS A PROTOTYPE OR A PARENT EXCEPT THE ROOT OBJECT




// --------------------------------------------------
// 3.2 Prototypes - Multi-level Inheritance

// let's take a look at another example 
// I'm gonna define an empty array
// let's call this myArray 

let myArray = [];

// now let's inspect this alright so here 
// we have a prototype property 
// let's look at the prototype or the parent for this array 

// myArray
// .[]
// ..length:0
// ..__proto__: Array(0)
// ...etc
// ...indexOf: f indexOf()
// ...push: f push()
// ...etc

// okay look and this object we have these methods 
// chances are you have used some of these methods before 

// for example we can call indexOf to locate an object in an array
// we can call push to add a new object to the array and so on 

// so all these methods are defined in this object which 
// is the prototype or the parent for all arrays in JavaScript 

// so this is what we have in memory 
// we have myArray which derives from let's call this object arrayBase

// now let us inspect the prototype of the arrayBase object 
// so back here if you scroll down look here we have another proto property 
// let's expand this what do you see here that looks familiar right 
// this is our objectBase or the root object in JavaScript 

// myArray
// .[]
// ..length:0
// ..__proto__: Array(0)
// ...etc
// ...indexOf: f indexOf()
// ...push: f push()
// ...etc
// ...__proto__:
// ....constructor: f Object()
// ....etc

// so here's a visualization of what we have in memory

// myArray derives from arrayBase an arrayBase derives from objectBase
// this is what we call MULTI-LEVEL INHERITANCE

//                      ---> [ objectBase]
//                     |
//        ---> [ arrayBase]
//       |
//  [ myArray ]

// what about the objects that we create using our custom constructors 

// so here we have this constructor circle 
// and we have created the circle object using this constructor

function Circle(radius) {
    this.radius = radius;

    this.draw = function () {
        console.log('draw');
    };
}

const circle = new Circle(10);

// so let's inspect this on the console 
// so circle 
// here's our circle object it has a prototype 
// look this prototype is the prototype for all circle objects 
// that we create using our circle constructor 

// Circle {radius: 10, draw: f}        <--- Circle
// .draw: f ()
// .radius: 10
// .__proto__: Object                  <---- CircleBase
// ..constructor: f Circle(radius)  
// ..__proto__: Object

// let's call this circleBase 

// so every time we call the circle constructor to create a new circle object 

const circle = new Circle(10);

// this constructor will create a new object and set its prototype property to circle base 

// in other words 

// OBJECTS CREATED BY A GIVEN CONSTRUCTOR WILL HAVE THE SAME PROTOTYPE

// so ALL CIRCLE OBJECTS CREATED BY THE CIRCLE CONSTRUCTOR WILL HAVE THE SAME PROTOTYPE 
// and similarly ALL ARRAYS CREATED BY THE ARRAY CONSTRUCTOR WILL HAVE THE SAME PROTOTYPE 

// now back here so this is our circle base 
// circle base also has a prototype 
// let's see what we have here 

// what is this object that's objectBase right, the root object in JavaScript

// Circle {radius: 10, draw: f}        <--- Circle
// .draw: f ()
// .radius: 10
// .__proto__: Object                  <---- circleBase
// ..constructor: f Circle(radius)  
// ..__proto__: Object                 <---- objectBase
// ...__constructor__: f Object()
// ...etc

// so this is what we have in memory we have 
// the circleObject that inherits from circleBase and circleBase inherits from objectBase

//                      ---> [ objectBase]
//                     |
//        ---> [ circleBase ]
//       |
//  [ Circle ]




// --------------------------------------------------
// 3.4 Prototypes - Property Attributes

// all right now let me show you something interesting 

// so I'm going to define a new object like person 
// and set its name to mosh 
// let's log it on the console person 
// so here's our person object 

let person = { name: 'Mosh' };
console.log(person);

// and in this prototype we have all these methods available 

// {name: "Mosh"}
// .name: "Mosh"
// .__proto__: Object
// ..constructor: f Object()
// ..etc
// ..toString: f toString()

// so we can type person.toString and it works

person.toString();

console.log(person.toString());
// output:
// [object Object]

// however if we iterate over the members of this object 
// we're not going to see this method toString 

// so a for loop let key in person 
// let's just log the key on the console 
// save 
// so the only key we have here is name 

for (let key in person)
    console.log(key)
// output:
// name

// NONE OF THE PROPERTIES AND METHODS DEFINED IN objectBase ARE VISIBLE HERE 

// by the same token if we call Object.keys of person and then log it on the console 
// again we only see the name property

console.log(Object.keys(person));
// output:
// ["name"]

// so how come we can't iterate over all these properties and methods defined in objectBase 

// well the reason is because IN JAVASCRIPT 
// OUR PROPERTIES HAVE ATTRIBUTES ATTACHED TO THEM 

// SOMETIMES THESE ATTRIBUTES PREVENT A PROPERTY FROM BEING ENUMERATED 

// let me show you what I mean 
// so first let's get the prototype for person we call 
// so this is our objectBase right 

let objectBase = Object.getPrototypeOf(person);

// now I want to show you the attributes attached to the toString property 
// or more accurately toString method 

// so we call 

Object.getOwnPropertyDescriptor()

// as the first argument we pass objectBase 
// as the second argument we pass the name of the target property or method 
// that is toString 
// and this will return an object which we call a property descriptor 

Object.getOwnPropertyDescriptor(objectBase, 'toString')

// let me show you 
// so let's store that in descriptor 
// so now let's log this descriptor on the console

let person = { name: 'Mosh' };
let objectBase = Object.getPrototypeOf(person);
let descriptor = Object.getOwnPropertyDescriptor(objectBase, 'toString');
console.log(descriptor);

// output:
// {
//     value: [Function: toString],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }


// okay so here's our descriptor object look at the properties 
// CONFIGURABLE IS TRUE THAT MEANS WE CAN DELETE THIS MEMBER IF YOU WANT TO 

// ENUMERABLE IS FALSE AND THAT'S WHY WHEN WE ITERATED OVER OUR PERSONAL OBJECT 
// WE COULDN'T SEE THE TOSTRING METHOD 

// you also have WRITABLE SET TO TRUE WHICH MEANS WE CAN OVERWRITE THIS METHOD WE
// CAN CHANGE ITS IMPLEMENTATION WE CAN SET ITS VALUE 

// and here's THE VALUE PROPERTY WHICH IS SET TO A METHOD 
// AND THIS IS WHERE WE HAVE THE DEFAULT IMPLEMENTATION OF THE toString METHOD 

// now WHEN YOU CREATE YOUR OWN OBJECTS YOU CAN SET THESE ATTRIBUTES FOR YOUR PROPERTIES 

// let me show you an example 
// so we're gonna use our personal object 
// we don't need these lines anymore 
// earlier in the last section you learned about 

Object.defineProperty();

// we use this to define a getter and a setter for a property 

// so as the first argument we pass person 
// the second argument is the name of the target property which is name 
// and THE THIRD ARGUMENT IS AN OBJECT WHICH IS OUR PROPERTY DESCRIPTOR OBJECT 
// THIS IS WHERE WE ADD THE ATTRIBUTES TO THIS PROPERTY 

Object.defineProperty(person, 'name', {

});

// so in the last section we used get and set to define a getter and a setter 

Object.defineProperty(person, 'name', {
    // get: function () { return name; },
    // set: function (value) { name = value; }
});

// now we're going to use a different set of properties 
// so I can set this to writable false and this will become read-only 

// so if I set person.name to let's say John 
// and then log it on the console 

let person = { name: 'Mosh' };

Object.defineProperty(person, 'name', {
    writable: false
});

person.name = 'John';

console.log(person);
// output:
// { name: 'Mosh' }


// ok look the name is not changed 
// so that's the writable attribute 

// we have another attribute enumerable we can set this to false 
// and then this will not show up in Object.keys 
// so if you log Object.keys of person

// look now we get an empty array in contrast if it was true it will show up here

let person = { name: 'Mosh' };

Object.defineProperty(person, 'name', {
    enumerable: false
});

console.log(Object.keys(person));
// output:
// []

// so BY DEFAULT ALL THESE ATTRIBUTES ARE TRUE
// ALL PROPERTIES ARE WRITABLE, ENUMERABLE AND CONFIGURABLE 

// so let's see what happens if we set configurable to false 
// now we cannot delete this property so if I try to 
// delete person.name nothing will happen 
// so let's log the person on the console  
// look the name property is still there

let person = { name: 'Mosh' };

Object.defineProperty(person, 'name', {
    configurable: false
});

delete person.name;

console.log(person);
// output:
// { name: 'Mosh' }




// --------------------------------------------------
// 3.5 Prototypes - Constructor Prototypes

// so you have learned that every object in JavaScript 
// except the rootObject has a prototype or a parent 

// now THE PROPER WAY TO GET THE PROTOTYPE OF AN OBJECT 
// IS USING object.getPrototypeOf() and here we pass an object

object.getPrototypeOf(myObj);

// and what we get here is exactly what we saw 
// in chrome console under:

// myObj.__proto___ (parent of myObj)

// it's the same thing right,
// so what we have here is THE PROTOTYPE OR THE PARENT OF myObj 

// now one thing you need to know is that CONSTRUCTORS ALSO HAVE A PROTOTYPE PROPERTY 

// so here we have the Circle constructor function 
// and you know that in JavaScript functions are objects 
// so they have properties and methods 
// so here we can type:

// Circle.

// look these are all the properties and methods that
// are available in every function 
// so here's the prototype property 
// what is this 

Circle.prototype

// THIS IS THE OBJECT THAT WILL BE USED AS THE PARENT 
// FOR OBJECTS CREATED BY THE CIRCLE CONSTRUCTOR 

// so back here if I want to put this together 
// assuming that we have this myObj and this myObj is created by this constructor

// this constructor has a prototype property 
// and what we get here is exactly 
// what we have here 

// myObj.__proto___
// Constructor.prototype()

// so the object that will be used as the parent for objects created by this constructor 

// let me show you this in action 
// so I'm going to define an object an empty object

let obj = {};

// this object has a prototype property which is its parent 
// and you know that this is what we call objectBase 
// so we have these members like constructor hasOwnProperty and so on

// obj.__proto__
// .constructor: f Object()
// .hawOwnProperty: f hasOwnProperty()

// now you know that this object is created using the
// Object constructor function

// so when we use the object literal syntax ( = {} )
// under the hood that's translated to a "new Object" 
// so that's our constructor

// now THIS CONSTRUCTOR HAS A PROTOTYPE PROPERTY 
// and THIS IS THE OBJECT THAT WILL BE USED 
// AS THE PROTOTYPE FOR ALL OBJECTS CREATED BY THIS CONSTRUCTOR

// Object.prototype
// .constructor: f Object()
// .hawOwnProperty: f hasOwnProperty()

// so look THIS IS OUR objectBase

// so what I'm telling you is that BOTH THESE ARE EQUAL
// obj.__proto__ (and) Object.prototype

// THE PARENT FOR THIS OBJECT (obj.__proto__)
// AND THE PROTOTYPE FOR THIS CONSTRUCTOR (Object.prototype)

// let's take a look at another example 

// so I'm gonna define an array empty array

let array = [];

// thisarray has a prototype proto 

// array.__proto__
// .concat: f concat()
// .constructor: f Array()
// .etc

// and THIS IS THE OBJECT THAT INCLUDES ALL THE METHODS THAT CAN BE CALLED ON ARRAYS 
// SO WE CALL THIS arrayBase 

// now when we use an array literal ( = [] )
// under the hood the array constructor will be called 
// now THIS CONSTRUCTOR HAS A PROTOTYPE PROPERTY 
// WHICH REFERENCES arrayBase, THE SAME OBJECT

// Array.prototype
// .concat: f concat()
// .constructor: f Array()
// .etc

// okay now finally as one more example 
// here we have a circle object

circle

// circle has a prototype 
// we call this circleBase which doesn't have anything specific here 
// it only has this constructor property 

// circle
// .Circle {radius: 1}
// ..radius: 1
// ..__proto__:
// ...constructor: f Circle(radius)
// ...__proto__: Object

// now we created the circle object using 
// "Circle" constructor

// this constructor has a prototype property __proto__
// which returns circleBase 

// Circle.prototype
// .{constructor: f}
// ..constructor: f Circle(radius)
// ..__proto__: Object

// so these two objects are exactly the same




// --------------------------------------------------
// 3.6 Prototypes - Prototype vs Instance Members

// now we have this Circle constructor with two members 

// the radius property and the draw method just like before 

// and we have two circle objects 
// so let's Log these objects on the console

function Circle(radius) {
    this.radius = radius;

    this.draw = function () {
        console.log('draw');
    }
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1);
console.log(c2);
// output:
// Circle { radius: 1, draw: [Function (anonymous)] }
// Circle { radius: 2, draw: [Function (anonymous)] }

// c1 here's our object, we have this draw method 
// let's log c2 and you can see we have this draw method here as well 

// so with the current implementation 
// if we have let's say a thousand circle objects in the memory 
// we're going to have a thousand copies of the draw method 

// now this is a very simplified example 
// in a real world application your objects might have several methods 
// so if you want to have a large number of these objects in the memory 
// you're going to WASTE A LOT OF MEMORY BY KEEPING COPIES OF ALL THESE METHODS

// so what's the solution well you know how PROTOTYPICAL INHERITANCE works 
// WHEN WE ACCESS A PROPERTY OR A METHOD ON AN OBJECT 
// JAVASCRIPT ENGINE FIRST LOOKS AT THE OBJECT ITSELF 
// IF IT CAN'T FIND THAT PROPERTY OR METHOD IT WILL LOOK AT THE PROTOTYPE OF THAT OBJECT 

// so now WE CAN TAKE THIS DRAW METHOD OUT OF THE CIRCLE OBJECT 
// AND PUT IT IN ITS PROTOTYPE 

// we're going TO HAVE A SINGLE INSTANCE OF THIS PROTOTYPE IN THE MEMORY 
// WHICH WE CALL circleBase SO WE'RE GOING TO HAVE A SINGLE INSTANCE OF THE DRAW METHOD 

// so how do we do that 

// well in the last lecture you learned 
// that every constructor has a prototype property so

// Circle.Prototype 

// and this is exactly the same as the prototype of our circle objects 

// so for c1 let's say if you access the __proto__ property 
// which we shouldn't because it's deprecated
// but essentially these two properties are referencing the same object in memory
// that's the circleBase 

// Circle.prototype === c1.__proto__

// so using Circle.Prototype 
// we can quickly and safely access this object 

// so you know that JavaScript objects are dynamic 
// so we can always add something to them later 
// so we can add the draw method here (Circle.prototype.draw)
// and simply move the implementation right here (inside the Circle.prototype.draw Code Block)

// and with that we no longer need the draw method on the object instance itself
// (delete the draw method from inside the Circle constructor function)

// save 
// so now let's log our circles one more time 

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.draw = function () {
    console.log('draw');
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1);
console.log(c2);
// output:
// Circle { radius: 1 }
// Circle { radius: 2 }

// c1 this object only has a radius property 
// the draw method is on the prototype the circleBase object right 

// and the same is true for c2 again we don't have the draw method 
// it's on the prototype 

// c1
// .Circle {radius: 1}
// ..radius: 1
// ..__proto__:
// ...draw: f ()
// ...constructor: f Circle(radius)
// ...__proto__: Object

// c2
// .Circle {radius: 2}
// ..radius: 2
// ..__proto__:
// ...draw: f ()
// ...constructor: f Circle(radius)
// ...__proto__: Object

// now because of the prototypical inheritance we can still access it so 
// we can call c1 but draw and everything works

c1.draw();

// so ESSENTIALLY WE HAVE TWO KINDS OF PROPERTIES AND METHODS IN JAVASCRIPT 

// we have INSTANCE PROPERTIES AND METHODS 
// let's CALL THEM INSTANCE MEMBERS 
// AND PROTOTYPE MEMBERS 

// now let's take this to the next level 
// so you know that every object has this toString method
// by default it returns this string here 

c1.toString();
// output:
// "[object Object]"

// we can overwrite the implementation of this method 
// and the prototype of our circle objects 

// so here I'm gonna add Circle.Prototype.toString 
// set it to a new function 
// and here we're gonna return circle with radius 

// now we need to access the radius property 
// so we can use this.radius 
// save the changes 
// now c1 the toString 
// and this is the new implementation

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.draw = function () {
    console.log('draw');
}

Circle.prototype.toString = function () { // modifying the toString method
    return 'Circle with radius ' + this.radius;
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.toString());
// output:
// Circle with radius 1

// so back to our PROTOTYPICAL INHERITANCE 
// WHEN WE CALL THIS METHOD JAVASCRIPT ENGINE LOOKS AT OUR CIRCLE OBJECT 
// OBVIOUSLY WE DON'T HAVE THIS METHOD THERE 
// THEN IT LOOKS AT ITS PROTOTYPE SO Circle.prototype 
// WE HAVE IMPLEMENTED THIS METHOD HERE (as Circle.prototype.toString = function())
// SO THIS IMPLEMENTATION WILL BE USED 

// so here's the interesting part 
// EVEN THOUGH WE HAVE ANOTHER IMPLEMENTATION OF THE toString METHOD ON objectBase
// but THIS IMPLEMENTATION WILL BE USED BECAUSE THIS IS MORE ACCESSIBLE 

// so THIS IS ALL ABOUT INSTANCE VERSUS PROTOTYPE MEMBERS 

// and by the way remember that 
// IN BOTH THESE KIND OF MEMBERS YOU CAN REFERENCE OTHER MEMBERS 

// for example 
// IN THE DRAW METHOD WHICH IS A PROTOTYPE METHOD 
// I CAN EASILY CALL AN INSTANCE METHOD ON THE CIRCLE CLASS 

// so let's add a method here call it this.move 
// we set it to a function, console.log of move
// now WE CAN REFERENCE THIS FUNCTION (or this METHOD more accurately) 
// IN OUR PROTOTYPE METHOD
// so this.move and then console.log of draw 
// so let's test this 
// and here are our two messages move and draw

function Circle(radius) { // 
    this.radius = radius; // Instance (Member) Method

    this.move = function () { // definining a new Instance (Member) Method
        console.log('move');
    }
}

Circle.prototype.draw = function () { // Protoype (Member) Method
    this.move(); // referencing this Instance (Member) Method in our Prototype (Member) Method
    console.log('draw');
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.draw());
// output:
// move
// draw

// by the same token 
// IN AN INSTANCE METHOD WE CAN REFERENCE A PROTOTYPE MEMBER 
// so let's reverse this 

// here before moving the circle we want to draw it 
// so we call this.draw 

// now ESSENTIALLY WHAT IS HAPPENING HERE WE ARE CALLING THE DRAW METHOD
// OBVIOUSLY IT'S NOT AN INSTANCE METHOD SO THE JAVASCRIPT ENGINE WILL FIND THIS
// METHOD ON THE PROTOTYPE, SO EVERYTHING WILL CONTINUE TO WORK 

// to demonstrate this let's go back to the draw method 

// we shouldn't call move because otherwise 
// we'll have a circular dependency so delete this 

// save the changes 
// now c1.move so we have draw and move

function Circle(radius) {
    this.radius = radius;

    this.move = function () { // Instance (Member) Method
        this.draw(); // JavaScript engine will find the draw method on the prototype
        console.log('move');
    }
}

Circle.prototype.draw = function () { // Protoype (Member) Method
    console.log('draw');
}

const c1 = new Circle(1);
const c2 = new Circle(2);

console.log(c1.move());
// output:
// draw
// move




// --------------------------------------------------
// 3.7 Prototypes - Iterating Properties

// so I've simplified the example from the last lecture 

// we have the circle object with two instance members 
// radius and move 

// and one prototype member which is called draw 

function Circle(radius) {
    // Instance Members
    this.radius = radius;

    this.move = function () {
        console.log('move');
    }
}

// Prototype Members
Circle.prototype.draw = function () {
    console.log('draw');
}

const c1 = new Circle(1);

// now one thing I want to emphasize here is that

// IT DOESN'T MATTER WHEN YOU CHANGE THE PROTOTYPE 
// so IN THIS CASE WE'RE MODIFYING THE PROTOTYPE BEFORE CREATING AN OBJECT 
// YOU COULD CREATE AN OBJECT FIRST AND THEN MODIFY THE PROTOTYPE 
// THE DRAW METHOD WILL STILL BE AVAILABLE ON THIS CIRCLE OBJECT

// BECAUSE HERE WE'RE DEALING WITH OBJECT REFERENCES 

// so WE HAVE A SINGLE OBJECT IN MEMORY 
// AS SOON AS WE MODIFY THAT ALL THE CHANGES ARE IMMEDIATELY VISIBLE 
// so save the changes, look we've got the draw message here

function Circle(radius) {
    // Instance Members
    this.radius = radius;

    this.move = function () {
        console.log('move');
    }
}

const c1 = new Circle(1); // create object first then modifying prototype after

// Prototype Members
Circle.prototype.draw = function () {
    console.log('draw');
}

c1.draw(); // draw method STILL AVAILABLE
// output:
// draw

// now in this lecture I'm gonna show you 
// HOW TO ITERATE OVER INSTANCE VERSUS PROTOTYPE PROPERTIES 

// so earlier you learn about Object.keys() method 

// I'm gonna pass this c1 here 
// let's see what we get on the console 
// so Object.keys ONLY RETURNS INSTANCE MEMBERS 
// RADIUS AND MOVE 
// DRAW IS NOT THERE BECAUSE DRAW IS A PROTOTYPE MEMBER 

console.log(Object.keys(c1));
// output:
// [ 'radius', 'move' ]

// so that's something I want you to remember 
// so Object.keys ONLY RETURNS INSTANCE MEMBERS 

// okay what about THE FOR IN LOOP 
// let me show you so for let key in c1 
// let's just do a console.log of the key 

for (let key in c1)
    console.log(key)
// output:
// radius
// move
// draw

// alright look here 
// WE HAVE ALL THE INSTANCE AND PROTOTYPE MEMBERS 
// SO WE GET THE DRAW METHOD AS WELL 

// so remember THE FOR IN LOOP RETURNS ALL MEMBERS INSTANCE AND PROTOTYPE 

// now in JavaScript language 
// we often use the word "own" instead of instance 
// so in some documents in some tutorials you may hear "own property" 
// versus "prototype property"

// let me show you a useful method 
// so here let's c1.hasOwnProperty 
// we passed the name of the property 
// let's say radius 
// THIS IS AN INSTANCE OR OWN PROPERTY 
// so we get true 

c1.hasOwnProperty('radius'); // radius is a INSTANCE MEMBER/PROPERTY or OWN PROPERTY

console.log(c1.hasOwnProperty('radius'));
// output:
// true

// but if we call has own property and pass draw 
// we should get false 
// because THIS IS A PROTOTYPE MEMBER OR A PROTOTYPE PROPERTY

c1.hasOwnProperty('draw'); // draw is a PROTOTYPE MEMBER/PROPERTY

console.log(c1.hasOwnProperty('draw'));
// output:
// false




// --------------------------------------------------
// 3.8 Prototypes - Avoid Extending the Built-in Objects

// so you have learned how easy it is to modify the prototype of an object 

// so you might be tempted to do something like this, so 

// we're gonna add a new method to our arrays for shuffling an array 
// now let's not worry about the algorithm for shuffling an array

Array.prototype.shuffle = function () {
    // ...
}

// now with this we can define an array like this 
// and we will be able to call the shuffle method 

const array = [];
array.shuffle();

// now while this is very easy to accomplish in JavaScript
// THAT'S SOMETHING YOU SHOULD AVOID 
// YOU SHOULD NOT MODIFY THE BUILT-IN OBJECTS IN JavaScript 

// because it is possible that tomorrow you're going to use a library 
// and in that library someone has also extended the array prototype 
// and added a shuffle method but with a different implementation 

// then you might end up spending the whole day debugging the problem 

// also nothing stops the developers of JavaScript 
// from adding this method to arrays in the future versions of JavaScript 

// so HERE IS THE LESSON DON'T MODIFY OBJECTS YOU DON'T OWN

// yes javascript is a dynamic language it makes it really easy 
// to add properties and methods to an existing object 

// BUT THAT DOESN'T MEAN THAT YOU SHOULD MODIFY THE BUILT-IN OBJECTS 

// so 
// DON'T OVERRIDE METHODS 
// DON'T ADD NEW METHODS OR PROPERTIES 
// and 
// DON'T REMOVE EXISTING PROPERTIES AND METHODS 

// because somewhere else in a library you might be using 
// there might be code that is dependent and those methods in the built-in objects 

// so IF YOU MODIFY THE BUILT-IN OBJECTS YOU WILL CREATE ALL SORTS OF ISSUES





// --------------------------------------------------
// 3.9 Prototypes - Prototypes Cheat Sheet

// Every object (except the root object) has a prototype (parent). 
// To get the prototype of an object:
Object.getPrototypeOf(obj);

// In Chrome, you can inspect "__proto__" property. ]
// But you should not use that in the code. 

// To get the attributes of a property:
Object.getOwnPropertyDescriptor(obj, 'propertyName');

// To set the attributes for a property:
Object.defineProperty(obj, 'propertyName', {
    configurable: false,    // cannot be deleted
    writable: false,
    enumerable: false
});

// Constructors have a "prototype" property. 
// It returns the object 
// that will be used as the prototype 
// for objects created by the constructor. 
Object.prototype === Object.getPrototypeOf({})
Array.prototype === Object.getPrototypeOf([])

// All objects created with the same constructor will have the same prototype. 
// A single instance of this prototype will be stored in the memory. 
const x = {};
const y = {};
Object.getPrototypeOf(x) === Object.getPrototypeOf(y); // returns true 

// Any changes to the prototype will be immediately visible 
// to all objects referencing this prototype. 

// When dealing with large number of objects, 
// it's better to put their methods on their prototype. 
// This way, a single instance of the methods will be in the memory. 
Circle.prototype.draw = function () { }

// To get the own/instance properties:
Object.keys(obj);

// To get all the properties (own + prototype): 
for (let key in obj) { }




// --------------------------------------------------
// 3.10 Prototypes - Exercise

// now it's time for an exercise
// so here's the stopwatch object 
// that we created in the last section 

// now in this exercise 
// I want you to move the methods we have here like start stop and reset 
// to the prototype of the stopwatch 

// now before we get started I want to clarify something 
// you should put methods on the prototype as an optimization technique 

// so if you're working with a large number of objects of the same type 
// you don't want to have multiple copies of these methods in memory 
// in the case of a stopwatch we don't really have that requirement 

// if you're gonna use stopwatch in a program we need only one instance 
// so in this case we don't really need to put these methods on the prototype 

// and as you will see putting these methods on the prototype will lead to another issue 

// and that's part of the exercise you're going to work on 

// so go ahead put these methods on the prototype 

// and then notice that you will not be able to access these variables 
// like running and start time 
// because these variables are defined in this function (function Stopwatch())
// they are within the scope of this function (function Stopwatch())

// when you put the start method on the prototype 
// you can only access the public members of the stopwatch 

// so in order to access running you need to define 
// this as a public read-only property on the Stopwatch 

// and then access it using "this."

// this.running = true

// so that was a quick hint for you go ahead do this exercise 
// and you will see my solution next

// Original that needs to be edited
function Stopwatch() {
    let startTime, endTime, running, duration = 0;

    this.start = function () {
        if (running)
            throw new Error('Stopwatch has already started.');

        running = true;

        startTime = new Date();
    };

    this.stop = function () {
        if (!running)
            throw new Error('Stopwatch is not started.');

        running = false;

        endTime = new Date();

        const seconds = (endTime.getTime() - startTime.getTime()) / 1000;
        duration += seconds;
    };

    this.reset = function () {
        startTime = null;
        endTime = null;
        running = false;
        duration = 0;
    };

    Object.defineProperty(this, 'duration', {
        get: function () { return duration; }
    });
}




// --------------------------------------------------
// 3.11 Prototypes - Solution

// all right so here's my solution

// I'm gonna SELECT THESE THREE METHODS START STOP AND RESET 
// AND MOVE THEM OUTSIDE OF THE STOPWATCH FUNCTION 

// now I'm gonna replace 
this.start
this.stop
this.reset

// with 
Stopwatch.prototype.start
Stopwatch.prototype.stop
Stopwatch.prototype.reset

// okay so these methods are now under prototype for the Stopwatch 

// as you can see running 
// iS NOT DEFINED ANYWHERE IN (Stopwatch.prototype.start = function())
// IT'S DEFINED (in funciton Stopwatch())
// AND WE DON'T HAVE ACCESS TO THAT 

// THAT'S WHY WE NEED TO DEFINE THIS AS A READ-ONLY PROPERTY 
// just like how we have expose the duration variable as a read-only property 

// HERE WE NEED TO EXPOSE THESE OTHER VARIABLES AS READ-ONLY PROPERTIES 

// now the problem with this is that it's going to pollute the interface of the stopwatch 
// in our previous implementation our stopwatch had only four public members 
// three methods start stop and reset and one public property that's the duration 

// now we're going to add three extra properties 
// and this is going to pollute the interface of stopwatch 
// and this is against the idea of abstraction in object-oriented programming 

// because as we explained earlier we want to keep the interface of our objects clean 
// and simple just like a DVD player 
// we don't want to expose all the details to the outside 

// so now let's define three public properties 
// actually to save time I'm gonna duplicate this a couple of times 

// now we want to expose startTime and here you want to return startTime 
Object.defineProperty(this, 'startTime', {
    get: function () { return startTime; }
});

// next we want to expose endTime
Object.defineProperty(this, 'endTime', {
    get: function () { return endTime; }
});

// this time I'm going to expose running 
Object.defineProperty(this, 'running', {
    get: function () { return running; }
});

// okay now back to our prototype methods 

// so here (in Stopwatch.prototype.start) I'm going to replace 
running
// with 
this.running
// and 
startTime
//with 
this.startTime

// I'm going to make the same changes to the other methods 
// so here in the stop method, replace
running
// with
this.running
// and
endTime
// with 
this.endTime

// all right so here's what we have now 

// now THERE'S A TRICKY SITUATION HERE IN THIS STOP METHOD 
// and the last line we're adding the seconds to the duration 

Stopwatch.prototype.stop = function () {
    if (!this.running)
        throw new Error('Stopwatch is not started');

    this.running = false;

    this.endTime = new Date();

    const seconds = (this.endTime.getTime() - this.startTime.getTime()) / 1000;

    duration += seconds; // DURATION IS A PUBLIC READ-ONLY PROPERTY 
}

// DURATION IS A PUBLIC READ-ONLY PROPERTY 
// SO I CANNOT MODIFY IT LIKE THIS 

this.duration += seconds;

// BECAUSE CURRENTLY IT DOESN'T HAVE A SETTER 

// now IF WE GO BACK TO OUR Stopwatch Constructor (function Stopwatch)
// here WE CAN DEFINE A SETTER FOR THIS TO SOLVE THIS PROBLEM 

// BUT THIS IS GOING TO LEAD TO ANOTHER PROBLEM 
// SO LET ME ADD THIS FIRST AND THEN WE WILL TALK ABOUT THAT 

// so setter a function that takes a value 
// and here we simply set duration to this value 
function Stopwatch() {
    let duration = 0;

    Object.defineProperty(this, 'duration', {
        get: function () { return duration; },
        set: function (value) { duration = value; } // giving duration a SETTER
    });
}

// now back to the stop method 
// so we can access the duration property and update its value 

Stopwatch.prototype.stop = function () {
    //...
    this.duration += seconds;
}

// similarly in the reset method we can set this.duration 

Stopwatch.prototype.reset = function () {
    //...
    this.duration = 0;
}

// but THIS WAS A TERRIBLE IDEA 
// why 
// because I CAN CREATE A STOPWATCH HERE 
// new stopwatch and THEN SIMPLY MODIFY THIS DURATION FROM THE OUTSIDE 

const sw = new Stopwatch();
sw.duration = 10;

// this will completely mess up with the state of this object 
// remember this principle 
// YOUR OBJECTS SHOULD ALWAYS BE IN A VALID STATE 
// YOU DON'T WANT YOUR OBJECTS TO LIE 
// YOU DON'T WANT THEM TO BE UNRELIABLE AND UNTRUSTWORTHY 

// THAT'S WHY WE USE ABSTRACTION 
// WITH ABSTRACTION WE HIDE THE UNNECESSARY COMPLEXITY 
// AND EXPOSE VERY FEW MEMBERS THAT WOULD ALLOW 
// THE CLIENTS OF AN OBJECT TO WORK WITH IT 
// WITHOUT MESSING UP THIS STATE 

// so I designed this exercise for you 
// SO YOU CAN SEE THAT SOMETIMES YOU MAKE SOME CHANGES TO YOUR CODE 
// FOR OPTIMIZATION REASONS, BUT YOU END UP CREATING MANY OTHER ISSUES 

// in this program we didn't have any performance problems 
// and we knew that we're not going to have let's say a thousand instances 
// of the stopwatch in the memory 

// SO PUTTING ALL THESE METHODS ON THE PROTOTYPE WAS A VERY BAD IDEA 
// TO START WITH IT BROKE THE ABSTRACTION PRINCIPLE 
// AND NOW WE'RE EXPOSING THIS DURATION PROPERTY 
// SO WE CAN MODIFY IT FROM THE OUTSIDE 

// so ESSENTIALLY THIS STOPWATCH OBJECT IS NOW USELESS 

// there is a FAMOUS SAYING
// "PREMATURE OPTIMIZATION IS THE ROOT OF ALL EVILS" 

// and here we have A REAL EXAMPLE OF PREMATURE OPTIMIZATION

function Stopwatch() {

    let startTime = 0;
    let endTime = 0;
    let running = false;
    let duration = 0;

    Object.defineProperty(this, 'startTime', {
        //writable: false,   // i tried to use these to set read-only flags
        get: function () { return startTime; } // actually needed to make a GETTER
    });

    Object.defineProperty(this, 'endTime', {
        get: function () { return endTime; }
    });

    Object.defineProperty(this, 'running', {
        get: function () { return running; }
    });

    Object.defineProperty(this, 'duration', {
        get: function () { return duration; },
        set: function (value) { duration = value; }
        // we can define a SETTER here for this, but this leads to another problem 
        // because now we can SET the value sw.duration = 10, from the OUTSIDE
        // this goes against the principles of the DVD Player "ABSTRACTION"
    });
}

Stopwatch.prototype.start = function () {
    if (this.running)
        throw new Error('Stopwatch already started.');

    this.running = true;

    this.startTime = new Date();
};

Stopwatch.prototype.stop = function () {
    if (!this.running)
        throw new Error('Stopwatch is not started');

    this.running = false;

    this.endTime = new Date();

    const seconds = (this.endTime.getTime() - this.startTime.getTime()) / 1000;

    this.duration += seconds;
    // duration is a public read only property
    // because currently it doesnt have a SETTER
    // when we give it a SETTER, we can update its value, but also from the OUTSIDE!
};

Stopwatch.prototype.reset = function () {
    this.startTime = 0;
    this.endTime = 0;
    this.running = false;
    this.duration = 0;
};

const sw = new Stopwatch();
sw.duration = 10;




// --------------------------------------------------
// 4.1 Prototypical Inheritance - Creating Your Own Prototypical Inheritance

// so here we have a circle object 
// with a radius property 
// and two methods that are defined on it's prototype 
// you have two draw method 
// and a duplicate method 

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.draw = function () {
    console.log('draw');
}

Circle.prototype.duplicate = function () {
    console.log('duplicate');
}

// now let's imagine tomorrow we're gonna add a square object here 
// and that square object should also have a duplicate method 
// with the exact same implementation 

// WE DON'T WANT TO REPEAT THIS IMPLEMENTATION 
// in other words 
// we don't want to define a square constructor 
// and then redefine the duplicate method 
// and the prototype of this constructor 
// so Square the prototype that duplicate 

function Square() {

}

Square.prototype.duplicate = function () {

}

// WE DON'T WANT TO DO THIS RIGHT 

// INSTEAD WE WANT TO USE INHERITANCE 
// so WE CAN DEFINE A SHAPE OBJECT 
// AND PUT THIS DUPLICATE METHOD THERE 
// AND THEN HAVE CIRCLE AND SQUARE INHERIT IT FROM THE SHAPE OBJECT 

// so let me show you how to do this 
// first I'm gonna delete everything about a square 
// because once you learn how to inherit a circle from a shape 
// you can easily have Square inherit from the shape object 
// so delete 

// now let's define the shape constructor 

// next we want to move this duplicate method 
// and put it on the prototype of the shape 
// so shape that prototype that duplicate okay

// so to make sure we're on the same page
// let's define two objects here one is a shape (S) new Shape
// and the other is a circle (c) new Circle with radius of 1 

function Shape() {

}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);

console.log(s);
console.log(c);

// now back to the console
// so here's our shape 
// IT INHERITS FROM THIS OBJECT WHICH WE CALL shapeBase 
// and in shapeBase we have the duplicate method 
// and as we can see shapeBase INHERITS FROM THIS OBJECT WHICH IS OUR objectBase 
// the root of all objects in JavaScript

// s
// .Shape {}
// ..__proto__: Object  <-- shapeBase (shape inherits from shapeBase)
// ...duplicate:f ()
// ...constructor: f Shape()
// ...__proto__: Object  <-- objectBase (shapeBase inherbits from objectBase)

// okay we have the exact same structure in our circle 
// let's verify that 
// so we have a circle 
// circle has a radius it inherits from let's call this circleBase 
// in circleBase we have the draw method 
// and as you can see a circleBase inherits from objectBase 

// c
// .Circle { radius: 1}
// ..__proto__: Object  <-- circleBase (circle inherits from circleBase)
// ...draw:f ()
// ...constructor: f Shape()
// ...__proto__: Object  <-- objectBase (circleBase inherits from objectBase)

// so here is a visualization of what we have in memory 
// we have this (c) object which inherits from circleBase 
// which is essentially a Circle.prototype 
// and this circleBase inherits from objectBase 

// similarly we have (s) which inherits from shapeBase 
// and this is the same object referenced by Shape.prototype
// and this object inherits from objectBase 

//                      ---> [ objectBase]
//                     |
//        ---> [ circleBase ]
//       |        (Circle.prototype)
//     [ c ]

//                      ---> [ objectBase]
//                     |
//        ---> [ shapeBase ]
//       |        (Shape.prototype)
//     [ s ]


// now TO SETUP INHERITANCE HERE 
// WE WANT TO HAVE circleBase INHERIT FROM shapeBase 

//                                       ---> [ objectBase]
//                                      |
//        ---> [ circleBase ] ---> [ shapeBase ]
//       |      
//     [ c ]

// how do we do this? it's really easy 

// in JavaScript WE HAVE A METHOD FOR CREATING AN OBJECT WITH A GIVEN PROTOTYPE 
// so 

Object.create();

// look at THE ARGUMENT HERE 
// THAT'S THE OBJECT TO USE AS A PROTOTYPE 
// so WE WANT A NEW circleBase OBJECT THAT INHERITS FROM shapeBase INSTEAD OF objectBase right

// now shapeBase is Shape.prototype right 
// so here we pass Shape.prototype
// and THIS RETURNS AN OBJECT THAT INHERITS FROM shapeBase

Object.create(Shape.prototype);

// NOW ALL WE HAVE TO DO IS TO USE THIS OBJECT AS THE PROTOTYPE FOR OUR circles 
// SO WE RESET Circle.prototype TO THIS NEW OBJECT

Circle.prototype = Object.create(Shape.prototype);

// so BEFORE THIS LINE 
// our circleBase or Circle.prototype was like this 
// so Circle.prototype WAS AN OBJECT THAT INHERITED FROM Object.prototype (which we call objectBase)
// right, so THIS WAS THE IMPLICIT RELATIONSHIP 

Circle.prototype = Object.create(Object.prototype); // inherits from objectBase (BEFORE changing the relationship)

// NOW WE CHANGE circleBase or Circle.prototype 
// TO A NEW OBJECT THAT INHERITS FROM Shape.prototype or shapeBase

Circle.prototype = Object.create(Shape.prototype); // inherits from shapeBase (AFTER changing the relationship)

// ok so let's detele this line 
// (Circle.prototype = Object.create(Object.prototype);
// now save the changes 

// back in the console let's look at what we have

// so here's our shape (s)

// s
// .Shape {}
// ..__proto__: Object  <-- [1] shapeBase
// ...duplicate:f () <-- (duplicate method)
// ...constructor: f Shape()
// ...__proto__: Object  <-- [2] objectBase

// [1] shape (s) inherits from shapeBase 
// here we have the duplicate method and
// [2] shapeBase inherits from objectBase 
// so far so good

// now let's take a look at the circle (c)

// c
// .Circle { radius: 1}
// ..radius:1
// ..__proto__: Shape  <-- [1] circleBase (it says Shape here because it shows the PARENT for that Object)
// ...draw:f ()  <-- (draw method)
// ...__proto__: Object  <-- [2] shapeBase (circleBase inherits from shapeBase)
// ....duplicate: f ()   <-- (duplicate method)
// ....constructor: f Shape ()
// ....__proto__: Object <-- [3] objectBase (shapeBase inherits from objectBase)


// [1] so circle (c) INHERITS FROM circleBase 
// ( now don't worry about this Shape here (..__proto__: Shape)
// this doesn't mean that this is the shape object, 
// this is a circleBase object, 
// what you see here (..__proto__: Shape) is the parent for that object, 
// let me explain what I mean, so let's expand this )
// in circleBase we have the draw method, perfect 
// [2] now circleBase INHERITS FROM shapeBase 
// and that's why we have shape here (..__proto__: Shape)
// let's look at the prototype 
// look this is shapeBase, we have the duplicate method 
// [3] and shapeBase INHERITS FROM objectBase

// so now with all this 
// THE CIRCLE OBJECT HAS A DRAW METHOD 

c.draw();

// IT ALSO HAS THE DUPLICATE METHOD THAT IT INHERITS FROM THE SHAPE OBJECT

c.duplicate();

// so THIS IS PROTOTYPICAL INHERITANCE IN ACTION

// FINAL CODE
function Shape() {

}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);




// --------------------------------------------------
// 4.2 Prototypical Inheritance - Resetting the Constructor

// now there's a tiny problem with this implementation 
// let me comment out this line 
// and go back to the console 

function Shape() {

}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius) {
    this.radius = radius;
}

// Circle.prototype = Object.create(Shape.prototype); // Commented Out

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);


// earlier I told you that every object in JavaScript 
// has a constructor property 
// that returns the function that was used 
// to construct or create that object 

// let's take a look at our circle object 
// so this circle 
// look at its prototype this is essentially Circle.prototype 

// c
// .Circle {radius: 1}
// ..__proto__: Object 

// right here we have this constructor property
// which references our circle function 

// c
// .Circle {radius: 1}
// ..__proto__: Object
// ...draw: f ()
// ...constructor: f Circle(radius)   <-- constructor property
// ...__proto__: Object

// now with this technically we can create a circle object 
// like this

Circle.prototype

// that returns this object here right (constructor: f Circle(radius))

// and here we have the constructor property 
// and this returns this circle constructor function right (f Circle(radius))

Circle.prototype.constructor

// so technically we can new up this expression 
// and pass a radius of 1 
// and this returns a circle object 

new Circle.prototype.constructor(1)

// so THIS EXPRESSION IS EQUIVALENT TO 

new Circle(1)

// THEY'RE EXACTLY THE SAME 

// now OBVIOUSLY WE USE THIS FORM BECAUSE IT'S SHORTER AND CLEANER 
// BUT IN SOME RARE CIRCUMSTANCES 
// YOU MAY GET A CONSTRUCTOR FUNCTION SOMEWHERE IN YOUR APPLICATION
// AND YOU MAY WANT TO DYNAMICALLY CREATE AN OBJECT BASED ON THAT CONSTRUCTOR FUNCTION 

// so there YOU CAN ACCESS THE PROTOTYPE PROPERTY 
// AND FROM THERE YOU GET THE CONSTRUCTOR 
// and THEN USE THE NEW OPERATOR 

// now let's see what happens when we uncomment this line 

// Circle.prototype = Object.create(Shape.prototype); // Commented Out

// so back in the console 
// let's take a look at the circle one more time 
// so 

// c
// .Circle {radius: 1}
// radius: 1
// ..__proto__: Shape
// ...draw: f ()
// ...__proto__: Object

// look we no longer have that constructor property here 

// so let's look at the prototype for this object 

// c
// .Circle {radius: 1}
// radius: 1
// ..__proto__: Shape
// ...draw: f ()
// ...__proto__: Object
// ....duplicate: f ()
// ....constructor: f Shape   <-- constructor property (returning the Shape function)
// ....__proto__: Object

// here we have the constructor property 
// but this is returning the Shape function 
// not the Circle function 

// in other words 
// with what we have now 
// WE NO LONGER CAN CREATE CIRCLE OBJECTS BASED ON THIS CONSTRUCTOR IN A DYNAMIC FASHION

// so if we get this circle constructor dynamically in a function 

Circle.

    // and then try to access its prototype property 

    Circle.prototype

// and then the constructor 

Circle.prototype.constructor

// and then new that up 

new Circle.prototype.constructor()
// output:
// Shape {}

// look we get a Shape object not a circle object 

// THE REASON WE'RE HAVING THIS PROBLEM 
// IS BECAUSE WE'VE RESET THE PROTOTYPE OF THE CIRCLE 

// before this line the prototype of the circle had this constructor property 
// so Circle.prototype.constructor this was set to this Circle constructor

Circle.prototype.constructor = Circle;

// that's why we could new up a circle like this 

new Circle.prototype.constructor();

// this is exactly like newing up a circle object right 

new Circle();

// so as a best practice 
// WHENEVER YOU RESET THE PROTOTYPE OF AN OBJECT YOU SHOULD ALSO RESET THE CONSTRUCTOR 

// so here we should set Circle.prototype.constructor
// we should that to the Circle constructor function 

Circle.prototype.constructor = Circle;

// let's save the changes

function Shape() {

}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);


// now let's inspect (c) one more time 

// c
// .Circle {radius: 1}
// ..radius: 1
// ..__proto__: Shape
// ...constructor: f Circle(radius)   <--constructor property is referencing the Circle function
// ...draw: f ()
// ...__proto__: Object
// ....duplicate: f ()
// ....constructor: f Shape()   <--- shapeBase
// ....__proto__: Object

// so here's the prototype for the circle 
// you can see constructor is referencing the circle function beautiful 
// we have the draw method which is part of the prototype for circles 
// and the rest is exactly like before 

// so this is shapeBase or the prototype for shapes 
// where we have the duplicate method

// now we can new up a circle like this so 
// Circle.prototype.constructor has one as the radius
// and we get a circle object 

Circle.prototype.constructor(1)
// output:
// Circle {radius: 1}

// so one more time 
// WHENEVER YOU RESET THE PROTOTYPE 
// AS A BEST PRACTICE MAKE SURE TO RESET THE CONSTRUCTOR AS WELL




// --------------------------------------------------
// 4.3 Prototypical Inheritance - Calling the Super Constructor

// alright now let's take this example to the next level 

// I'm gonna modify the shape constructor and introduce a color parameter 

// we want every shape to have a color 
// so here we set this.color to color 

function Shape(color) { // color parameter introduced
    this.color = color; // color property set
}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius) {
    this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);

// now with the current implementation 
// when we create a circle
// we only pass the radius 
// so if we log (c) on the console 
// we can only see the radius property 
// there is no color here 

// c
// .Circle {radius: 1}
// ..radius: 1
// ..__proto__: Shape

// but from an inheritance point of view 
// this circle object should have a color property 
// and that should be initialized at the time of creating a circle 

// how do we do this? very easy 

// here in the circle constructor 
// we should call the shape constructor 

// now one easy way to do this 
// which actually doesn't work 
// is like this 

// so we call Shape() it's a function right 
// we need to pass a color so let's add the color parameter 
// here and simply pass that to this shape function 

function Circle(radius, color) { // added 2nd parameter color
    Shape(color); // call the Shape function with color parameter

    this.radius = radius;
}

// now let's modify this line 
// where we create a circle object 
// and pass an argument for the color 
// save the changes 
// let's look at the circle (c)

const c = new Circle(1, 'red');
console.log(c)

// c
// .Circle {radius: 1}

// we don't have the color property, we only have the radius 
// why didn't it work?

// well earlier I told you that WHEN YOU USE THE "new" OPERATOR 
// THREE THINGS HAPPEN 
// THIS NEW OPERATOR CREATES A NEW EMPTY OBJECT 
// and THEN SETS "this" TO POINT TO THAT OBJECT 
// so here we set the radius property on that new object 
// and FINALLY THAT NEW OBJECT WILL BE RETURNED FROM THIS CONSTRUCTOR, right 

// also I told you that IF YOU DON'T USE THE "new" OPERATOR 
// this by default will point to the global object which is window 
// in the browser and global in node 

// so the reason this didn't work is because let me put this back here 

// here we're calling the shape function ( Shape(color); )
// and by default this. in this function (Shape) 
// will point to the global object 

// so WE DIDN'T SET THE COLOR PROPERTY ON THE NEW INSTANCE OF THE CIRCLE OBJECT 
// WE SET IT ON THE WINDOW OBJECT 

// let's verify that, window.color, look it's red 

window.color
// output:
// "red"

// so how do we fix this problem 
// WE DON'T WANT TO USE THE NEW OPERATOR HERE 
// BECAUSE THIS WILL CREATE ANOTHER NEW OBJECT 
// AND THEN SET THE COLOR PROPERTY ON THAT OBJECT 

// YOU WANT TO USE THE OBJECT THAT IS REFERENCED BY "this" 

// so TO FIX THIS PROBLEM 
// WE NEED TO CALL THE Shape FUNCTION (inside the code block of function Circle(radius, color))
// AND SET "this" (this.color inside function Shape(color) 
// TO POINT TO THE NEW INSTANCE OF THE CIRCLE OBJECT 

// earlier I told you that every function in JavaScript is an object 
// so 

Shape.;

// this is the shape object with these properties and methods 

// you also learnt about the call method 

// so we can call this Shape function 

Shape.call();

// and look at the first argument of the call method thisArg 
// so the object to be used as the current object

// now here we can pass this 
// and this is the instance of the circle object 

Shape.call(this);

// we're gonna use the same instance here 
// ( in function Shape(color) { this.color = color } )

// alright now we pass our arguments 
// in this case we want to pass the color argument 

Shape.call(this, color);

// and this will solve the problem 
// save the changes back in the console 
// see now our circle has two properties 

function Shape(color) { // color parameter introduced
    this.color = color; // color property set
}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle(radius, color) {
    Shape.call(this, color);

    this.radius = radius;
}

Circle.prototype = Object.create(Shape.prototype);
Circle.prototype.constructor = Circle;

Circle.prototype.draw = function () {
    console.log('draw');
}

const s = new Shape();
const c = new Circle(1);

console.log(c);
// output:
// Circle { color: 'red', radius: 1 }

// so THIS IS HOW YOU CALL THE SUPER CONSTRUCTOR




// --------------------------------------------------
// 4.4 Prototypical Inheritance - Intermediate Function Inheritance

// so we have set up our inheritance chain properly 

// now let's create another object 

// like a square that inherits from the shape 

// so that should be very easy 
// we create a constructor square 
// it takes a size we set the size 

function Square(size) {
    this.size = size;
}

// now we want this square to inherit from the shape 

// so I'm going to copy these two lines for resetting the prototype here
// and then change this to square and square 
// of course we need to change this one more time 

function Square(size) {
    this.size = size;
}
Square.prototype = Object.create(Shape.prototype);
Square.prototype.constructor = Square;

// now with this we can create a square object 
// new square with size 10 

const sq = new Square(10);

// let's inspect this 

// sq
// .Square {size: 10}
// ..size: 10
// ..__proto__
// ...constructor: f Square(size)
// ...__proto__:
// ....duplicate: f ()
// ....constructor: f Shape (color)
// ....__proto__: Object


// so we have the size property 
// here's the prototype 
// we don't have any methods in the prototype for the square 
// let's look at its parent prototype 
// so here we have the duplicate method that we inherited from the shape object 
// so we can call 

square.duplicate();

// and everything works beautifully

// however these two lines 
// for setting up the prototype chain is a little bit noisy 

// and as we define multiple objects this logic gets in the way 
// and chances are you might make a mistake along the way 

// so LET'S REFACTOR THIS CODE 
// and EXTRACT THESE TWO LINES INTO A FUNCTION THAT WE CAN REUSE 

// so here I'M GOING TO DEFINE A FUNCTION CALLED EXTEND 
// THAT TAKES TWO PARAMETERS CHILD AND PARENT 

function extend(Child, Parent) {

}

// and note that here the first letter of these parameters is uppercase 
// because I'm expecting these to be constructor functions 

// so now let's put these two lines inside this function 
// and change Circle to Child and Shape to Parent

function extend(Child, Parent) {
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
}

// NOW WE HAVE ENCAPSULATED THIS LOGIC SOMEWHERE THAT WE CAN REUSE

// so let's put this further up 
// I'm going to put it before the circle constructor

// so we define a constructor 
// and then we can call extend pass Circle and Shape 
// we extend the Circle with the Shape

extend(Circle, Shape);

// and then we can add other stuff in the prototype for circle 

// now let's make the same change for our squares 
// so instead of these two lines here 

// right after we define the constructor function 
// we call extend Square with Shape 

extend(Square, Shape);

// save the changes 
// let's make sure everything works 
// so let's define a square then call duplicate 

const sq = new Square(10);
sq.duplicate();

// beautiful 
// SO THIS EXTEND FUNCTION IS 
// WHAT WE CALL INTERMEDIATE FUNCTION INHERITANCE

function Shape(color) {
    this.color = color;
}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function extend(Child, Parent) {
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
}

function Circle(radius, color) {
    Shape.call(this, color);

    this.radius = radius;
}

extend(Circle, Shape);
// Circle.prototype = Object.create(Shape.prototype);
// Circle.prototype.constructor = Circle;

Circle.prototype.draw = function () {
    console.log('draw');
}

function Square(size) {
    this.size = size;
}

extend(Circle, Shape);
// Square.prototype = Object.create(Shape.prototype);
// Square.prototype.constructor = Square;

const s = new Shape();
const c = new Circle(1);

const sq = new Square(10);

sq.duplicate();





// --------------------------------------------------
// 4.5 Prototypical Inheritance - Method Overriding

// I have simplified the code from the last lecture 
// so we can focus on one concept

// so let's see what we have here 
// we have our extend function
// we have a very simple shape constructor 
// this shape has this duplicate method on its prototype
// after that we have the circle constructor 
// we have the circle inherit from the shape 
// and finally we create a new circle object 

// so now if you go on the console and type 
// c.duplicate()
// we get duplicate on the console 

function extend(Child, Parent) { // extend function
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
}

function Shape() { // shape constructor
}

Shape.prototype.duplicate = function () { // duplicate method on shape prototype
    console.log('duplicate');
}

function Circle() { // circle constructor
}

extend(Circle, Shape); // we have the circle inherit from the shape  

const c = new Circle(1); // we create a new circle object 

c.duplicate();
// output:
// "duplicate"

// now SOMETIMES AS YOU WORK WITH INHERITANCE 
// YOU MAY FACE A SITUATION WHERE 
// THIS IMPLEMENTATION THAT YOU HAVE DEFINED 
// IN A PARENT OBJECT MAY NOT WORK, OR MAY NOT BE IDEAL, IN A CHILD OBJECT 

// so let's imagine this algorithm for duplicating a shape 
// works for most of the shape objects
// but MAYBE IT SHOULD BEHAVE DIFFERENTLY FOR CIRCLE OBJECTS 

// what should we do?
// that's when we use METHOD OVERRIDING 
// so WE OVERRIDE A METHOD THAT IS DEFINED IN THE baseObject 

// and it's very simple 
// all we have to do is to redefine this (Shape.protoype.duplicate) method in the circle object 

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

// so I'm going to copy this 

// here we have the constructor 
// we extend it 
// then after that we redefine this (duplicate method) on circle.prototype 

function Circle() {
}

extend(Circle, Shape);

Circle.prototype.duplicate = function () { // duplicate method on shape prototype
    console.log('duplicate circle');
}


// IT'S VERY IMPORTANT TO PUT THIS AFTER EXTENDING THE CIRCLE 
// BECAUSE AT THIS POINT WE ARE RESETTING THE PROTOTYPE 

// so IF WE DEFINE THIS (Circle.prototype.duplicate) BEFORE RESETTING THE PROTOTYPE 
// THEN THIS IMPLEMENTATION IS GOING TO DISAPPEAR 
// okay, so let's put this back here 

// now in this new implementation 
// I'm gonna change the message to 'duplicate circle'
// save the changes 
// back in the console 

c.duplicate();
// output:
// "duplicate circle"

// note that we get the 'duplicate circle' message

// so THE REASON THIS WORKS GOES BACK TO HOW PROTOTYPICAL INHERITANCE WORKS IN JAVASCRIPT 

// WHEN WE ACCESS A PROPERTY OR A METHOD ON AN OBJECT 
// JAVASCRIPT ENGINE WALKS UP THE PROTOTYPE CHAIN 
// AND PICKS THE FIRST IMPLEMENTATION

// SO EVEN THOUGH IN THIS HIERARCHY WE HAVE IMPLEMENTED THE DUPLICATE METHOD 
// BOTH ON THE PARENT AND CHILD OBJECTS 
// THE IMPLEMENTATION IN THE CHILD OBJECT WILL BE USED 

// now SOMETIMES YOU MAY WANT TO CALL THE IMPLEMENTATION ON THE PARENT OBJECT AS WELL 

// let me show you how to do this 

// so here in (Circle.prototype.duplicate)
// let's imagine we're going to call the duplicate method on the parent or the shapeObject 

// if you're not using this:

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

// in this implementation 

// we can simply call that like a regular function

// so Shape.prototype.duplicate() we call it like this 

Circle.prototype.duplicate = function () {
    Shape.prototype.duplicate();

    console.log('duplicate circle');
}

// now IF YOU'RE USING "this" IN THIS IMPLEMENTATION 
// then WE NEED TO USE THE "call" METHOD TO SET THE CONTEXT FOR "this"

// so we call the call method and pass "this" as the context for the current object

Circle.prototype.duplicate = function () {
    Shape.prototype.duplicate.call(this);

    console.log('duplicate circle');
}

// so save the changes 
// back in the console let's call c.duplicate()

c.duplicate();
// output:
// "duplicate"
// "duplicate circle"

// so first we get the 'duplicate' message 
// which COMES FROM THE IMPLEMENTATION OF DUPLICATE METHOD IN THE shapeObject 
// and then after that we have duplicate circle

function extend(Child, Parent) {
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
}

function Shape() {
}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle() {
}

extend(Circle, Shape);

Circle.prototype.duplicate = function () {
    Shape.prototype.duplicate.call(this);

    console.log('duplicate circle')
}

const c = new Circle();

c.duplicate();




// --------------------------------------------------
// 4.6 Prototypical Inheritance - Polymorphism

// so in the last lecture you learn about METHOD OVERRIDING 
// WHICH BASICALLY MEANS RE-IMPLEMENTING A METHOD IN A CHILD OBJECT 

// now THIS BRINGS US TO 
// A VERY IMPORTANT AND POWERFUL CONCEPT IN OBJECT-ORIENTED PROGRAMMING 
// CALLED POLYMORPHISM 

// poly means many 
// morph means form 
// so POLYMORPHISM MEANS MANY FORMS 

// IT'S AN EXTREMELY POWERFUL TECHNIQUE IN OBJECT-ORIENTED PROGRAMMING 
// as I'm going to show you in a second 

// so continuing from the example from the last lecture

// I'm gonna define a new shape object called square 
// so let's define a constructor square 

function Square() {

}

// now just like the circle you want to have this square inherit from shape 
// so we extend square with shape 

extend(Square, Shape);

// and then we're gonna redefine this duplicate method on the square object 
// so Square.prototype.duplicate 
// and then  let's change this to 'duplicate square'

Square.prototype.duplicate = function () {
    console.log('duplicate square');
}

// so basically WHAT WE HAVE NOW IS A SIMPLE HIERARCHY 
// ON THE TOP WE HAVE THE SHAPE 
// AND WE HAVE TWO DERIVATIVES OR CHILD OBJECTS CIRCLE AND SHAPE 

// EACH OBJECT WILL PROVIDE A DIFFERENT IMPLEMENTATION OF THE DUPLICATE METHOD 

// SO WE HAVE MANY IMPLEMENTATIONS OR MANY FORMS OF THE DUPLICATE METHOD 

// THAT'S WHAT WE CALL **POLYMORPHISM**

function extend(Child, Parent) {
    Child.prototype = Object.create(Parent.prototype);
    Child.prototype.constructor = Child;
}

function Shape() {
}

Shape.prototype.duplicate = function () {
    console.log('duplicate');
}

function Circle() {
}

extend(Circle, Shape);

Circle.prototype.duplicate = function () {
    console.log('duplicate circle')
}

function Square() {
}

extend(Square, Shape);

Square.prototype.duplicate = function () {
    console.log('duplicate square')
}

const c = new Circle();
const sq = new Square();

c.duplicate();
sq.duplicate();

console.log(c.duplicate());
console.log(sq.duplicate());
// output:
// duplicate circle
// duplicate square

// now WHY IS THIS SO POWERFUL? I'll show you 

// so let's imagine we have an array of shape objects 
// so let's define an array 
// in this array I'm going to add two objects a circle and a square 
// in this array I'm going to add two objects a circle and a square 

const shapes = [
    new Circle(),
    new Square()
];

// now we can iterate over this array using for of loop 
// so for let's shape of shapes 
// and then call shape.duplicate

for (let shape of shapes)
    shape.duplicate();

// depending on the type of the shape object 
// a different implementation, or a different form of the duplicate method, will be caught

// so if shape is a circle 
// the implementation of duplicate in the circle object will be caught 
// if it's a square 
// a different implementation will be caught 

// let's have a look 
// save the changes 
// look in the console 

for (let shape of shapes)
    console.log(shape.duplicate());

// output:
// duplicate circle
// duplicate Square

// why is this so powerful? 
// well before object-oriented programming 
// if you wanted to implement this logic we will have to write code like this 

// so in this for loop we would have to check the type of each object 
// let's say shape.type if it's a circle 
// then perhaps we'll have a function somewhere else like duplicateCircle()
// it would have to call that function

// now this function is not part of any objects 
// it's just a standalone function 
// this is the non object-oriented way of writing code 

for (let shape of shapes) {
    if (shape.type === 'circle')
        duplicateCircle();
}

// in object-oriented programming we encapsulate our variables and functions into objects 

// now continuing with this implementation 
// then we would have to check else if shape.type is a square 
// then we'll have to call a different function duplicate Square
// and we can have another if statement else duplicate shape

for (let shape of shapes) {
    if (shape.type === 'circle')
        duplicateCircle();
    else if (shape.type === 'square')
        duplicateSquare();
    else
        duplicateShape();
}

// now this is a very simple program 
// what if we had ten different types of shapes 
// we would end up with eleven conditional statements in this block 

// in contrast when we encapsulate variables and functions into objects 
// and use inheritance 
// we can execute many forms of a method using a single line of code 

// so instead of all this (the if else block), we just call shape.duplicate

for (let shape of shapes)
    shape.duplicate();

// isn't that beautiful

// SO THAT'S POLYMORPHISM IN ACTION




// --------------------------------------------------
// 4.7 Prototypical Inheritance - When To Use Inheritance

// so you have seen inheritance and polymorphism in action 

// while inheritance is a great tool for solving the problem of code reuse

// YOU HAVE TO BE REALLY CAREFUL ABOUT USING IT 
// BECAUSE IT CAN MAKE YOUR SOURCE CODE COMPLEX AND FRAGILE 

// so DON'T USE INHERITANCE JUST FOR THE SAKE OF USING IT 
// especially in small projects 

// as I've always emphasized in all my courses 
// KEEP IT SIMPLE AND STUPID 

// start with simple objects 
// and then IF YOU SEE A NUMBER OF THESE OBJECTS SHARE SIMILAR FEATURES 
// THEN PERHAPS YOU CAN ENCAPSULATE THOSE FEATURES INSIDE OF A GENERIC OBJECT 
// AND USE INHERITANCE 

// but remember INHERITANCE IS NOT THE ONLY SOLUTION 
// TO ENABLE CODE REUSE 
// there is another technique called COMPOSITION 

// which you're going to learn about soon 

// so LET'S SEE THE PROBLEM WITH INHERITANCE 

// here we have this animal object with two methods eat and walk 
// and we have two objects that derive from animal 
// person and dog 

//          ..>  [ Animal ]
//         /         ^    eat()
//        /          |    walk()
//       /           |
//  [ Person ]    [ Dog ]

// now tomorrow we're gonna introduce a new object called goldfish 
// that derives from animal 

// our hierarchy is broken why because goldfish cannot walk 
// it can swim
// so we got the hierarchy wrong and this is something that happens quite
// often especially amongst inexperienced developers

//          ..>  [ Animal ]    <....
//         /         ^    eat()     \
//        /          |    walk()     \
//       /           |                \
//  [ Person ]    [ Dog ]        [ Goldfish ]

// so to solve this problem we need to change our hierarchy 

// on the top we should have the animal object with the eat method 
// under that we're gonna have two objects mammal and fish 
// mammals can walk, fish can swim 
// and then we can have person and dog derive from mammal
// and goldfish derive from fish

//                  ..> [ Animal ] <.
//                 /        eat()    \
//                |                  |
//          [ Mammal ]            [ Fish ]
//        /   walk() |               | swim()
//       /           |               |
//  [ Person ]    [ Dog ]        [ Goldfish ]

// see what happened 
// as a result of introducing a new kind of animal 
// that is goldfish 

// we had to change our hierarchy 
// and now this hierarchy is more complex than what we had before

// now what would happen if we had ten different types of animals 
// this hierarchy would get more and more complex 
// and we have to constantly go back and forth to determine 
// the right place to implement a method 

// so 
// AVOID CREATING INHERITANCE HIERARCHIES 
// because they are very fragile 

// IF YOU WANT TO USE INHERITANCE KEEP TO ONE LEVEL 
// DO NOT GO MORE THAN ONE LEVEL OF INHERITANCE 

// there is a famous saying that says 
// "FAVOUR COMPOSITION OVER INHERITANCE" 

// with composition instead of having a complex hierarchy like this (above) 

// we can compose a few objects together 
// to create a new object 
// and this technique gives us great flexibility 

// so back to our previous example 
// instead of using inheritance 
// we can define various features for our animals as independent objects 

// so we can have three objects like 

//  (canWalk)   (canEat)   (canSwim)

// each of these objects are plain JavaScript objects 
// with certain properties and methods 

// now we want to have a person object 
// okay, we simply compose canWalk and canEat to create a person object

// tomorrow we want to introduce a goldfish 
// awesome, we can compose canEat and canSwim together 
// to produce a goldfish 

//  (canWalk)   (canEat)   (canSwim)

// [ Person ]           [ Goldfish ]

// so we don't have a hierarchy and we can come up with 
// any combination of these objects to create new objects 

// in JavaScript we can use Mix-Ins to achieve composition 
// and that's what you're gonna see in the next lecture
    </code></pre>
    <script src=prism.js></script>
</body>

</html>